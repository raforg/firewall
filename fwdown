#!/bin/sh
#
# firewall: http://www.zip.com.au/~raf2/lib/software/firewall
#
# Copyright (C) 1999, 2000 raf <raf2@zip.com.au>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
# or visit http://www.gnu.org/copyleft/gpl.html
#

# fwdown - Brings down an ipchains packet filtering firewall
#
# Run this after all network interfaces are down
# (i.e. after /etc/rc.d/rc?.d/K??network stop)
#
# 20000430 raf <raf2@zip.com.au>

##############################################################################
# Usage: [policy=filename] fwdown
#
# The policy variable determines the policy file to implement.
# It is /etc/firewall.policy by default.
#

##############################################################################
# Start by checking that we've got everything we need
#

# Set the path explicitly

PATH=/sbin:/usr/sbin:/bin:/usr/bin

# Define a version of redhat's action function that copes with functions

RES_COL=60
[ -z "$COLUMNS" ] && COLUMNS=80
MOVE_TO_COL="echo -en \\033[300C\\033[$[${COLUMNS}-${RES_COL}]D"
SETCOLOR_SUCCESS="echo -en \\033[1;32m"
SETCOLOR_FAILURE="echo -en \\033[1;31m"
SETCOLOR_NORMAL="echo -en \\033[0;39m"

log()
{
	[ -z "$PROG_NAME" ] && PROG_NAME="`basename $0`"
	logger -t "$PROG_NAME" -p daemon.notice $*
}

success()
{
	local msg="$1"
	log $msg succeeded
	echo -n $msg
	$MOVE_TO_COL
	echo -n "[  "
	$SETCOLOR_SUCCESS
	echo -n "OK"
	$SETCOLOR_NORMAL
	echo "  ]"
	return 0
}

failure()
{
	local msg="$1"
	log $msg failed
	echo -n $msg
	$MOVE_TO_COL
	echo -n "["
	$SETCOLOR_FAILURE
	echo -n "FAILED"
	$SETCOLOR_NORMAL
	echo "]"
	return 1
}

action()
{
	local msg="$1"; shift
	$* && success "$msg" || failure "$msg"
}

# Source the network configuration (if redhat)

[ -r /etc/sysconfig/network ] && . /etc/sysconfig/network

# Check that networking is required

[ "$NETWORKING" = "no" ] && exit 0

# Check that ipchains is available

if [ ! -x /sbin/ipchains ]
then
	log -s "failed to find executable /sbin/ipchains"
	exit 1
fi

# Check that ip is available if static NAT

case "$STATIC_NAT" in
	[Yy]es|[Tt]rue|[Oo]n|1)
		log -s "STATIC_NAT is not yet implemented"
		exit 1
		if [ ! -x /sbin/ip ]
		then
			log -s "failed to find executable /sbin/ip (required for static NAT)"
			exit 1
		fi
		;;
esac

# Check that ip is available if alias masquerading

case "$ALIAS_MASQUERADING" in
	[Yy]es|[Tt]rue|[Oo]n|1)
		log -s "ALIAS_MASQUERADING is not yet implemented"
		exit 1
		if [ ! -x /sbin/ip ]
		then
			log -s "failed to find executable /sbin/ip (required for alias masquerading)"
			exit 1
		fi
		PORT_FORWARDING="yes"
		;;
esac

# Check that ipmasqadm is available if port forwarding or alias masquerading

case "$PORT_FORWARDING" in
	[Yy]es|[Tt]rue|[Oo]n|1)
		if [ ! -x /usr/sbin/ipmasqadm ]
		then
			log -s "failed to find executable /usr/sbin/ipmasqadm (required for port forwarding)"
			exit 1
		fi
		;;
esac

# Check that the policy file is available

[ -z "$policy" ] && policy=/etc/firewall.policy

if [ ! -r $policy ]
then
	log -s "failed to find readable $policy"
	exit 1
fi

# Source the policy file

. $policy

##############################################################################
# Stop IP Port Forwarding
#

case "$PORT_FORWARDING" in
	[Yy]es|[Tt]rue|[Oo]n|1)
		action "Stopping IP Port Forwarding" ipmasqadm portfw -f
		;;
esac

##############################################################################
# Stop IP Packet Forwarding
#

ipv4=/proc/sys/net/ipv4

# Do we need to stop forwarding?

stop_forwarding="0"

case "$FORWARDING" in
	[Yy]es|[Tt]rue|[Oo]n|1)
		stop_forwarding="1"
		;;
esac

case "$MASQUERADING" in
	[Yy]es|[Tt]rue|[Oo]n|1)
		stop_forwarding="1"
		;;
esac

case "$STATIC_NAT" in
	[Yy]es|[Tt]rue|[Oo]n|1)
		stop_forwarding="1"
		;;
esac

# Don't override /etc/sysconfig/network (if redhat)

case "$FORWARD_IPV4" in
	[Yy]es|[Tt]rue|[Oo]n|1)
		stop_forwarding="0"
		;;
esac

if [ "$stop_forwarding" = "1" ]
then
	do_stop_forwarding()
	{
		[ -w $ipv4/ip_forward ] && echo 0 > $ipv4/ip_forward
	}

	action "Stopping IP Packet Forwarding" do_stop_forwarding
fi

##############################################################################
# Stop Dynamic IP Address Hacking in IP MASQ
#

case "$IPV4_DYNADDR" in
	[Yy]es|[Tt]rue|[Oo]n|1)
		do_stop_dynaddr()
		{
			[ -w $ipv4/ip_dynaddr ] && echo 0 > $ipv4/ip_dynaddr
		}

		action "Stopping Dynamic IP Address Hacking in IP MASQ" do_stop_dynaddr
		;;
esac

##############################################################################
# Stop IP Martian Logging
#

case "$IPV4_LOG_MARTIANS" in
	[Nn]o|[Ff]alse|[Oo]ff|0)
		;;
	*)
		do_stop_martian()
		{
			if [ -w $ipv4/conf/all/log_martians ]
			then
				for procfile in $ipv4/conf/*/log_martians
				do
					echo 0 > $procfile
				done
			fi
		}

		action "Stopping IP Martian Logging" do_stop_martian
		;;
esac

##############################################################################
# Stop IP Bogus Error Response Protection
#

case "$IPV4_BOGUS_ERROR_RESPONSE_PROTECT" in
	[Nn]o|[Ff]alse|[Oo]ff|0)
		;;
	*)
		do_stop_bogus()
		{
			[ -w $ipv4/icmp_ignore_bogus_error_responses ] && echo 0 > $ipv4/icmp_ignore_bogus_error_responses
		}

		action "Stopping IP Bogus Error Response Protection" do_stop_bogus
		;;
esac

##############################################################################
# Stop IP ICMP Broadcast Echo Protection
#

case "$IPV4_ICMP_BROADCAST_ECHO_PROTECT" in
	[Nn]o|[Ff]alse|[Oo]ff|0)
		;;
	*)
		do_stop_icmp()
		{
			[ -w $ipv4/icmp_echo_ignore_broadcasts ] && echo 0 > $ipv4/icmp_echo_ignore_broadcasts
		}

		action "Stopping IP ICMP Broadcast Echo Protection" do_stop_icmp
		;;
esac

##############################################################################
# Stop IP Fragment Protection
#

case "$IPV4_FRAGMENT_PROTECT" in
	[Nn]o|[Ff]alse|[Oo]ff|0)
		;;
	*)
		do_stop_fragment()
		{
			[ -w $ipv4/ip_always_defrag ] && echo 0 > $ipv4/ip_always_defrag
		}

		action "Stopping IP Fragment Protection" do_stop_fragment
		;;
esac

##############################################################################
# Stop IP TCP SYN Cookie Protection
#

case "$IPV4_TCP_SYN_COOKIE_PROTECT" in
	[Nn]o|[Ff]alse|[Oo]ff|0)
		;;
	*)
		do_stop_syncookie()
		{
			[ -w $ipv4/tcp_syncookies ] && echo 0 > $ipv4/tcp_syncookies
		}

		action "Stopping IP TCP SYN Cookie Protection" do_stop_syncookie
		;;
esac

##############################################################################
# Stop IP ICMP Redirect Protection
#

case "$IPV4_ICMP_REDIRECT_PROTECT" in
	[Nn]o|[Ff]alse|[Oo]ff|0)
		;;
	*)
		do_stop_redirect()
		{
			if [ -w $ipv4/conf/all/accept_redirects ]
			then
				for procfile in $ipv4/conf/*/accept_redirects
				do
					echo 1 > $procfile
				done
			fi
		}

		action "Stopping IP ICMP Redirect Protection" do_stop_redirect
		;;
esac

##############################################################################
# Stop IP Source Routing Protection
#

case "$IPV4_SOURCE_ROUTE_PROTECT" in
	[Nn]o|[Ff]alse|[Oo]ff|0)
		;;
	*)
		do_stop_sourceroute()
		{
			if [ -w $ipv4/conf/all/accept_source_route ]
			then
				for procfile in $ipv4/conf/*/accept_source_route
				do
					echo 1 > $procfile
				done
			fi
		}

		action "Stopping IP Source Routing Protection" do_stop_sourceroute
		;;
esac

##############################################################################
# Stop IP Source Address Verification
#

case "$IPV4_SPOOF_PROTECT" in
	[Nn]o|[Ff]alse|[Oo]ff|0)
		;;
	*)
		do_stop_spoof()
		{
			if [ -w $ipv4/conf/all/rp_filter ]
			then
				for procfile in $ipv4/conf/*/rp_filter
				do
					echo 0 > $procfile
				done
			fi
		}

		action "Stopping IP Source Address Verification" do_stop_spoof
		;;
esac

##############################################################################
# Unload IP Masquerading Modules
#

case "$MASQUERADING" in
	[Yy]es|[Tt]rue|[Oo]n|1)
		if [ -r /proc/modules -a -n "$MASQ_MODULES" ]
		then
			do_unload_modules()
			{
				local loaded="0" unloaded="0" module

				for module in $MASQ_MODULES
				do
					if grep ip_masq_$module /proc/modules >/dev/null
					then
						loaded="`expr $loaded + 1`"
						rmmod ip_masq_$module && unloaded="`expr $unloaded + 1`"
					fi
				done

				[ "$loaded" = "$unloaded" ]
			}

			action "Unloading IP Masquerading Modules" do_unload_modules
		fi
		;;
esac

##############################################################################
# Stop IP Packet Filter
#

do_stop_filter()
{
	# Remove any existing rules/chains

	ipchains -F
	ipchains -X

	# Set policies for the built-in chains

	ipchains -P input ACCEPT
	ipchains -P output ACCEPT
	ipchains -P forward ACCEPT
}

action "Stopping IP Packet Filter" do_stop_filter

exit 0

# vi:set ts=4 sw=4:
