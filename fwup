#!/bin/bash
#
# firewall: http://www.zip.com.au/~raf2/lib/software/firewall
#
# Copyright (C) 1999, 2000 raf <raf2@zip.com.au>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
# or visit http://www.gnu.org/copyleft/gpl.html
#

# fwup - Brings up an ipchains packet filtering firewall
#
# Run this before any network interfaces are up
# (i.e. before /etc/rc.d/rc?.d/S??network start)
# and after receiving a dynamic IP address.
#
# Define policy in /etc/firewall.policy
# Read it carefully
#
# 20000421 raf <raf2@zip.com.au>

##############################################################################
# Usage: [policy=filename] [fwdebug=1] fwup
#
# The policy variable determines the policy file to implement.
# It is /etc/firewall.policy by default.
#
# The fwdebug variable causes ipchains, ipmasqadm and ip commands
# to be printed on standard error as they are executed.
#

##############################################################################
# Start by checking that we've got everything we need
#

# Set the path explicitly

PATH=/sbin:/usr/sbin:/bin:/usr/bin

# Source the function library

if [ -r /etc/rc.d/init.d/functions ]
then
	. /etc/rc.d/init.d/functions
else
	# Define a crappy version of redhat's action function
	action()
	{
		echo -n "$1 "; shift
		$* && echo "[ OK ]" || echo "[ FAILED ]"
	}
fi

# Source the network configuration (if redhat)

[ -r /etc/sysconfig/network ] && . /etc/sysconfig/network

# Check that networking is required

[ "$NETWORKING" = "no" ] && exit 0

# Check that ipchains is available

if [ ! -x /sbin/ipchains ]
then
	echo "$0: failed to find executable /sbin/ipchains" >&2
	exit 1
fi

# Check that ifconfig is available

if [ ! -x /sbin/ifconfig ]
then
	echo "$0: failed to find executable /sbin/ifconfig" >&2
	exit 1
fi

# Check for other protocols that we might need

grep '^ospf' /etc/protocols >/dev/null && OSPF_PROTOCOL="1"
grep '^pptp' /etc/protocols >/dev/null && PPTP_PROTOCOL="1"
grep '^esp' /etc/protocols >/dev/null && ESP_PROTOCOL="1"
grep '^ah' /etc/protocols >/dev/null && AH_PROTOCOL="1"

# Check that the policy file is available

[ -z "$policy" ] && policy=/etc/firewall.policy

if [ ! -r $policy ]
then
	echo "$0: failed to find readable $policy" >&2
	exit 1
fi

# Check for ipmasqadm and ip later, iff they are needed

##############################################################################
# Define some network addresses
#

# Matches every ip address

any="0/0"

# Broadcast source addess

broadcast_src="0.0.0.0/32"

# Broadcast destination address

broadcast_dst="255.255.255.255/32"

# The loopback address (never to appear on the internet)

loopback="127.0.0.0/8"

# Class A, B and C private addresses (never to appear on the internet)

private_a="10.0.0.0/8"
private_b="172.16.0.0/12"
private_c="192.168.0.0/16"

# Class D multicast address

multicast="224.0.0.0/4"

# Class E reserved address

reserved="240.0.0.0/5"

# Illegal addresses

ILLEGAL_NETWORKS="$loopback $private_a $private_b $private_c"

# Reserved addresses

RESERVED_NETWORKS="1.0.0.0/8 2.0.0.0/8 5.0.0.0/8 7.0.0.0/8 23.0.0.0/8 27.0.0.0/8 31.0.0.0/8 37.0.0.0/8 39.0.0.0/8 41.0.0.0/8 42.0.0.0/8 49.0.0.0/8 50.0.0.0/8 58.0.0.0/7 60.0.0.0/8 65.0.0.0/8 66.0.0.0/8 67.0.0.0/8 68.0.0.0/8 69.0.0.0/8 70.0.0.0/8 71.0.0.0/8 72.0.0.0/8 73.0.0.0/8 74.0.0.0/8 75.0.0.0/8 76.0.0.0/8 77.0.0.0/8 78.0.0.0/8 79.0.0.0/8 80.0.0.0/4 96.0.0.0/4 112.0.0.0/8 113.0.0.0/8 114.0.0.0/8 115.0.0.0/8 116.0.0.0/8 117.0.0.0/8 118.0.0.0/8 119.0.0.0/8 120.0.0.0/8 121.0.0.0/8 122.0.0.0/8 123.0.0.0/8 124.0.0.0/8 125.0.0.0/8 126.0.0.0/8 197.0.0.0/8 217.0.0.0/8 218.0.0.0/8 219.0.0.0/8 220.0.0.0/6"

##############################################################################
# Determine some system specific port numbers
#

ipv4=/proc/sys/net/ipv4

# Range of local return port numbers

if [ -r $ipv4/ip_local_port_range ]
then
	normal_ports=`sed 's/\W/:/' < $ipv4/ip_local_port_range`
else
	normal_ports="1024:"
fi

# Range of port numbers used for masquerading
# These are defined in /usr/src/linux/include/net/ip_masq.h
# Note: This only works if the source reflects the currently running kernel

[ -z "$masq_ports" ] && masq_ports=`perl -e '

	my $min;
	my $max;

	if (open(MASQ, "/usr/src/linux/include/net/ip_masq.h"))
	{
		while (<MASQ>)
		{
			/^\s*#\s*define\s+PORT_MASQ_BEGIN\s+(\d+)/ and do
			{
				$min = $1;
				next;
			};

			/^\s*#\s*define\s+PORT_MASQ_END\s+(\([^)]+\))/ and do
			{
				$max = $1;
				$max =~ s/PORT_MASQ_BEGIN/\$min/;
				$max = eval $max;
				last;
			};
		}

		close(MASQ);
	}

	$min = 61000 unless defined $min and $min =~ /^\d+$/;
	$max = 65096 unless defined $max and $max =~ /^\d+$/;

	print "$min:$max\n";

'`

##############################################################################
# Define some default port numbers. You can override these in the policy file.
#

# Range of X Window server ports to avoid like the plague

XWIN_PORTS="6000:6063"

# List of other tcp ports to avoid like the plague (NFS, SOCKS, OpenWindows)

EVIL_TCP_PORTS="2049 1080 2000"

# Allowable HTTP server port numbers (this is stupid, use a proxy)

EXTERNAL_HTTP_PORTS="80 81 800 8000 8080 8088"
INTERNAL_HTTP_PORTS="80"

# Allowable HTTPS server port numbers (this is stupid, use a proxy)

EXTERNAL_HTTPS_PORTS="443"
INTERNAL_HTTPS_PORTS="443"

# Allowable HTTP PROXY server port numbers

EXTERNAL_HTTP_PROXY_PORTS="8080"
INTERNAL_HTTP_PROXY_PORTS="8080"

# Allowable GOPHER server port numbers (this is stupid, use a proxy)

EXTERNAL_GOPHER_PORTS="70"
INTERNAL_GOPHER_PORTS="70"

# Allowable WAIS server port numbers (this is stupid, use a proxy)

EXTERNAL_WAIS_PORTS="210"
INTERNAL_WAIS_PORTS="210"

# Allowable udp ports used by traceroute

ITRACEROUTE_SRC_PORTS="32769:65535"
ITRACEROUTE_DST_PORTS="33434:33523"
OTRACEROUTE_SRC_PORTS="32769:65535"
OTRACEROUTE_DST_PORTS="33434:33523"

# Allowable tcp ports used by ssh1

[ -z "$SSH1_PORTS" ] && SSH1_PORTS="513:1023"

# Allowable icmp packet types

OTHER_INCOMING_ICMP="3 4 11 12"
OTHER_OUTGOING_ICMP="fragmentation-needed 4 11 12"

##############################################################################
# Define some default timeout values used for masquerading. You can override
# these in the policy file
#

# Timeout in seconds for masqueraded tcp addresses
# Zero means leave the timeout as it is

MASQ_TCP_TIMEOUT="0"

# Timeout in seconds for masqueraded tcp addresses after receiving FIN
# Zero means leave the timeout as it is

MASQ_TCPFIN_TIMEOUT="0"

# Timeout in seconds for masqueraded udp addresses
# Zero means leave the timeout as it is

MASQ_UDP_TIMEOUT="0"

##############################################################################
# Load the IP packet filtering policy and check it
#

# Source the policy file

. $policy

# Check that $TRUSTED_INTERFACES is defined (at least lo)

if [ -z "$TRUSTED_INTERFACES" ]
then
	echo "$0: \$TRUSTED_INTERFACES must be defined in $policy (e.g. TRUSTED_INTERFACES=\"eth0 lo\")" >&2
	exit 1
fi

trusted_interfaces="$TRUSTED_INTERFACES"

# If $INTERNAL_NETWORKS isn't defined, derive it from $trusted_interfaces

[ -z "$INTERNAL_NETWORKS" ] && INTERNAL_NETWORKS="`ifconfig | perl -e '

	my %network = ();
	my $iface = undef;

	while (<STDIN>)
	{
		if (defined $iface && $_ =~ /inet addr:(\d+\.\d+\.\d+\.\d+)\s+.*\s+Mask:(\d+\.\d+\.\d+\.\d+)/)
		{
			my $network = $1 . "/" . $2;
			$network{$iface} = (exists $network{$iface}) ? ($network{$iface} . " " . $network) : $network;
			$iface = undef;
			next;
		}

		my ($if) = $_ =~ /^(\S+)\s/;
		next unless defined $if;
		my ($device, $alias) = $if =~ /^([^:]+):(\d+)$/;
		$iface = (defined $device && defined $alias) ? $device : $if;
	}

	for (@ARGV)
	{
		next if $_ eq "lo";
		next unless exists $network{$_};
		print $network{$_}, " ";
	}

' $trusted_interfaces`"

# Check that $UNTRUSTED_INTERFACES is defined

if [ -z "$UNTRUSTED_INTERFACES" ]
then
	echo "$0: \$UNTRUSTED_INTERFACES must be defined in $policy (e.g. UNTRUSTED_INTERFACES=\"ppp0\")" >&2
	exit 1
fi

untrusted_interfaces="$UNTRUSTED_INTERFACES"

# Check that there aren't too many interfaces listed in $UNTRUSTED_INTERFACES

if [ "`perl -e 'print $#ARGV' $untrusted_interfaces`" -gt 9 ]
then
	echo "$0: Too many untrusted interfaces (only supports 10)" >&2
	exit 1
fi

# Find the IP addresses of the untrusted interfaces (if they are up).
# These addresses will be used in the packet rules. If any of the
# interfaces aren't up yet, we will use $any in the packet rules.
# If any interfaces have aliases, we treat their addresses as being
# equal for that interface.

untrusted_addresses="`ifconfig | perl -e '

	my %iface = ();
	my $iface = undef;

	while (<STDIN>)
	{
		if (defined $iface && $_ =~ /inet addr:(\d+\.\d+\.\d+\.\d+)\s/)
		{
			$iface{$iface} = (exists $iface{$iface}) ? ($iface{$iface} . "," . $1) : $1;
			$iface = undef;
			next;
		}

		my ($if) = $_ =~ /^(\S+)\s/;
		next unless defined $if;
		my ($device, $alias) = $if =~ /^(\w+):(\d+)$/;
		$iface = (defined $device && defined $alias) ? $device : $if;
	}

	for (@ARGV)
	{
		print(((exists $iface{$_}) ? $iface{$_} : "'$any'") , " ");
	}

' $untrusted_interfaces`"

# Check the network topology variables

# Static NAT requires iproute2
case "$STATIC_NAT" in
	[Yy]es|[Tt]rue|[Oo]n|1)
		echo "$0: STATIC_NAT is not yet implemented" >&2
		exit 1
		# Check that ip is available
		if [ ! -x /sbin/ip ]
		then
			echo "$0: failed to find executable /sbin/ip (required for static NAT)" >&2
			exit 1
		fi
		;;
esac

# Alias masquerading requires iproute2 and implies port forwarding
case "$ALIAS_MASQUERADING" in
	[Yy]es|[Tt]rue|[Oo]n|1)
		echo "$0: ALIAS_MASQUERADING is not yet implemented" >&2
		exit 1
		# Check that ip is available
		if [ ! -x /sbin/ip ]
		then
			echo "$0: failed to find executable /sbin/ip (required for alias masquerading)" >&2
			exit 1
		fi
		# Implies PORT_FORWARDING
		PORT_FORWARDING="yes"
		;;
esac

# Port forwarding requires ipmasqadm and implies masquerading
case "$PORT_FORWARDING" in
	[Yy]es|[Tt]rue|[Oo]n|1)
		# Check that ipmasqadm is available
		if [ ! -x /usr/sbin/ipmasqadm ]
		then
			echo "$0: failed to find executable /usr/sbin/ipmasqadm (required for port forwarding)" >&2
			exit 1
		fi
		# Implies MASQUERADING
		MASQUERADING="yes"
		;;
esac

# If masquerading is required, check that $INTERNAL_NETWORKS is defined.
# Also check that at most one of MASQUERADING, FORWARDING and STATIC_NAT has
# been requested. They are mutually exclusive.

case "$FORWARDING" in
	[Yy]es|[Tt]rue|[Oo]n|1)
		if [ -z "$INTERNAL_NETWORKS" ]
		then
			echo "$0: \$INTERNAL_NETWORKS must be defined in $policy (e.g. INTERNAL_NETWORKS=\"192.168.1.0/24\")" >&2
			exit 1
		fi

		case "$MASQUERADING" in
			[Yy]es|[Tt]rues|[Oo]n|1)
				echo "$0: \$FORWARDING and \$MASQUERADING are mutually exclusive" >&2
				exit 1
				;;
		esac

		case "$STATIC_NAT" in
			[Yy]es|[Tt]rues|[Oo]n|1)
				echo "$0: \$FORWARDING and \$STATIC_NAT are mutually exclusive" >&2
				exit 1
				;;
		esac
		;;
esac

case "$MASQUERADING" in
	[Yy]es|[Tt]rue|[Oo]n|1)
		if [ -z "$INTERNAL_NETWORKS" ]
		then
			echo "$0: \$INTERNAL_NETWORKS must be defined in $policy (e.g. INTERNAL_NETWORKS=\"192.168.1.0/24\")" >&2
			exit 1
		fi

		case "$FORWARDING" in
			[Yy]es|[Tt]rues|[Oo]n|1)
				echo "$0: \$MASQUERADING and \$FORWARDING are mutually exclusive" >&2
				exit 1
				;;
		esac

		case "$STATIC_NAT" in
			[Yy]es|[Tt]rues|[Oo]n|1)
				echo "$0: \$MASQUERADING and \$STATIC_NAT are mutually exclusive" >&2
				exit 1
				;;
		esac
		;;
esac

case "$STATIC_NAT" in
	[Yy]es|[Tt]rue|[Oo]n|1)
		if [ -z "$INTERNAL_NETWORKS" ]
		then
			echo "$0: \$INTERNAL_NETWORKS must be defined in $policy (e.g. INTERNAL_NETWORKS=\"192.168.1.0/24\")" >&2
			exit 1
		fi

		case "$MASQUERADING" in
			[Yy]es|[Tt]rues|[Oo]n|1)
				echo "$0: \$STATIC_NAT and \$MASQUERADING are mutually exclusive" >&2
				exit 1
				;;
		esac

		case "$FORWARDING" in
			[Yy]es|[Tt]rues|[Oo]n|1)
				echo "$0: \$STATIC_NAT and \$FORWARDING are mutually exclusive" >&2
				exit 1
				;;
		esac
		;;
esac

# Check that $OCDNS_SERVERS or $OSDNS_SERVERS is defined or really obvious

[ -z "$OCDNS_SERVERS" ] && OCDNS_SERVERS="`awk '/^nameserver/ { if ($2 != "127.0.0.1") { printf "%s/32\n", $2 } }' /etc/resolv.conf`"
if [ -z "$OCDNS_SERVERS$OSDNS_SERVERS" ]
then
	echo "$0: Either \$OCDNS_SERVERS or \$OSDNS_SERVERS must be defined in $policy" >&2
	exit 1
fi

# Log all denied/rejected packets except those in the "NOLOG" variables

case "$LOG" in
	[Nn]o|[Ff]alse|[Oo]ff|0)
		LOG=""
		;;
	*)
		LOG="-l"
		;;
esac

# Set the blocking policies

[ -z "$BLOCKIN" ] && BLOCKIN="DENY"
[ -z "$BLOCKOUT" ] && BLOCKOUT="REJECT"
[ -z "$BLOCKFWD" ] && BLOCKFWD="REJECT"

##############################################################################
# Debugging
#

ipchains()
{
	case "$fwdebug" in
		[Yy]es|[Tt]rue|[Oo]n|1)
			echo ipchains $* >&2
			;;
	esac

	/sbin/ipchains $*
}

ipmasqadm()
{
	case "$fwdebug" in
		[Yy]es|[Tt]rue|[Oo]n|1)
			echo ipmasqadm $* >&2
			;;
	esac

	/usr/sbin/ipmasqadm $*
}

ip()
{
	case "$fwdebug" in
		[Yy]es|[Tt]rue|[Oo]n|1)
			echo ip $* >&2
			;;
	esac

	/sbin/ip $*
}

##############################################################################
# Helper functions.
#

# chain basename index
#
# Create a chain if it doesn't already exist

chain()
{
	local name=$1 index=$2
	eval [ -z "\$chain_$name$index" ] && ipchains -N $name$index
	eval chain_$name$index="1"
}

# chains basename index
#
# Create input and output chains by prepending 'i' and 'o', respectively,
# to basename and appending index

chains()
{
	local base=$1 index=$2
	chain i$base $index
	chain o$base $index
}

# domasq index
#
# Returns 1 if masquerading is required on the current interface, 0 otherwise

domasq()
{
	local index=$1
	case "$MASQUERADING" in
		[Yy]es|[Tt]rue|[Oo]n|1)
			[ "$index" = "0" ] && return 0
			;;
	esac
	return 1
}

# tcp chain1 chain2 srcaddr srcport dstaddr dstport
#
# Accept a tcp service from src to dst on chain1 and replies on chain2

tcp()
{
	local chain1=$1 chain2=$2 srcaddr=$3 srcport=$4 dstaddr=$5 dstport=$6
	ipchains -A $chain1 -p tcp -s $srcaddr $srcport -d $dstaddr $dstport -j ACCEPT
	ipchains -A $chain2 -p tcp -s $dstaddr $dstport -d $srcaddr $srcport ! -y -j ACCEPT
}

# tcpmasq chain1 chain2 srcaddr srcport dstaddr dstport
#
# Accept an outgoing tcp service for this host and masqueraded hosts

tcpmasq()
{
	local chain1=$1 chain2=$2 srcaddr=$3 srcport=$4 dstaddr=$5 dstport=$6
	tcp $chain1 $chain2 $srcaddr $srcport $dstaddr $dstport
	tcp $chain1 $chain2 $srcaddr $masq_ports $dstaddr $dstport
}

# tcpm index chain1 chain2 srcaddr srcport dstaddr dstport
#
# Accept an outgoing tcp service for this host and masqueraded hosts if
# masquerading and this is on the first untrusted interface. Just accept
# the tcp service as stated, otherwise.

tcpm()
{
	local index=$1 chain1=$2 chain2=$3 srcaddr=$4 srcport=$5 dstaddr=$6 dstport=$7
	if domasq $index
	then
		tcpmasq $chain1 $chain2 $srcaddr $srcport $dstaddr $dstport
	else
		tcp $chain1 $chain2 $srcaddr $srcport $dstaddr $dstport
	fi
}

# tcpno chain1 chain2 srcaddr srcport dstaddr dstport target1 target2
#
# Deny a tcp service: On chain1, make tcp src to dst jump to target1. On
# chain2, make tcp dst to src responses jump to target2. If chain1 is the
# input chain and chain2 is the output chain, target1 should be deny and
# target2 should be reject. If chain1 is the output chain and chain2 is the
# input chain, target1 should be reject and target2 should be deny.

tcpno()
{
	local chain1=$1 chain2=$2 srcaddr=$3 srcport=$4 dstaddr=$5 dstport=$6 target1=$7 target2=$8
	ipchains -A $chain1 -p tcp -s $srcaddr $srcport -d $dstaddr $dstport -j $target1 $LOG
	ipchains -A $chain2 -p tcp -s $dstaddr $dstport -d $srcaddr $srcport ! -y -j $target2 $LOG
}

# tcpmasqno chain1 chain2 srcaddr srcport dstaddr dstport target1 target2
#
# Deny an outgoing tcp service for this host and masqueraded hosts

tcpmasqno()
{
	local chain1=$1 chain2=$2 srcaddr=$3 srcport=$4 dstaddr=$5 dstport=$6 target1=$7 target2=$8
	tcpno $chain1 $chain2 $srcaddr $srcport $dstaddr $dstport $target1 $target2
	tcpno $chain1 $chain2 $srcaddr $masq_ports $dstaddr $dstport $target1 $target2
}

# tcpmno chain1 chain2 srcaddr srcport dstaddr dstport target1 target2
#
# Deny an outgoing tcp service for this host and masqueraded hosts if
# masquerading and this is on the first untrusted interface. Just deny
# the tcp service as stated, otherwise.

tcpmno()
{
	local index=$1 chain1=$2 chain2=$3 srcaddr=$4 srcport=$5 dstaddr=$6 dstport=$7 target1=$8 target2=$9
	if domasq $index
	then
		tcpmasqno $chain1 $chain2 $srcaddr $srcport $dstaddr $dstport $target1 $target2
	else
		tcpno $chain1 $chain2 $srcaddr $srcport $dstaddr $dstport $target1 $target2
	fi
}

# tcpsyn chain srcaddr srcport dstaddr dstport target extra
#
# Accept or deny a tcp connection: On chain, make tcp src to dst connections
# jump to target. extra is for the logging option, -l.

tcpsyn()
{
	local chain=$1 srcaddr=$2 srcport=$3 dstaddr=$4 dstport=$5 target=$6 extra=$7
	ipchains -A $chain -p tcp -s $srcaddr $srcport -d $dstaddr $dstport -y -j $target $extra
}

# udp1 chain srcaddr srcport dstaddr dstport extra
#
# Accept a udp packet: On chain, accept udp src to dst. extra is for the
# logging option, -l.

udp1()
{
	local chain=$1 srcaddr=$2 srcport=$3 dstaddr=$4 dstport=$5 extra=$6
	ipchains -A $chain -p udp -s $srcaddr $srcport -d $dstaddr $dstport -j ACCEPT $extra
}

# udpmasq1 chain srcaddr srcport dstaddr dstport extra
#
# Accept an outgoing udp packet for this host and masqueraded hosts

udpmasq1()
{
	local chain=$1 srcaddr=$2 srcport=$3 dstaddr=$4 dstport=$5 extra=$6
	udp1 $chain $srcaddr $srcport $dstaddr $dstport $extra
	udp1 $chain $srcaddr $masq_ports $dstaddr $dstport $extra
}

# udpm1 chain srcaddr srcport dstaddr dstport extra
#
# Accept an outgoing udp packet for this host and masqueraded hosts if
# masquerading and this is on the first untrusted interface. Just accept
# the udp packet as stated, otherwise.

udpm1()
{
	local index=$1 chain=$2 srcaddr=$3 srcport=$4 dstaddr=$5 dstport=$6 extra=$7
	if domasq $index
	then
		udpmasq1 $chain $srcaddr $srcport $dstaddr $dstport $extra
	else
		udp1 $chain $srcaddr $srcport $dstaddr $dstport $extra
	fi
}

# udp chain1 chain2 srcaddr srcport dstaddr dstport
#
# Accept udp src to dst on chain1 and udp dst to src on chain2.

udp()
{
	local chain1=$1 chain2=$2 srcaddr=$3 srcport=$4 dstaddr=$5 dstport=$6
	udp1 $chain1 $srcaddr $srcport $dstaddr $dstport
	udp1 $chain2 $dstaddr $dstport $srcaddr $srcport
}

# udpmasq chain1 chain2 srcaddr srcport dstaddr dstport
#
# Accept an outgoing udp service for this host and masqueraded hosts

udpmasq()
{
	local chain1=$1 chain2=$2 srcaddr=$3 srcport=$4 dstaddr=$5 dstport=$6
	udp $chain1 $chain2 $srcaddr $srcport $dstaddr $dstport
	udp $chain1 $chain2 $srcaddr $masq_ports $dstaddr $dstport
}

# udpmasq chain1 chain2 srcaddr srcport dstaddr dstport
#
# Accept an outgoing udp service for this host and masqueraded hosts if
# masquerading and this is on the first untrusted interface. Just accept
# the udp service as stated, otherwise.

udpm()
{
	local index=$1 chain1=$2 chain2=$3 srcaddr=$4 srcport=$5 dstaddr=$6 dstport=$7
	if domasq $index
	then
		udpmasq $chain1 $chain2 $srcaddr $srcport $dstaddr $dstport
	else
		udp $chain1 $chain2 $srcaddr $srcport $dstaddr $dstport
	fi
}

# noudp1 chain srcaddr srcport dstaddr dstport target extra
#
# Deny/reject a udp packet: On chain, jump to target for udp src to dst.
# extra is for the logging option, -l.

noudp1()
{
	local chain=$1 srcaddr=$2 srcport=$3 dstaddr=$4 dstport=$5 target=$6 extra=$7
	ipchains -A $chain -p udp -s $srcaddr $srcport -d $dstaddr $dstport -j $target $extra
}

# notcp1 chain srcaddr srcport dstaddr dstport target extra
#
# Deny/reject a tcp packet: On chain, jump to target for udp src to dst.
# extra is for the logging option, -l.

notcp1()
{
	local chain=$1 srcaddr=$2 srcport=$3 dstaddr=$4 dstport=$5 target=$6 extra=$7
	ipchains -A $chain -p tcp -s $srcaddr $srcport -d $dstaddr $dstport -j $target $extra
}

# icmp chain srcaddr dstaddr type extra
#
# Accept icmp type from src to dst on chain. extra is for the logging
# option, -l.

icmp()
{
	local chain=$1 srcaddr=$2 dstaddr=$3 type=$4 extra=$5
	ipchains -A $chain -p icmp -s $srcaddr $type -d $dstaddr -j ACCEPT $extra
}

# other protocol chain1 chain2 srcaddr dstaddr
#
# Accept other protocol from src to dst on chain1 and from dst to src on chain2.

other()
{
	local protocol=$1 chain1=$2 chain2=$3 srcaddr=$4 dstaddr=$5
	ipchains -A $chain1 -p $protocol -s $srcaddr -d $dstaddr -j ACCEPT
	ipchains -A $chain2 -p $protocol -s $dstaddr -d $srcaddr -j ACCEPT
}

# default_to_any varname index
#
# Takes the name of a policy variable and an address loop index as arguments.
# If both the common policy variable and its interface specific equivalent are
# empty, the interface specific policy variable is set to $any. This is used
# by services which accept access to/from all hosts by default.

default_to_any()
{
	local common=$1 index=$2
	eval local specific=\"\${common}_$index\"
	eval [ -z \"\$$common\$$specific\" ] && eval $specific="$any"
}

# combine varname index
#
# Takes the name of a policy variable and an address loop index as arguments.
# Outputs the contents of the common policy variable and its interface specific
# equivalent. This is used by all services.

combine()
{
	local common=$1 index=$2
	eval local specific=\"\${common}_$index\"
	case "$fwdebug" in
		[Yy]es|[Tt]rue|[Oo]n|1)
			eval echo combine $common $index = \$$common \$$specific >&2
			;;
	esac
	eval echo \$$common \$$specific
}

# number num arg...
#
# Appends the first argument to the remaining arguments and outputs them

number()
{
	local num=$1; shift
	for item in $*
	do
		echo $item$num
	done
}

# index listvarname index
#
# Prints the n-th word (n is $2) in the variable named in $1

index()
{
	local var=$1 index=$2
	eval set \$$var
	index=`expr $index + 1`
	eval echo \$$index
}

# notin search arg...
#
# Returns 1 if the 1st argument is not the same as any of the following
# arguments, 0 if it is

notin()
{
	local search=$1
	shift
	for item in $*
	do
		[ "$search" = "$item" ] && return 1
	done
	return 0
}

# incoming_tcp_only service target port clientsvarname index [clientports]
#
# Create and populate rule chains that allow incoming connections from the
# specific hosts given in a policy variable to a local/internal tcp service

incoming_tcp_only()
{
	local service=$1 targets="$2" port=$3 clientsvarname=$4 index=$5 client_ports=$6
	[ -z "$client_ports" ] && client_ports="1024:"

	chains i$service $index

	for client in `combine $clientsvarname $index`
	do
		for target in $targets
		do
			tcp ii$service$index oi$service$index $client $client_ports $target $port
		done
	done
}

# incoming_tcp_any service target port clientsvarname index [clientports]
#
# Create and populate rule chains that allow incoming connections from the
# specific hosts given in a policy variable (any host, by default) to a
# local/internal tcp service

incoming_tcp_any()
{
	local service=$1 targets="$2" port=$3 clientsvarname=$4 index=$5 client_ports=$6

	default_to_any $clientsvarname $index
	incoming_tcp_only $service "$targets" $port $clientsvarname $index $client_ports
}

# outgoing_tcp_only service target port serversvarname index [clientports]
#
# Create and populate rule chains that allow outgoing connections from the
# local/internal host and masqueraded internal hosts to a tcp service on
# specific external hosts given in a policy variable

outgoing_tcp_only()
{
	local service=$1 targets="$2" port=$3 serversvarname=$4 index=$5 client_ports=$6
	[ -z "$client_ports" ] && client_ports="$normal_ports"

	chains o$service $index

	for server in `combine $serversvarname $index`
	do
		for target in $targets
		do
			tcpm $index oo$service$index io$service$index $target $client_ports $server $port
		done
	done
}

# outgoing_tcp_any service target port serversvarname index [clientports]
#
# Create and populate rule chains that allow outgoing connections from the
# local/internal host and masqueraded internal hosts to a tcp service on
# specific external hosts given in a policy variable (any host, by default)

outgoing_tcp_any()
{
	local service=$1 targets="$2" port=$3 serversvarname=$4 index=$5 client_ports=$6

	default_to_any $serversvarname $index
	outgoing_tcp_only $service "$targets" $port $serversvarname $index $client_ports
}

# outgoing_tcp_exclusive service target port serversvarname excludevarname index [clientports]
#
# Create and populate rule chains that allow outgoing connections from the
# local/internal host and masqueraded internal hosts to a tcp service on
# specific hosts given in a policy variable (any host, by default) except
# for specific ones given in another policy variable

outgoing_tcp_exclusive()
{
	local service=$1 targets="$2" port=$3 serversvarname=$4 excludevarname=$5 index=$6 client_ports=$7
	[ -z "$client_ports" ] && client_ports="$normal_ports"

	chains o$service $index

	for server in `combine $excludevarname $index`
	do
		for target in $targets
		do
			tcpmno $index oo$service$index io$service$index $target $client_ports $server $port $BLOCKOUT $BLOCKIN
		done
	done

	outgoing_tcp_any $service "$targets" $port $serversvarname $index $client_ports
}

# incoming_tcpudp_any servce target port clientsvarname index [clientports]
#
# Create and populate rule chains that allow incoming connections from the
# specific hosts given in a policy variable (any host, by default) to a
# local/internal tcp service and a local/internal udp service with the
# same port number

incoming_tcpudp_any()
{
	local service=$1 targets="$2" port=$3 clientsvarname=$4 index=$5 client_ports=$6
	[ -z "$client_ports" ] && client_ports="1024:"

	chains i$service $index

	default_to_any $clientsvarname $index

	for client in `combine $clientsvarname $index`
	do
		for target in $targets
		do
			udp ii$service$index oi$service$index $client $client_ports $target $port
			tcp ii$service$index oi$service$index $client $client_ports $target $port
		done
	done
}

# outgoing_tcpudp_only service target port serversvarname index [clientports]
#
# Create and populate rule chains that allow outgoing connections from the
# local/internal host and masqueraded internal hosts to a tcp service and
# a udp service with the same port number on specific external hosts given
# in a policy variable

outgoing_tcpudp_only()
{
	local service=$1 targets="$2" port=$3 serversvarname=$4 index=$5 client_ports=$6
	[ -z "$client_ports" ] && client_ports="$normal_ports"

	chains o$service $index

	for server in `combine $serversvarname $index`
	do
		for target in $targets
		do
			udpm $index oo$service$index io$service$index $target $client_ports $server $port
			tcpm $index oo$service$index io$service$index $target $client_ports $server $port
		done
	done
}

# incoming_tcp_byport service target portsvarname index
#
# Create and populate rule chains that allow incoming connections from any
# external host for a local/internal tcp service on ports given in a policy
# variable

incoming_tcp_byport()
{
	local service=$1 targets="$2" portsvarname=$3 index=$4

	chains i$service $index

	eval portsvar=\"\$$portsvarname\"

	for target in $targets
	do
		for port in $portsvar
		do
			tcp ii$service$index oi$service$index $any 1024: $target $port
		done
	done
}

# outgoing_tcp_byport service target portsvarname index
#
# create and populate rule chains that allow connections from the
# local/internal host to any external host for a tcp service on ports given
# in a policy variable (all ports, by default)

outgoing_tcp_byport()
{
	local service=$1 targets="$2" portsvarname=$3 index=$4

	chains o$service $index

	eval portsvar=\"\$$portsvarname\"
	[ -z "$portsvar" ] && portsvar=":"

	for target in $targets
	do
		for port in $portsvar
		do
			tcpm $index oo$service$index io$service$index $target $normal_ports $any $port
		done
	done
}

# incoming_udp_only service target port clientsvarname index [clientports]
#
# Create and populate rule chains that allow incoming connections from
# specific hosts given in a policy variable to a local/internal udp service

incoming_udp_only()
{
	local service=$1 targets="$2" port=$3 clientsvarname=$4 index=$5 client_ports=$6
	[ -z "$client_ports" ] && client_ports="1024:"

	chains i$service $index

	for client in `combine $clientsvarname $index`
	do
		for target in $targets
		do
			udp ii$service$index oi$service$index $client $client_ports $target $port
		done
	done
}

# incoming_udp_any service target port clientsvarname index [clientports]
#
# Create and populate rule chains that allow incoming connections from
# specific hosts given in a policy variable (all hosts, by default) to
# a local/internal udp service

incoming_udp_any()
{
	local service=$1 targets="$2" port=$3 clientsvarname=$4 index=$5 client_ports=$6

	default_to_any $clientsvarname $index
	incoming_udp_only $service "$targets" $port $clientsvarname $index $client_ports
}

# outgoing_udp_only service target ports serversvarname index [clientports]
#
# Create and populate rule chains that allow outgoing connections from the
# local/internal host and masqueraded internal hosts to a udp service on
# specific external hosts given in a policy variable

outgoing_udp_only()
{
	local service=$1 targets="$2" port=$3 serversvarname=$4 index=$5 client_ports=$6
	[ -z "$client_ports" ] && client_ports="$normal_ports"

	chains o$service $index

	for server in `combine $serversvarname $index`
	do
		for target in $targets
		do
			udpm $index oo$service$index io$service$index $target $client_ports $server $port
		done
	done
}

##############################################################################
# The following sections define functions that create rule chains that allow
# specific internet services.
#

##############################################################################
# Incoming Client DNS
#
# Note: This is needed when this host runs a registered DNS server that can
# be accessed by external hosts (resolvers or BIND 8 servers without
# "query-source port 53"). For a bastion DNS slave server host, give access
# to all hosts. For an internal DNS master server host, give access to the
# bastion DNS server host for zone transfers if it runs BIND 8 without
# "query-source port 53". However, it would be better for the bastion DNS
# slave server to "query-source port 53" so that only incoming Server DNS
# from the bastion host is required for this host.
#
# Open: tcp/53 udp/53

icdns() # target index
{
	incoming_tcpudp_any cdns "$1" 53 ICDNS_CLIENTS $2
}

##############################################################################
# Outgoing Client DNS
#
# Note: Don't use this. It leaves too many udp ports open.
# Note: This is needed when this host's resolver queries external DNS
# servers. This is also needed even when the resolver queries the local DNS
# server if that server is BIND 8 without "query-source port 53". If the
# resolver only queries the local DNS server which has been configured with
# "query-source port 53", only outgoing Server DNS is required for this
# host.
#
# Open: tcp(ack)/1024-4999,61000-65096 udp/1024-4999,61000-65096

ocdns() # targets index
{
	outgoing_tcpudp_only cdns "$1" 53 OCDNS_SERVERS $2
}

##############################################################################
# Incoming Server DNS
#
# Note: This is only needed when this host runs a registered DNS server that
# can be accessed by external DNS servers (BIND 4 servers and BIND 8 servers
# with "query-source port 53"). For a bastion DNS slave server host, give
# access to all hosts. For an internal DNS master server host, give access
# to the bastion DNS slave server host for zone transfers if it runs BIND 4
# or BIND 8 with "query-source port 53".
#
# Open: tcp/53 udp/53

isdns() # targets index
{
	incoming_tcpudp_any sdns "$1" 53 ISDNS_CLIENTS $2 53
}

##############################################################################
# Outgoing Server DNS
#
# Note: This is needed when this host runs a DNS server (BIND 4 or BIND 8
# with "query-source port 53") that queries external DNS servers. For an
# internal host, forward all queries to a bastion (or your ISP's) DNS server
# and give access to only those servers. For a bastion DNS server host, give
# access to all hosts.
#
# Open: tcp(ack)/53,61000-65096 udp/53,61000-65096

osdns() # targets index
{
	outgoing_tcpudp_only sdns "$1" 53 OSDNS_SERVERS $2 53
}

##############################################################################
# Incoming SMTP
#
# Note: If this is a bastion host, run smap and permit all hosts to connect.
# Otherwise, run smap and only permit connections from the bastion host.
#
# Open: tcp/25

ismtp() # targets index
{
	incoming_tcp_any smtp "$1" 25 SMTP_CLIENTS $2
}

##############################################################################
# Outgoing SMTP
#
# Note: If this host is a bastion, permit connections to all hosts, otherwise
# only permit connections to the bastion host.
#
# Open: tcp(ack)/1024-4999,61000-65096

osmtp() # targets index
{
	outgoing_tcp_any smtp "$1" 25 SMTP_SERVERS $2
}

##############################################################################
# Incoming POP
#
# Note: This is an extremely bad idea since real user names and passwords
# and private mail will be transmitted over the net in plaintext. Use
# SSL-POP instead.
#
# Open: tcp/109-110

ipop() # targets index
{
	incoming_tcp_any pop "$1" 109:110 POP_CLIENTS $2
}

##############################################################################
# Outgoing POP
#
# Note: This is an extremely bad idea when the user name and password or
# people's private mail are too sensitive to be transmitted over the net in
# plaintext. Use $EVIL_POP_SERVERS to deny such uses while allowing less
# sensitive POP access. Use SSL-POP instead.
#
# Open: tcp(ack)/1024-4999,61000-65096

opop() # targets index
{
	outgoing_tcp_exclusive pop "$1" 109:110 POP_SERVERS EVIL_POP_SERVERS $2
}

##############################################################################
# Incoming IMAP
#
# Note: This is an extremely bad idea if any external IMAP clients or internal
# IMAP servers don't support and use the "AUTHENTICATE" command instead of the
# "LOGIN" command since user names, passwords and people's private mail will
# be transmitted over the net in plaintext. Use SSL-IMAP instead.
#
# Open: tcp/143

iimap() # targets index
{
	incoming_tcp_any imap "$1" 143 IMAP_CLIENTS $2
}

##############################################################################
# Outgoing IMAP
#
# Note: This is an extremely bad idea if any internal IMAP clients or external
# IMAP servers don't support and use the "AUTHENTICATE" command instead of the
# "LOGIN" command since user names, passwords and people's private mail will
# be transmitted over the net in plaintext. Use $EVIL_IMAP_SERVERS to deny
# such uses while allowing secure IMAP access. Use SSL-IMAP instead.
#
# Open: tcp(ack)/1024-4999,61000-65096

oimap() # targets index
{
	outgoing_tcp_exclusive imap "$1" 143 IMAP_SERVERS EVIL_IMAP_SERVERS $2
}

##############################################################################
# Incoming LDAP
#
# Note: Don't allow this across a firewall if your ldap server contains
# information that the world at large does not need to see. This should
# probably only be used for public key servers. Otherwise, use SSL-LDAP.
#
# Open: tcp/389

ildap() # targets index
{
	incoming_tcp_any ldap "$1" 389 SLDAP_CLIENTS $2
}

##############################################################################
# Outgoing LDAP
#
# Open: tcp(ack)/1024-4999,61000-65096

oldap() # targets index
{
	outgoing_tcp_any ldap "$1" 389 SLDAP_SERVERS $2
}

##############################################################################
# Incoming SSL-POP
#
# Open: tcp/995

ispop() # targets index
{
	incoming_tcp_any spop "$1" 995 SPOP_CLIENTS $2
}

##############################################################################
# Outgoing SSL-POP
#
# Open: tcp(ack)/1024-4999,61000-65096

ospop() # targets index
{
	outgoing_tcp_any spop "$1" 995 SPOP_SERVERS $2
}

##############################################################################
# Incoming SSL-IMAP
#
# Open: tcp/993

isimap() # targets index
{
	incoming_tcp_any simap "$1" 993 SIMAP_CLIENTS $2
}

##############################################################################
# Outgoing SSL-IMAP
#
# Open: tcp(ack)/1024-4999,61000-65096

osimap() # targets index
{
	outgoing_tcp_any simap "$1" 993 SIMAP_SERVERS $2
}

##############################################################################
# Incoming SSL-LDAP
#
# Open: tcp/636

isldap() # targets index
{
	incoming_tcp_any sldap "$1" 636 SLDAP_CLIENTS $2
}

##############################################################################
# Outgoing SSL-LDAP
#
# Open: tcp(ack)/1024-4999,61000-65096

osldap() # targets index
{
	outgoing_tcp_any sldap "$1" 636 SLDAP_SERVERS $2
}

##############################################################################
# Incoming SSH1
#
# Note: Permit this rather than telnet or ftp. You can restrict this to
# specific, trusted hosts.
#
# Open: tcp/22

issh1() # targets index
{
	incoming_tcp_any ssh1 "$1" 22 SSH1_CLIENTS $2 $SSH1_PORTS
}

##############################################################################
# Outgoing SSH1
#
# Note: Permit this rather than telnet or ftp. You can restrict this to
# specific, trusted hosts.
#
# Open: tcp(ack)/513-1023,61000-65096

ossh1() # targets index
{
	outgoing_tcp_any ssh1 "$1" 22 SSH1_SERVERS $2 $SSH1_PORTS
}

##############################################################################
# Incoming SSH2/LSH
#
# Note: Permit this rather than telnet or ftp. You can restrict this to
# specific, trusted hosts.
#
# Open: tcp/22

issh2() # targets index
{
	incoming_tcp_any ssh2 "$1" 22 SSH2_CLIENTS $2
}

##############################################################################
# Outgoing SSH2/LSH
#
# Note: Permit this rather than telnet or ftp. You can restrict this to
# specific, trusted hosts.
#
# Open: tcp(ack)/1024-4999,61000-65096

ossh2() # targets index
{
	outgoing_tcp_any ssh2 "$1" 22 SSH2_SERVERS $2
}

##############################################################################
# Incoming FTP
#
# Note: This is an extremely bad idea if this host is are running a
# non-anonymous FTP server since real user names, passwords and private
# files will be transmitted over the net in plaintext. Use rsync over ssh
# instead. This should only be used on a bastion host running an anonymous
# FTP server.
#
# Open: tcp/21

iftp() # targets index
{
	incoming_tcp_any ftp "$1" 21 FTP_CLIENTS $2
}

##############################################################################
# Incoming Normal FTP
#
# Note: This is an extremely bad idea if this host is are running a
# non-anonymous FTP server since real user names, passwords and private
# files will be transmitted over the net in plaintext. Use rsync over ssh
# instead. This should only be used on a bastion host running an anonymous
# FTP server.
#
# Open: tcp/21 tcp(ack)/1024-4999,61000-65096

inftp() # targets index
{
	local targets="$1" index=$2

	chains inftp $index # outgoing and incoming rule chains for incoming Normal FTP

	# Permit Normal FTP connections from specific external hosts
	# If no clients are specified, permit all hosts

	iftp "$targets" $index
	ipchains -A oinftp$index -j oiftp$index
	ipchains -A iinftp$index -j iiftp$index

	default_to_any FTP_CLIENTS $index

	for client in `combine FTP_CLIENTS $index`
	do
		for target in $targets
		do
			tcp oinftp$index iinftp$index $target 20 $client 1024:
		done
	done
}

##############################################################################
# Incoming Passive FTP
#
# Note: This is an extremely bad idea if this host is are running a
# non-anonymous FTP server since real user names, passwords and private
# files will be transmitted over the net in plaintext. It is also an
# extremely bad idea since it may allow any host to connect to any tcp port
# above 1023. Use rsync over ssh instead. This should only be used on a
# bastion host running an anonymous FTP server.
#
# Open: tcp/21,1024-4999

ipftp() # targets index
{
	local targets="$1" index=$2

	chains ipftp $index # outgoing and incoming rule chains for incoming Passive FTP

	# Permit Passive FTP connections from specific external hosts
	# If no clients are specified, permit all hosts

	iftp "$targets" $index
	ipchains -A iipftp$index -j iiftp$index
	ipchains -A oipftp$index -j oiftp$index

	default_to_any FTP_CLIENTS $index

	for client in `combine FTP_CLIENTS $index`
	do
		for target in $targets
		do
			tcp iipftp$index oipftp$index $client 1024: $target $normal_ports
		done
	done
}

##############################################################################
# Outgoing FTP
#
# Note: This is an extremely bad idea if used for non-anonymous FTP access
# since real user names, passwords and private files will be transmitted
# over the net in plaintext. Use $EVIL_FTP_SERVERS to deny such uses and
# require that users use rsync over ssh instead.
#
# Open: tcp(ack)/1024-4999,61000-65096

oftp() # targets index
{
	local targets="$1" index=$2

	chains oftp $index # outgoing and incoming rule chains for outgoing FTP

	# Deny FTP connections to specific external hosts where the user name and
	# password required to connect or the contents of the files is too sensitive
	# to be transmitted over the net in plaintext

	for server in `combine EVIL_FTP_SERVERS $index`
	do
		for target in $targets
		do
			tcpmno $index ooftp$index ioftp$index $target $normal_ports $server 21 $BLOCKOUT $BLOCKIN
		done
	done

	# Permit FTP connections to specific external hosts
	# If no servers are specified, permit all hosts

	default_to_any FTP_SERVERS $index

	for server in `combine FTP_SERVERS $index`
	do
		for target in $targets
		do
		tcpm $index ooftp$index ioftp$index $target $normal_ports $server 21
		done
	done
}

##############################################################################
# Outgoing Normal FTP
#
# Note: This is an extremely bad idea if used for non-anonymous FTP access
# since real user names, passwords and private files will be transmitted
# over the net in plaintext. Use $EVIL_FTP_SERVERS to deny such uses and
# require that users use rsync over ssh instead. It is also an extremely bad
# idea since it allows any host to connect to any tcp port above 1023.
# Instead, restrict connections to a bastion host running an FTP proxy.
#
# Open: tcp/1024-4999 tcp(ack)/1024-4999,61000-65096

onftp() # targets index
{
	local targets="$1" index=$2

	chains onftp $index # incoming and outgoing rule chains for outgoing FTP (normal mode)

	# Include common outgoing FTP connection rules

	oftp "$targets" $index
	ipchains -A ionftp$index -j ioftp$index
	ipchains -A oonftp$index -j ooftp$index

	# Deny FTP connections to specific external hosts where the user name and
	# password required to connect or the contents of the files is too sensitive
	# to be transmitted over the net in plaintext

	for server in `combine EVIL_FTP_SERVERS $index`
	do
		for target in $targets
		do
			tcpno ionftp$index oonftp$index $server 20 $target $normal_ports $BLOCKIN $BLOCKOUT
		done
	done

	# Permit Normal FTP connections to specific external hosts
	# If no servers are specified, permit all hosts

	default_to_any FTP_SERVERS $index

	for server in `combine FTP_SERVERS $index`
	do
		for target in $targets
		do
			tcp ionftp$index oonftp$index $server 20 $target $normal_ports
		done
	done
}

##############################################################################
# Outgoing Passive FTP
#
# Note: This is an extremely bad idea if used for non-anonymous FTP access
# since real user names, passwords and private files will be transmitted
# over the net in plaintext. Use $EVIL_FTP_SERVERS to deny such uses and
# require that users use rsync over ssh instead.
#
# Open: tcp(ack)/1024-4999,61000-65096

opftp() # targets index
{
	local targets="$1" index=$2

	chains opftp $index # outgoing and incoming rule chains for outgoing FTP (passive mode)

	# Include common outgoing FTP connection rules

	oftp "$targets" $index
	ipchains -A oopftp$index -j ooftp$index
	ipchains -A iopftp$index -j ioftp$index

	# Deny FTP connections to specific external hosts where the user name and
	# password required to connect or the contents of the files is too sensitive
	# to be transmitted over the net in plaintext

	for server in `combine EVIL_FTP_SERVERS $index`
	do
		for target in $targets
		do
			tcpmno $index oopftp$index iopftp$index $target $normal_ports $server 1024: $BLOCKOUT $BLOCKIN
		done
	done

	# Permit Passive FTP connections to specific external hosts
	# If no servers are specified, permit all hosts

	default_to_any FTP_SERVERS $index

	for server in `combine FTP_SERVERS $index`
	do
		for target in $targets
		do
			tcpm $index oopftp$index iopftp$index $target $normal_ports $server 1024:
		done
	done
}

##############################################################################
# Incoming TELNET
#
# Note: This is an extremely bad idea since real user names, passwords and
# login sessions will be transmitted over the net in plaintext. Require that
# users use ssh instead.
#
# Open: tcp/23

iteln() # targets index
{
	incoming_tcp_only teln "$1" 23 TELNET_CLIENTS $2
}

##############################################################################
# Outgoing TELNET
#
# Note: This is an extremely bad idea since real user names, passwords and
# login sessions will be transmitted over the net in plaintext. Require that
# users use ssh instead.
#
# Open: tcp(ack)/1024-4999,61000-65096

oteln() # targets index
{
	outgoing_tcp_exclusive teln "$1" 23 TELNET_SERVERS EVIL_TELNET_SERVERS $2
}

##############################################################################
# Incoming HTTP
#
# Note: Only run public HTTP servers on bastion hosts.
#
# Open: tcp/80

ihttp() # targets index
{
	incoming_tcp_byport http "$1" INTERNAL_HTTP_PORTS $2
}

##############################################################################
# Outgoing HTTP
#
# Note: You can limit HTTP connections to certain ports on external hosts
# with $EXTERNAL_HTTP_PORTS. By default, this is "80 81 800 8000 8080 8088".
# It is safe to make $EXTERNAL_HTTP_PORTS empty, permitting local clients to
# connect to any port (potentially an HTTP server) on any host and receive
# the responses but you'd be better off using a caching HTTP proxy on a
# bastion host anyway.
#
# Open: tcp(ack)/1024-4999,61000-65096

ohttp() # targets index
{
	outgoing_tcp_byport http "$1" EXTERNAL_HTTP_PORTS $2
}

##############################################################################
# Incoming HTTPS
#
# Note: Only run public HTTPS servers on bastion hosts.
#
# Open: tcp/443

ihttps() # targets index
{
	incoming_tcp_byport https "$1" INTERNAL_HTTPS_PORTS $2
}

##############################################################################
# Outgoing HTTPS
#
# Note: You can limit HTTPS connections to certain ports on external hosts
# with $EXTERNAL_HTTPS_PORTS. By default, this is "443". It is safe to make
# $EXTERNAL_HTTPS_PORTS empty, permitting local clients to connect to any
# port (potentially an HTTPS server) on any host and receive the responses
# but you'd be better off using a caching HTTPS proxy on a bastion host anyway.
#
# Open: tcp(ack)/1024-4999,61000-65096

ohttps() # targets index
{
	outgoing_tcp_byport https "$1" EXTERNAL_HTTPS_PORTS $2
}

##############################################################################
# Incoming HTTP PROXY
#
# Note: You need this if your web proxy is internal and it has external
# clients (don't do that), or if this host is a bastion and the interface
# being filtered connects to the internal network.
#
# Open: tcp/8080

iproxy() # targets index
{
	local targets="$1" index=$2

	chains iproxy $index # incoming and outgoing rule chains for incoming HTTP PROXY

	# Permit HTTP PROXY connections to limited ports on specified hosts

	for client in `combine INTERNAL_HTTP_PROXY_CLIENTS $index`
	do
		for target in $targets
		do
			for port in $INTERNAL_HTTP_PROXY_PORTS
			do
				tcp iiproxy$index oiproxy$index $client 1024: $target $port
			done
		done
	done
}

##############################################################################
# Outgoing HTTP PROXY
#
# Note: You need this if your web proxy is running on a bastion host.
#
# Open: tcp(ack)/1024-4999,61000-65096

oproxy() # targets index
{
	local targets="$1" index=$2

	chains oproxy $index # outgoing and incoming rule chains for outgoing HTTP PROXY

	# Permit HTTP PROXY connections to limited ports on specified hosts

	for server in `combine EXTERNAL_HTTP_PROXY_SERVERS $index`
	do
		for target in $targets
		do
			for port in $EXTERNAL_HTTP_PROXY_PORTS
			do
				tcpm $index ooproxy$index ioproxy$index $target $normal_ports $server $port
			done
		done
	done
}

##############################################################################
# Incoming NNTP
#
# Note: Don't run an NNTP server on a bastion host. Run it on an internal
# host and only permit connections from trusted external NNTP servers.
#
# Open: tcp/119

inntp() # targets index
{
	incoming_tcp_only nntp "$1" 119 NNTP_CLIENTS $2
}

##############################################################################
# Outgoing NNTP
#
# Note: Only permit NNTP connections to trusted external NNTP servers.
#
# Open: tcp(ack)/1024-4999,61000-65096

onntp() # targets index
{
	outgoing_tcp_only nntp "$1" 119 NNTP_SERVERS $2
}

##############################################################################
# Incoming RSYNC
#
# Note: Don't allow this over a firewall. Use rsync over ssh instead.
#
# Open: tcp/873

irsync() # targets index
{
	incoming_tcp_only rsync "$1" 873 RSYNC_CLIENTS $2
}

##############################################################################
# Outgoing RSYNC
#
# Note: Don't allow this over a firewall. Use rsync over ssh instead.
#
# Open: tcp(ack)/1024-4999,61000-65096

orsync() # targets index
{
	outgoing_tcp_only rsync "$1" 873 RSYNC_SERVERS $2
}

##############################################################################
# Incoming CVS
#
# Note: Don't allow this over a firewall. Use rsync over ssh instead.
#
# Open: tcp/2401

icvs() # targets index
{
	incoming_tcp_only cvs "$1" 2401 CVS_CLIENTS $2
}

##############################################################################
# Outgoing CVS
#
# Note: Don't allow this over a firewall. Use rsync over ssh instead.
#
# Open: tcp(ack)/1024-4999,61000-65096

ocvs() # targets index
{
	outgoing_tcp_only cvs $1 2401 CVS_SERVERS $2
}

##############################################################################
# Incoming GNATS
#
# Open: tcp/1529

ignats() # targets index
{
	incoming_tcp_only gnats "$1" 1529 GNATS_CLIENTS $2
}

##############################################################################
# Outgoing GNATS
#
# Open: tcp(ack)/1024-4999,61000-65096

ognats() # targets index
{
	outgoing_tcp_only gnats "$1" 1529 GNATS_SERVERS $2
}

##############################################################################
# Incoming MYSQL
#
# Open: tcp/3306

imysql() # targets index
{
	incoming_tcp_only mysql "$1" 3306 MYSQL_CLIENTS $2
}

##############################################################################
# Outgoing MYSQL
#
# Open: tcp(ack)/1024-4999,61000-65096

omysql() # targets index
{
	outgoing_tcp_only mysql "$1" 3306 MYSQL_SERVERS $2
}

##############################################################################
# Incoming SMB
#
# Note: This is probably a bad idea over a firewall.
#
# Open: tcp/139 udp/137-138

ismb() # targets index
{
	local targets="$1" index=$2

	chains ismb $index # incoming and outgoing rule chains for incoming SMB

	# Permit SMB connections from specific external hosts

	for client in `combine SMB_CLIENTS $index`
	do
		for target in $targets
		do
			udp iismb$index oismb$index $client 137 $target 137
			udp iismb$index oismb$index $client 138 $target 138
			tcp iismb$index oismb$index $client 1024: $target 139
		done
	done
}

##############################################################################
# Outgoing SMB
#
# Note: This is probably a bad idea over a firewall.
#
# Open: tcp(ack)/1024-4999,61000-65096

osmb() # targets index
{
	local targets="$1" index=$2

	chains osmb $index # outgoing and incoming rule chains for outgoing SMB

	# Permit SMB connections to specific external hosts

	for server in `combine SMB_SERVERS $index`
	do
		for target in $targets
		do
			udpm $index oosmb$index iosmb$index $target 137 $server 137
			udpm $index oosmb$index iosmb$index $target 138 $server 138
			tcpm $index oosmb$index iosmb$index $target $normal_ports $server 139
		done
	done
}

##############################################################################
# Incoming IRC
#
# Note: If this host run an internal IRC server, make sure it can't
# communicate with external IRC servers or it will attach itself to the IRC
# spanning tree through which this host can be attacked. Also, DCC
# connections between IRC clients isn't supported because it's a very bad
# idea across a firewall.
#
# Open: tcp/6667

iirc() # targets index
{
	incoming_tcp_any irc "$1" 6667 IRC_CLIENTS $2
}

##############################################################################
# Outgoing IRC
#
# Note: IRC clients can be dangerous and you shouldn't allow IRC across a
# firewall. It's best to run them on a victim host. Also, DCC connections
# between IRC clients isn't supported because it's a very bad idea across a
# firewall.
#
# Open: tcp(ack)/1024-4999,61000-65096

oirc() # targets index
{
	outgoing_tcp_any irc "$1" 6667 IRC_SERVERS $2
}

##############################################################################
# Incoming ICQ
#
# Note: Don't allow this through a firewall. ICQ is dangerous. Run ICQ
# servers on an external victim host.
#
# Open: tcp/2000-4000 udp/4000

iicq() # targets index
{
	local targets="$1" index=$2

	chains iicq $index # incoming and outgoing rule chains for incoming ICQ

	# Permit ICQ connections from specific external hosts
	# If no clients are specified, permit all hosts

	default_to_any ICQ_CLIENTS $index

	for client in `combine ICQ_CLIENTS $index`
	do
		for target in $targets
		do
			tcp iiicq$index oiicq$index $client 1024: $target 2000:4000
			udp iiicq$index oiicq$index $client 1024: $target 4000
		done
	done
}

##############################################################################
# Outgoing ICQ
#
# Note: Don't allow this through a firewall. ICQ is dangerous. Run ICQ
# clients on an external victim host.
#
# Open: tcp(ack)/1024-4999,61000-65096 udp/1024-4999,61000-65096

oicq() # targets index
{
	local targets="$1" index=$2

	chains oicq $index # outgoing and incoming rule chains for outgoing ICQ

	# Permit ICQ connections to specific external hosts
	# If no servers are specified, permit all hosts

	default_to_any ICQ_SERVERS $index

	for server in `combine ICQ_SERVERS $index`
	do
		for target in $targets
		do
			tcpm $index ooicq$index ioicq$index $target $normal_ports $server 2000:4000
			udpm $index ooicq$index ioicq$index $target $normal_ports $server 4000
		done
	done
}

##############################################################################
# Incoming RealAudio/QuickTime
#
# Note: Don't allow this through a firewall. You probably don't need it. It's
# a bad idea since it leaves all the udp ports open.
#
# Open: tcp/554,7070-7071 udp/1024-4999

ireal() # targets index
{
	local targets="$1" index=$2

	chains ireal $index # incoming and outgoing rule chains for incoming RealAudio/QuickTime

	# Permit RealAudio connections from specific external hosts
	# If no clients are specified, permit all hosts

	default_to_any REALAUDIO_CLIENTS $index

	for client in `combine REALAUDIO_CLIENTS $index`
	do
		for target in $targets
		do
			tcp iireal$index oireal$index $client 1024: $target 554
			tcp iireal$index oireal$index $client 1024: $target 7070:7071
			udp iireal$index oireal$index $client 6970:6999 $target $normal_ports
		done
	done
}

##############################################################################
# Outgoing RealAudio/QuickTime
#
# Note: You may need special kernel modules for this. This is a bad idea
# since it leaves many udp ports open.
#
# Open: tcp(ack)/1024-4999,61000-65096 udp/6970-6999,61000,65096

oreal() # targets index
{
	local targets="$1" index=$2

	chains oreal $index # outgoing and incoming rule chains for outgoing RealAudio/QuickTime

	# Permit RealAudio connections to specific external hosts
	# If no servers are specified, permit all hosts

	default_to_any REALAUDIO_SERVERS $index

	for server in `combine REALAUDIO_SERVERS $index`
	do
		for target in $targets
		do
			tcpm $index ooreal$index ioreal$index $target $normal_ports $server 554
			tcpm $index ooreal$index ioreal$index $target $normal_ports $server 7070:7071
			udpm $index ooreal$index ioreal$index $target 6970:6999 $server 1024:
		done
	done
}

##############################################################################
# Incoming NTP
#
# Note: Only permit this if this host is running a public NTP server. If
# it's an internal host, only permit connections from a proxy DNS server
# running on a bastion host.
#
# Open: udp/123

intp() # targets index
{
	local targets="$1" index=$2

	chains intp $index # incoming and outgoing rule chains for incoming NTP

	# Permit NTP connections from specific hosts
	# If no clients are specified, permit all hosts

	default_to_any NTP_CLIENTS $index

	incoming_udp_any ntp "$targets" 123 NTP_CLIENTS $index 123

	for client in `combine NTP_CLIENTS $index`
	do
		for target in $targets
		do
			udp iintp$index ointp$index $client 1024: $target 123
		done
	done
}

##############################################################################
# Outgoing NTP
#
# Note: Permit this if you synchronize your network from external NTP
# servers. Restrict NTP connections to only those NTP servers.
#
# Open: udp/123,1024-4999,61000-65096

ontp() # targets index
{
	local targets="$1" index=$2

	chains ontp $index # outgoing and incoming rule chains for outgoing NTP

	# Permit NTP connections to specific hosts

	outgoing_udp_only ntp "$targets" 123 NTP_SERVERS $index 123

	for server in `combine NTP_SERVERS $index`
	do
		for target in $targets
		do
			udpm $index oontp$index iontp$index $target $normal_ports $server 123
		done
	done
}

##############################################################################
# Incoming GOPHER
#
# Note: Don't use this. It's for GOPHER servers. I'm just being silly.
# If you must run a public GOPHER server, run it on a bastion host.
#
# Open: tcp/70

igoph() # targets index
{
	incoming_tcp_byport goph "$1" INTERNAL_GOPHER_PORTS $2
}

##############################################################################
# Outgoing GOPHER
#
# Note: Don't use this. Use an HTTP-GOPHER gateway.
#
# Open: tcp(ack)/1024-4999,61000-65096

ogoph() # targets index
{
	outgoing_tcp_byport goph "$1" EXTERNAL_GOPHER_PORTS $2
}

##############################################################################
# Incoming WAIS
#
# Note: Don't use this. It's for WAIS servers. I'm just being silly.
# If you must run a public WAIS server, run it on a bastion host.
#
# Open: tcp/210

iwais() # targets index
{
	incoming_tcp_byport wais "$1" INTERNAL_WAIS_PORTS $2
}

##############################################################################
# Outgoing WAIS
#
# Note: Don't use this. Use an HTTP-WAIS gateway instead.
#
# Open: tcp(ack)/1024-4999,61000-65096

owais() # targets index
{
	outgoing_tcp_byport wais "$1" EXTERNAL_WAIS_PORTS $2
}

##############################################################################
# Outgoing ARCHIE
#
# Note: Don't use this. Use an HTTP-ARCHIE gateway instead. If you must
# permit this, restrict it to the well known ARCHIE servers.
#
# Open: udp/1024-4999,61000-65096

oarch() # targets index
{
	outgoing_udp_only arch "$1" 1525 ARCHIE_SERVERS $2
}

##############################################################################
# Incoming FINGER
#
# Note: Only run a public (secure) FINGER server on a bastion host.
#
# Open: tcp/79

ifing() # targets index
{
	incoming_tcp_any fing "$1" 79 FINGER_CLIENTS $2
}

##############################################################################
# Outgoing FINGER
#
# Note: Make sure this host's finger clients can handle non-printable
# characters in finger output otherwise programmable terminals may get
# themselves reprogrammed.
#
# Open: tcp(ack)/1024-4999,61000-65096

ofing() # targets index
{
	outgoing_tcp_any fing "$1" 79 FINGER_SERVERS $2
}

##############################################################################
# Outgoing WHOIS
#
# Note: Restrict WHOIS connections to the well known WHOIS servers.
# Do not run a WHOIS server.
#
# Open: tcp(ack)/1024-4999,61000-65096

owhois() # targets index
{
	outgoing_tcp_any whois "$1" 43 WHOIS_SERVERS $2
}

##############################################################################
# Incoming AUTH
#
# Note: Permitting this speeds up outgoing SMTP and FTP communications since
# some SMTP and FTP servers attempt to identify their clients. However,
# handing out local user names to anonymous FTP servers is not necessarily a
# good idea. See man identd for details.
#
# Open: tcp/113

iauth() # targets index
{
	incoming_tcp_any auth "$1" 113 AUTH_CLIENTS $2
}

##############################################################################
# Outgoing AUTH
#
# Note: It is safe to permit this except that it may be used by local
# attackers to gain information about external hosts.
#
# Open: tcp(ack)/1024-4999,61000-65096

oauth() # targets index
{
	outgoing_tcp_any auth "$1" 113 AUTH_SERVERS $2
}

##############################################################################
# Incoming NOTES
#
# Note: You only need this if external Lotus Notes servers connect to
# internal Lotus Notes servers.
#
# Open: tcp/1352

inotes() # targets index
{
	incoming_tcp_any notes "$1" 1352 NOTES_CLIENTS $2
}

##############################################################################
# Outgoing NOTES
#
# Note: You only need this if internal Lotus Notes servers connect to
# external Lotus Notes servers.
#
# Open: tcp(ack)/1024-4999,61000-65096

onotes() # targets index
{
	outgoing_tcp_any notes "$1" 1352 NOTES_SERVERS $2
}

##############################################################################
# Incoming SYSLOG
#
# Note: Only use this to collect syslog messages from a bastion host.
#
# Open: udp/514

ilog() # targets index
{
	local targets="$1" index=$2

	chains ilog $index # incoming SYSLOG

	# Permit SYSLOG packets from specific external hosts

	for client in `combine SYSLOG_CLIENTS $index`
	do
		for target in $targets
		do
			udp1 iilog$index $client : $target 514
		done
	done
}

##############################################################################
# Outgoing SYSLOG
#
# Note: Only use this to send syslog messages from the bastion host to an
# internal host.
#
# Open: none

olog() # targets index
{
	local targets="$1" index=$2

	chains olog $index # outgoing SYSLOG

	# Permit SYSLOG packets to specific external hosts

	for server in `combine SYSLOG_SERVERS $index`
	do
		for target in $targets
		do
			udp1 oolog$index $target : $server 514
		done
	done
}

##############################################################################
# DHCP Server
#
# Note: You probably don't need this.
#
# Open: udp/67

sdhcp() # targets index
{
	local targets="$1" index=$2

	chains sdhcp $index # incoming and outgoing rule chains for DHCP Server

	# Permit DHCP traffic between this host and specific external hosts
	# If no clients are specified, permit all hosts

	default_to_any DHCP_CLIENTS $index

	for client in `combine DHCP_CLIENTS $index`
	do
		for target in $targets
		do
			udp osdhcp$index isdhcp$index $target 67 $client 68
			udp1 osdhcp$index $target 67 $broadcast_dst 68
			udp1 isdhcp$index $broadcast_src 68 $target 67
		done
	done

	# Outgoing address update
	udp1 osdhcp$index $broadcast_src 67 $broadcast_dst 68
	udp1 isdhcp$index $broadcast_src 68 $broadcast_dst 67
}

##############################################################################
# DHCP Client
#
# Note: Only allow DHCP traffic to/from trusted external DHCP servers.
#
# Open: udp/68

cdhcp() # targets index
{
	local targets="$1" index=$2

	chains cdhcp $index # incoming and outgoing rule chains for DHCP Client

	# Permit DHCP traffic between this host and specific external hosts

	for server in `combine DHCP_SERVERS $index`
	do
		for target in $targets
		do
			udp icdhcp$index ocdhcp$index $server 67 $any 68
			udp1 icdhcp$index $server 67 $broadcast_dst 68
			udp1 ocdhcp$index $broadcast_src 68 $server 67
		done
	done

	if [ -n "`combine DHCP_SERVERS $index`" ]
	then
		# Incoming address update
		udp1 icdhcp$index $broadcast_src 67 $broadcast_dst 68
		udp1 ocdhcp$index $broadcast_src 68 $broadcast_dst 67
	fi
}

##############################################################################
# Incoming SNMP
#
# Note: You probably don't want to permit this across a firewall.
# If you do, only allow connections from trusted SNMP management stations.
#
# Open: udp/161

isnmp() # targets index
{
	incoming_udp_only snmp "$1" 161 SNMP_CLIENTS $2
}

##############################################################################
# Outgoing SNMP
#
# Note: You probably don't want to permit this across a firewall.
# If you do, only allow connections to trusted SNMP network devices.
#
# Open: udp/1024-4999,61000-65096

osnmp() # targets index
{
	outgoing_udp_only snmp "$1" 161 SNMP_SERVERS $2
}

##############################################################################
# Incoming SNMP TRAP
#
# Note: You probably don't want to permit this across a firewall.
# If you do, only allow connections from trusted SNMP management stations.
#
# Open: 162

isnmpt() # targets index
{
	incoming_udp_only snmpt "$1" 162 SNMP_TRAP_CLIENTS $2
}

##############################################################################
# Outgoing SNMP TRAP
#
# Note: You probably don't want to permit this across a firewall.
# If you do, only allow connections to trusted SNMP network devices.
#
# Open: udp/1024-4999,61000-65096

osnmpt() # targets index
{
	outgoing_udp_only snmpt "$1" 162 SNMP_TRAP_SERVERS $2
}

##############################################################################
# Incoming BGP
#
# Note: You probably don't want to permit this across a firewall.
# If you do, only allow connections from trusted BGP peers.
#
# Open: tcp/179

ibgp() # targets index
{
	incoming_tcp_only bgp "$1" 179 BGP_CLIENTS $2
}

##############################################################################
# Outgoing BGP
#
# Note: You probably don't want to permit this across a firewall.
# If you do, only allow connections to trusted BGP peers.
#
# Open: tcp(ack)/1024-4999,61000-65096

obgp() # targets index
{
	outgoing_tcp_only bgp "$1" 179 BGP_SERVERS $2
}

##############################################################################
# OSPF
#
# Note: You must have ospf(89) in /etc/protocols.
#
# Open: ospf

ospf() # targets index
{
	local targets="$1" index=$2

	if [ -n "$OSPF_PROTOCOL" ]
	then
		chains ospf $index # incoming and outgoing rule chains for OSPF

		# Permit OSPF traffic to/from specific external routers

		for router in `combine OSPF_ROUTERS $index`
		do
			for target in $targets
			do
				other ospf oospf$index iospf$index $target $router
			done
		done
	fi
}

##############################################################################
# Incoming RIP
#
# Note: You probably don't want to permit this across a firewall.
# If you do, only allow connection from trusted routers.
#
# Open: udp/520

irip() # targets index
{
	local targets="$1" index=$2

	chains irip $index # incoming and outgoing rule chains for incoming RIP

	# Permit RIP requests from specific external hosts

	for client in `combine RIP_CLIENTS $index`
	do
		for target in $targets
		do
			# Incoming RIP broadcast from specified host (server)
			udp1 iirip$index $client 520 $target 520
			# Incoming RIP request from specified host (client)
			udp iirip$index oirip$index $client 1024: $target 520
		done
	done
}

##############################################################################
# Outgoing RIP
#
# Note: You probably don't want to permit this across a firewall.
# If you do, only allow connection to trusted routers.
#
# Open: udp/1024-4999,61000-65096

orip() # targets index
{
	local targets="$1" index=$2

	chains orip $index # outgoing and incoming rule chains for outgoing RIP

	# Permit RIP requests to specific external hosts

	for server in `combine RIP_SERVERS $index`
	do
		for target in $targets
		do
			# Outgoing RIP broadcast to specified host (server)
			udpm1 $index oorip$index $target 520 $server 520
			# Outgoing RIP request to specified host (client)
			udpm $index oorip$index iorip$index $target $normal_ports $server 520
		done
	done
}

##############################################################################
# Incoming KERBEROS
#
# Open: tcp/88,543-544,749

ikerb() # targets index
{
	local targets="$1" index=$2

	chains ikerb $index # incoming and outgoing rule chains for incoming KERBEROS

	# Permit KERBEROS connections from specific external hosts
	# If no clients are specified, permit all hosts

	default_to_any KERBEROS_CLIENTS $index

	for client in `combine KERBEROS_CLIENTS $index`
	do
		for target in $targets
		do
			tcp iikerb$index oikerb$index $client 1024: $target 88      # kerberos
			tcp iikerb$index oikerb$index $client 1024: $target 543:544 # klogin/kshell
			tcp iikerb$index oikerb$index $client 1024: $target 749     # kadmin
		done
	done
}

##############################################################################
# Outgoing KERBEROS
#
# Open: tcp(ack)/1024-4999,61000-65096

okerb() # targets index
{
	local targets="$1" index=$2

	chains okerb $index # incoming and outgoing rule chains for outgoing KERBEROS

	# Permit KERBEROS connections to specific external hosts
	# If no servers are specified, permit all hosts

	default_to_any KERBEROS_SERVERS $index

	for server in `combine KERBEROS_SERVERS $index`
	do
		for target in $targets
		do
			tcpm $index ookerb$index iokerb$index $target $normal_ports $server 88      # kerberos
			tcpm $index ookerb$index iokerb$index $target $normal_ports $server 543:544 # klogin/kshell
			tcpm $index ookerb$index iokerb$index $target $normal_ports $server 749     # kadmin
		done
	done
}

##############################################################################
# Incoming PPTP
#
# Note: You must have pptp(47) in /etc/protocols to use this.
# Warning: Some iMplementationS of PPTP are completely insecure, use IPSEC.
#
# Open: tcp/1723 pptp

if [ -n "$PPTP_PROTOCOL" ]
then
	ipptp()
	{
		local targets="$1" index=$2

		chains ipptp $index # incoming and outgoing rule chains for incoming PPTP

		# Permit PPTP connections from specific external hosts
		# If no clients are specified, permit all hosts

		default_to_any PPTP_CLIENTS $index

		for client in `combine PPTP_CLIENTS $index`
		do
			for target in $targets
			do
				tcp iipptp$index oipptp$index $client 1024: $target 1723
				other pptp iipptp$index oipptp$index $client $target
			done
		done
	}
fi

##############################################################################
# Outgoing PPTP
#
# Note: You must have pptp(47) in /etc/protocols to use this.
# Warning: Some iMplementationS of PPTP are completely insecure, use IPSEC.
#
# Open: tcp(ack)/1024-4999,61000-65096 pptp

if [ -n "$PPTP_PROTOCOL" ]
then
	opptp()
	{
		local targets="$1" index=$2

		chains opptp $index # outgoing and incoming rule chains for outgoing PPTP

		# Permit PPTP connections to specific external hosts
		# If no servers are specified, permit all hosts

		default_to_any PPTP_SERVERS $index

		for server in `combine PPTP_SERVERS $index`
		do
			for target in $targets
			do
				tcp oopptp$index iopptp$index $target $normal_ports $server 1723
				other pptp oopptp$index iopptp$index $target $server
			done
		done
	}
fi

##############################################################################
# Incoming IPSEC
#
# Note: You must have esp(50) and ah(51) in /etc/protocols to use this.
#
# Open: udp/500 esp ah

if [ -n "$ESP_PROTOCOL" -a -n "$AH_PROTOCOL" ]
then
	iipsec()
	{
		local targets="$1" index=$2

		chains iipsec $index # incoming and outgoing rule chains for incoming IPSEC

		# Permit IPSEC connections from specific external hosts
		# If no clients are specified, permit all hosts

		default_to_any IPSEC_CLIENTS $index

		for client in `combine IPSEC_CLIENTS $index`
		do
			for target in $targets
			do
				udp iiipsec$index oiipsec$index $client 500 $target 500
				other esp iiipsec$index oiipsec$index $client $target
				other ah iiipsec$index oiipsec$index $client $target
			done
		done
	}
fi

##############################################################################
# Outgoing IPSEC
#
# Note: You must have esp(50) and ah(51) in /etc/protocols to use this.
#
# Open: udp/500 esp ah

oipsec() # targets index
{
	local targets="$1" index=$2

	if [ -n "$ESP_PROTOCOL" -a -n "$AH_PROTOCOL" ]
	then
		chains oipsec $index # outgoing and incoming rule chains for outgoing IPSEC

		# Permit IPSEC connections to specific external hosts
		# If no servers are specified, permit all hosts

		default_to_any IPSEC_SERVERS $index

		for server in `combine IPSEC_SERVERS $index`
		do
			for target in $targets
			do
				udp ooipsec$index ioipsec$index $target 500 $client 500
				other esp ooipsec$index ioipsec$index $target $client
				other ah ooipsec$index ioipsec$index $target $client
			done
		done
	fi
}

##############################################################################
# Incoming PING
#
# Note: Only permit incoming pings from external hosts that have a reason to
# be pinging this host (e.g. your ISP).
#
# Open: icmp/echo-request

iping() # targets index
{
	local targets="$1" index=$2

	chains iping $index # incoming and outgoing rule chains for incoming PING

	# Permit PING requests from specific hosts

	for client in `combine PING_CLIENTS $index`
	do
		for target in $targets
		do
			# Incoming echo-request
			icmp iiping$index $client $target 8 $LOG
			# Outgoing echo-reply
			icmp oiping$index $target $client 0
		done
	done
}

##############################################################################
# Outgoing PING
#
# Note: This can be used by local attackers to flood external hosts but it
# is very useful. You can restrict outgoing PING to specific hosts if you
# want.
#
# Open: icmp/echo-reply

oping() # targets index
{
	local targets="$1" index=$2

	chains oping $index # outgoing and incoming rule chains for outgoing PING

	# Permit PING requests to specific hosts
	# If no servers are specified, permit all hosts

	default_to_any PING_SERVERS $index

	for server in `combine PING_SERVERS $index`
	do
		for target in $targets
		do
			# Outgoing echo-request
			icmp ooping$index $target $server 8
			# Incoming echo-reply
			icmp ioping$index $server $target 0
		done
	done
}

##############################################################################
# Incoming TRACEROUTE
#
# Note: Only permit incoming traceroute from external hosts that have a
# reason to be tracing this network (e.g. your ISP). You can also limit
# which udp ports may be used for incoming traceroute by prior arrangement
# with those wishing to trace your network (recommended).
#
# Open: udp/33434-33523

itrace() # targets index
{
	local targets="$1" index=$2

	chains itrace $index # incoming and outgoing rule chains for incoming TRACEROUTE

	# Permit TRACEROUTE requests from specific hosts

	for client in `combine TRACEROUTE_CLIENTS $index`
	do
		for target in $targets
		do
			# Incoming TRACEROUTE probe
			udp1 iitrace$index $client $ITRACEROUTE_SRC_PORTS $target $ITRACEROUTE_DST_PORTS $LOG
			# Incoming TRACEROUTE responses: time-exceeded, destination-unreachable
			icmp oitrace$index $target $client 11
			icmp oitrace$index $target $client 3
		done
	done
}

##############################################################################
# Outgoing TRACEROUTE
#
# Note: This can be used by local attackers to gather information about
# external hosts but it is very useful. You can restrict outgoing TRACEROUTE
# to specific hosts if you want.
#
# Open: icmp/time-exceeded,destination-unreachable

otrace() # targets index
{
	local targets="$1" index=$2

	chains otrace $index # outgoing and incoming rule chains for outgoing TRACEROUTE

	# Permit TRACEROUTE requests to specific hosts
	# If no servers are specified, permit all hosts

	default_to_any TRACEROUTE_SERVERS $index

	for server in `combine TRACEROUTE_SERVERS $index`
	do
		for target in $targets
		do
			# Outgoing TRACEROUTE probe
			udp1 ootrace$index $target $OTRACEROUTE_SRC_PORTS $server $OTRACEROUTE_DST_PORTS
			# Outgoing TRACEROUTE responses: time-exceeded, destination-unreachable
			icmp iotrace$index $server $target 11
			icmp iotrace$index $server $target 3
		done
	done
}

##############################################################################
# Other ICMP packets
#
# Note: The default icmp rules allow incoming destination-unreachable and
# outgoing fragmentation-needed, incoming anad outgoing source-quench,
# incoming and outgoing time-exceeded and incoming and outgoing
# parameter-problem. There's probably no reason to change this.
#
# Open: destination-unreachable, source-quench, time-exceeded, parameter-problem

mand_icmp()
{
	local targets="$1" index=$2

	chains icmp $index # incoming and outgoing rule chains for other ICMP packets

	for code in `combine OTHER_INCOMING_ICMP $index`
	do
		for target in $targets
		do
			icmp iicmp$index $any $target $code
		done
	done

	for code in `combine OTHER_OUTGOING_ICMP $index`
	do
		for target in $targets
		do
			icmp oicmp$index $target $any $code
		done
	done
}

##############################################################################
# Prevent connections to notoriously insecure services (e.g. X Windows,
# NFS, SOCKS, OpenWindows)
#
# Note: There can up to 64(?) X servers on a host, occupying one port each.
# Blocking 64 ports (whether there are actually that many X servers running or
# not) can cause problems for other services that innocently bind to those
# ports only to find that nobody can connect. If you are certain that this host
# will never run that many X servers, you can reduce the range given in
# $XWIN_PORTS to something less aggressive: 6000:6000+#Xservers-1
#

mand_danger()
{
	local targets="$1" index=$2

	chains danger $index # incoming and outgoing rule chains for dangerous services

	# Permit specific X clients to connect
	# Note: Don't use this

	for client in `combine XWIN_CLIENTS $index`
	do
		for target in $targets
		do
			tcpsyn idanger$index $client : $target $XWIN_PORTS ACCEPT
			tcpsyn odanger$index $target : $client $XWIN_PORTS ACCEPT
		done
	done

	for ports in `combine XWIN_PORTS $index` `combine EVIL_TCP_PORTS $index`
	do
		for target in $targets
		do
			tcpsyn idanger$index $any : $target $ports $BLOCKIN $LOG
			tcpsyn odanger$index $target : $any $ports $BLOCKOUT $LOG
		done
	done
}

##############################################################################
# Self Spoofing
#
# Note: Most spoof detection is interface independent (see below) except for
# spoofing of this host's interfaces' addresses.
#

mand_spoof()
{
	local targets="$1" index=$2

	chain ispoof $index

	# Catch incoming packets that claim to be from this host
	if [ "$targets" != "$any" ]
	then
		for target in $targets
		do
			ipchains -A ispoof$index -s $target -j $BLOCKIN $LOG
		done
	fi
}

##############################################################################
# Other TCP Services
#
# Note: This only works for applications with a simple, single-connection
# application protocol. Also, it can't be restricted to certain external
# servers or clients. All external hosts will be allowed to engage in these
# services so it should only be used for safe applications.
#
# Open (incoming): whatever you add
# Open (outgoing): tcp(ack)/1024-4999,61000-65096

mand_user()
{
	local targets="$1" index=$2

	chains iuser $index
	chains ouser $index

	# List of ports on this host that any external host can connect to

	for port in $OTHER_INCOMING_TCP_SERVICES
	do
		for target in $targets
		do
			incoming_tcp_any user $target $port any $index
		done
	done

	# List of ports on any host that this network may connect to

	for port in $OTHER_OUTGOING_TCP_SERVICES
	do
		for target in $targets
		do
			outgoing_tcp_any user $target $port any $index
		done
	done
}

##############################################################################
# No Log
#
# After you've set up your firewall, you may find regular, harmless packets
# being blocked and logged (e.g. netbios broadcasts). If you don't want them
# to be logged, you can add port numbers and protocol names to these variables
# and they will be blocked but not logged.
#

mand_nolog()
{
	local targets="$1" index=$2

	chains nolog $index

	# Deny incoming udp packets without logging them

	for port in `combine INOLOG_UDP_PORTS $index`
	do
		for target in $targets
		do
			noudp1 inolog$index $any : $target $port $BLOCKIN
		done
	done

	# Reject outgoing udp packets without logging them

	for port in `combine ONOLOG_UDP_PORTS $index`
	do
		for target in $targets
		do
			noudp1 onolog$index $target : $any $port $BLOCKOUT
		done
	done

	# Deny incoming tcp packets without logging them

	for port in `combine INOLOG_TCP_PORTS $index`
	do
		for target in $targets
		do
			notcp1 inolog$index $any : $target $port $BLOCKIN
		done
	done

	# Reject outgoing tcp packets without logging them

	for port in `combine ONOLOG_TCP_PORTS $index`
	do
		for target in $targets
		do
			notcp1 onolog$index $target : $any $port $BLOCKOUT
		done
	done

	# Deny incoming packets for other protocols without logging them

	for protocol in `combine INOLOG_PROTO $index`
	do
		for target in $targets
		do
			ipchains -A inolog$index -p $protocol -j $BLOCKIN
		done
	done

	# Reject outgoing packets for other protocols without logging them

	for protocol in `combine ONOLOG_PROTO $index`
	do
		for target in $targets
		do
			ipchains -A onolog$index -p $protocol -j $BLOCKOUT
		done
	done
}

##############################################################################
# Before we start creating chains, set up the policy for the top level chains
# and flush all chains.
#

echo -n "Starting IP Packet Filter"

# Set policies for the built-in chains

ipchains -P input $BLOCKIN
ipchains -P output $BLOCKOUT
ipchains -P forward $BLOCKFWD

# Remove all existing rules/chains

ipchains -F
ipchains -X

##############################################################################
# IP Spoofing
#
# Note: The kernel performs IP spoof protection as explained in the
# following extract from the "Advanced Router" section's help in the
# kernel configuration.
#
#   If you turn on IP forwarding, you will also get the rp_filter, which
#   automatically rejects incoming packets if the routing table entry
#   for their source address doesn't match the network interface they're
#   arriving on. This has security advantages because it prevents the
#   so-called IP spoofing, however it can pose problems if you use
#   asymmetric routing (packets from you to a host take a different path
#   than packets from that host to you) or if you operate a non-routing
#   host which has several IP addresses on different interfaces.
#
# If most packets take the default route, this only really protects the host
# from packets pretending to come from the internal network, not packets
# pretending to come from some external network (that you may trust to some
# extent). Following the lead of http://linux-firewall-tools.com, we at least
# guard against anyone using blatantly illegal network addresses (Perhaps this
# is done in the hope that they won't have to conflict with anyone else's
# routing tables to get return packets back(?)).
#

chains spoof # incoming and outgoing rule chains for spoofed packets

# Catch incoming packets that claim to be from an internal network
for internal_network in $INTERNAL_NETWORKS
do
	ipchains -A ispoof -s $internal_network -j $BLOCKIN $LOG
done

# Catch packets claiming to be to or from illegal networks
for illegal_netork in $ILLEGAL_NETWORKS
do
	ipchains -A ispoof -s $illegal_netork -j $BLOCKIN $LOG
	ipchains -A ispoof -d $illegal_netork -j $BLOCKIN $LOG
	ipchains -A ospoof -s $illegal_netork -j $BLOCKOUT $LOG
	ipchains -A ospoof -d $illegal_netork -j $BLOCKOUT $LOG
done

# Catch incoming packets with the wrong type of broadcast address
ipchains -A ispoof -s $broadcast_dst -j $BLOCKIN $LOG
ipchains -A ispoof -d $broadcast_src -j $BLOCKIN $LOG

# Catch packets with a multicast source address
ipchains -A ispoof -s $multicast -j $BLOCKIN $LOG
ipchains -A ospoof -s $multicast -j $BLOCKOUT $LOG

# Catch packets with a reserved source address
ipchains -A ispoof -s $reserved  -j $BLOCKIN $LOG

# Catch incoming packets with IANA reserved source addresses
for reserved_network in $RESERVED_NETWORKS
do
	ipchains -A ispoof -s $reserved_network -j $BLOCKIN $LOG
done

##############################################################################
# Packet Fragments
#
# Note: Fragments are denied/rejected iff $IPV4_FRAGMENT_PROTECT != "no".
#

chains frag # incoming and outgoing rule chains for fragments

# Note: The kernel must "always defrag" so as to avoid attacks where packets
# that would not pass through the filter aren't assembled until after filtering
# so we should deny any fragments that make it this far. There shouldn't be
# any.

case "$IPV4_FRAGMENT_PROTECT" in
	[Nn]o|[Ff]alse|[Oo]ff|0)
		;;
	*)
		ipchains -A ifrag -f -j $BLOCKIN $LOG
		ipchains -A ofrag -f -j $BLOCKOUT $LOG
		;;
esac

##############################################################################
# Construct the chains for the untrusted interfaces. All untrusted interfaces
# are protected from spoofing, notoriously dangerous services and problematic
# networks. Each untrusted interface permits services as specified for it in
# the policy file.
#
# The SERVICE variables are composed of words of the form: service[.target]
# where service is the name of a supported service and target identifies a
# TARGET_* variable containing the set of ip addresses that require the
# service. If the target is omitted, the target is the addresses of the
# current interface.
#

i=-1
for untrusted in $untrusted_interfaces
do
	# Each untrusted interface has a number from 0 to 9.
	i=`expr $i + 1`

	# There may be aliases and hence multiple ip addresses.
	TARGET_self="`index untrusted_addresses $i | sed 's/,/ /g'`"

	# Create incoming and outgoing chains for the untrusted network interface
	# Note: May not work for things like ppp+
	chains $untrusted

	# Disallow spoofing
	mand_spoof "$TARGET_self" "$i"
	ipchains -A i$untrusted -j ispoof$i
	# Only perform full spoof protection on external untrusted interfaces
	if notin $untrusted $INTERNAL_UNTRUSTED_INTERFACES
	then
		ipchains -A i$untrusted -j ispoof
		ipchains -A o$untrusted -j ospoof
	fi

	# Disallow all packets between this network and untrusted networks
	# Note: This is not particularly useful. If it's really hostile,
	# they can spoof some other network's addresses anyway. In fact,
	# they may have been doing so all along.
	for untrusted_network in $UNTRUSTED_NETWORKS
	do
		ipchains -A i$untrusted -s $untrusted_network -j $BLOCKIN $LOG
		ipchains -A o$untrusted -d $untrusted_network -j $BLOCKOUT $LOG
	done

	# Add the input/output rule chains to deny dangerous services
	mand_danger "$any" "$i"
	ipchains -A i$untrusted -j idanger$i
	ipchains -A o$untrusted -j odanger$i

	# Add the input/output rule chains to allow requested services
	for service in `combine SERVICES $i`
	do
		# Extract the service name and target (no target implies self)
		service_name=${service%.*}
		service_target=${service#*.}
		[ "$service_name" = "$service_target" ] && service_target="self"
		eval target=\"\$TARGET_$service_target\"

		if [ -z "$target" ]
		then
			echo "$0: Failed to find target for $service_name: \$TARGET_$service_target" >&2
			continue;
		fi

		if typeset -f $service_name >/dev/null
		then
			$service_name "$target" "$i"
			ipchains -A i$untrusted -j i$service_name$i
			ipchains -A o$untrusted -j o$service_name$i
		else
			echo "$0: $service_name is not a recognised service name" >&2
		fi
	done

	mand_user "$any" "$i"
	mand_icmp "$any" "$i"
	mand_nolog "$any" "$i"
	for service in iuser$i ouser$i icmp$i frag nolog$i
	do
		ipchains -A i$untrusted -j i$service
		ipchains -A o$untrusted -j o$service
	done
done

##############################################################################
# Finally, start filtering packets. Set up the built-in chains. Packets on
# trusted interfaces are accepted. Packets on untrusted interfaces must pass
# their respective rule chains. All packets that don't match any terminal
# rule are logged if requested. Masquerading begins here as well if requested.
#

# Accept all packets on trusted interfaces

for trusted in $trusted_interfaces
do
	ipchains -A input  -i $trusted -j ACCEPT
	ipchains -A output -i $trusted -j ACCEPT
done

# Direct packets through each untrusted interface's direction-based chains

for untrusted in $untrusted_interfaces
do
	ipchains -A input  -i $untrusted -j i$untrusted
	ipchains -A output -i $untrusted -j o$untrusted
done

# If masquerading, masquerade packets between the internal networks and
# everywhere else but not amongst the internal networks themselves.
#
# Note: while ipchains probably can masquerade packets across multiple external
# interfaces, it seems very strange so fwup will only create rules to allow
# masquerading across the first untrusted interface.

case "$MASQUERADING" in
	[Yy]es|[Tt]rue|[Oo]n|1)

		# Set masquerading timeouts

		if [ "$MASQ_TCP_TIMEOUT" != 0 -o "$MASQ_TCPFIN_TIMEOUT" != 0 -o "$MASQ_UDP_TIMEOUT" != 0 ]
		then
			ipchains -M -S ${MASQ_TCP_TIMEOUT:-0} ${MASQ_TCPFIN_TIMEOUT:-0} ${MASQ_UDP_TIMEOUT:-0}
		fi

		# Accept (unmasqueraded) traffic amongst multiple internal networks

		for src in $INTERNAL_NETWORKS
		do
			for dst in $INTERNAL_NETWORKS
			do
				if [ "$src" != "$dst" ]
				then
					ipchains -A forward -s $src -d $dst -j ACCEPT
				fi
			done
		done

		# Masquerade traffic from internal networks to the outside world

		for masqnet in $INTERNAL_NETWORKS
		do
			ipchains -A forward -s $masqnet -j MASQ
		done

		# Setup port forwarding XXX not when disconnected: pukes on -L 0/0

		case "$PORT_FORWARDING" in
			[Yy]es|[Tt]rue|[Oo]n|1)
				ipmasqadm portfw -f
				if [ -n "$PORTFW" ]
				then
					# There may only be one address on this interface
					dstaddr="`index untrusted_addresses 0`"
					if [ "${dstaddr#,}" != "$dstaddr" ]
					then
						echo "$0: Too many addresses - use alias masquerading" >&2
					elif [ "$dstaddr" = "$any" ]
					then
						echo " (not connected - leaving portfw until later)" >&2
					else
						set $PORTFW
						while [ $# != 0 ]
						do
							proto=$1; dstport=$2; toaddr=$3; toport=$4
							shift; shift; shift; shift

							if [ -z "$proto" -o -z "$dstport" -o -z "$toaddr" -o -z "$toport" ]
							then
								echo "$0: Invalid port forwarding instructions: \"$proto\" \"$dstport\" \"$toaddr\" \"$toport\" (protocol dstport toaddr toport)" >&2
								break
							fi

							ipmasqadm portfw -a -P $proto -L $dstaddr $dstport -R $toaddr $toport
						done
					fi
				fi
				;;
		esac
		;;
esac

# If forwarding, accept all forwarded packets. All checks are on the input and
# output chains.

case "$FORWARDING" in
	[Yy]es|[Tt]rue|[Oo]n|1)
		ipchains -A forward -j ACCEPT
		;;
esac

# Log all packets that reach the end of their chain

if [ ! -z "$LOG" ]
then
	ipchains -A input $LOG
	ipchains -A output $LOG
	ipchains -A forward $LOG
fi

action "" true

##############################################################################
# Load IP Masquerading Modules
#

case "$MASQUERADING" in
	[Yy]es|[Tt]rue|[Oo]n|1)
		if [ -r /proc/modules -a -n "$MASQ_MODULES" ]
		then
			echo -n "Loading IP Masquerading Modules"
			required="0"
			loaded="0"

			for module in $MASQ_MODULES
			do
				if grep ip_masq_$module /proc/modules >/dev/null
				then
					continue
				fi
				required="`expr $required + 1`"
				eval modprobe ip_masq_$module \$MASQ_MODULES_$module && loaded="`expr $loaded + 1`"
			done

			if [ "$loaded" != "$required" ]
			then
				action ": $loaded/$required modules loaded" /bin/false
			else
				action "" /bin/true
			fi
		fi
		;;
esac

##############################################################################
# Start IP Source Address Verification
#

case "$IPV4_SPOOF_PROTECT" in
	[Nn]o|[Ff]alse|[Oo]ff|0)
		;;
	*)
		echo -n "Starting IP Source Address Verification"
		if [ -w $ipv4/conf/all/rp_filter ]
		then
			for procfile in $ipv4/conf/*/rp_filter
			do
				echo 1 > $procfile
			done
			action "" true
		else
			action "" false
		fi
		;;
esac

##############################################################################
# Start IP Source Routing Protection
#

case "$IPV4_SOURCE_ROUTE_PROTECT" in
	[Nn]o|[Ff]alse|[Oo]ff|0)
		;;
	*)
		echo -n "Starting IP Source Routing Protection"
		if [ -w $ipv4/conf/all/accept_source_route ]
		then
			for procfile in $ipv4/conf/*/accept_source_route
			do
				echo 0 > $procfile
			done
			action "" true
		else
			action "" false
		fi
		;;
esac

##############################################################################
# Start IP ICMP Redirect Protection
#

case "$IPV4_ICMP_REDIRECT_PROTECT" in
	[Nn]o|[Ff]alse|[Oo]ff|0)
		;;
	*)
		echo -n "Starting IP ICMP Redirect Protection"
		if [ -w $ipv4/conf/all/accept_redirects ]
		then
			for procfile in $ipv4/conf/*/accept_redirects
			do
				echo 0 > $procfile
			done
			action "" true
		else
			action "" false
		fi
		;;
esac

##############################################################################
# Start IP TCP SYN Cookie Protection
#

case "$IPV4_TCP_SYN_COOKIE_PROTECT" in
	[Nn]o|[Ff]alse|[Oo]ff|0)
		;;
	*)
		echo -n "Starting IP TCP SYN Cookie Protection"
		if [ -w $ipv4/tcp_syncookies ]
		then
			echo 1 > $ipv4/tcp_syncookies
			action "" true
		else
			action "" false
		fi
		;;
esac

##############################################################################
# Start IP Fragment Protection
#

case "$IPV4_FRAGMENT_PROTECT" in
	[Nn]o|[Ff]alse|[Oo]ff|0)
		;;
	*)
		echo -n "Starting IP Fragment Protection"
		if [ -w $ipv4/ip_always_defrag ]
		then
			echo 1 > $ipv4/ip_always_defrag
			action "" true
		else
			action "" false
		fi
		;;
esac

##############################################################################
# Start IP ICMP Broadcast Echo Protection
#

case "$IPV4_ICMP_BROADCAST_ECHO_PROTECT" in
	[Nn]o|[Ff]alse|[Oo]ff|0)
		;;
	*)
		echo -n "Starting IP ICMP Broadcast Echo Protection"
		if [ -w $ipv4/icmp_echo_ignore_broadcasts ]
		then
			echo 1 > $ipv4/icmp_echo_ignore_broadcasts
			action "" true
		else
			action "" false
		fi
		;;
esac

##############################################################################
# Start IP Bogus Error Response Protection
#

case "$IPV4_BOGUS_ERROR_RESPONSE_PROTECT" in
	[Nn]o|[Ff]alse|[Oo]ff|0)
		;;
	*)
		echo -n "Starting IP Bogus Error Response Protection"
		if [ -w $ipv4/icmp_ignore_bogus_error_responses ]
		then
			echo 1 > $ipv4/icmp_ignore_bogus_error_responses
			action "" true
		else
			action "" false
		fi
		;;
esac

##############################################################################
# Start IP Martian Logging
#

case "$IPV4_LOG_MARTIANS" in
	[Nn]o|[Ff]alse|[Oo]ff|0)
		;;
	*)
		echo -n "Starting IP Martian Logging"
		if [ -w $ipv4/conf/all/log_martians ]
		then
			for procfile in $ipv4/conf/*/log_martians
			do
				echo 0 > $procfile
			done
			action "" true
		else
			action "" false
		fi
		;;
esac

##############################################################################
# Start Dynamic IP Address Hacking in IP MASQ
#

case "$IPV4_DYNADDR" in
	[Yy]es|[Tt]rue|[Oo]n|1)
		echo -n "Starting Dynamic IP Address Hacking in IP MASQ"
		if [ -w $ipv4/ip_dynaddr ]
		then
			echo 1 > $ipv4/ip_dynaddr
			action "" true
		else
			action "" false
		fi
		;;
esac

##############################################################################
# Start IP Packet Forwarding
#

start_forwarding="0"

case "$FORWARDING" in
	[Yy]es|[Tt]rue|[Oo]n|1)
		start_forwarding="1"
		;;
esac

case "$MASQUERADING" in
	[Yy]es|[Tt]rue|[Oo]n|1)
		start_forwarding="1"
		;;
esac

case "$STATIC_NAT" in
	[Yy]es|[Tt]rue|[Oo]n|1)
		start_forwarding="1"
		;;
esac

if [ "$start_forwarding" = "1" ]
then
	echo -n "Starting IP Packet Forwarding"
	if [ -w $ipv4/ip_forward ]
	then
		echo 1 > $ipv4/ip_forward
		action "" true
	else
		action "" false
	fi
fi

exit 0

# vi:set ts=4 sw=4:
