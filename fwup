#!/bin/sh
#
# firewall: http://www.zip.com.au/~raf2/lib/software/firewall
#
# Copyright (C) 1999, 2000 raf <raf2@zip.com.au>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
# or visit http://www.gnu.org/copyleft/gpl.html
#

# fwup - Brings up an ipchains packet filtering firewall
#
# Run this before any network interfaces are up
# (i.e. before /etc/rc.d/rc?.d/S??network start)
# and after receiving a dynamic IP address.
#
# Define policy in /etc/firewall.policy
# Read it carefully
#
# 20000402 raf <raf2@zip.com.au>

##############################################################################
# Start by checking that we've got everything we need
#

# Set the path explicitly

PATH=/sbin:/bin:/usr/bin

# Source the function library

if [ -r /etc/rc.d/init.d/functions ]
then
	. /etc/rc.d/init.d/functions
else
	#echo "$0: failed to find /etc/rc.d/init.f/functions" >&2
	#exit 1

	# Define a crappy version of redhat's action function

	action() {
		local msg=$1; shift
		echo -n "$msg "
		$* && echo "[ OK ]" || echo "[ FAILED ]"
	}
fi

# Source the network configuration

if [ -r /etc/sysconfig/network ]
then
	. /etc/sysconfig/network
#else
	#echo "$0: failed to find /etc/sysconfig/network" >&2
	#exit 1
fi

# Check that networking is required

[ "$NETWORKING" = "no" ] && exit 0

# Check that ipchains is available

if [ ! -x /sbin/ipchains ]
then
	echo "$0: failed to find /sbin/ipchains" >&2
	exit 1
fi

# Check that ifconfig is available

if [ ! -x /sbin/ifconfig ]
then
	echo "$0: failed to find /sbin/ifconfig" >&2
	exit 1
fi

# Check for other protocols that we might need

grep '^ospf' /etc/protocols >/dev/null && OSPF_PROTOCOL="1"
grep '^pptp' /etc/protocols >/dev/null && PPTP_PROTOCOL="1"
grep '^esp' /etc/protocols >/dev/null && ESP_PROTOCOL="1"
grep '^ah' /etc/protocols >/dev/null && AH_PROTOCOL="1"

# Check that the policy file is available

[ -z "$policy" ] && policy=/etc/firewall.policy

if [ ! -r $policy ]
then
	echo "$0: failed to find $policy" >&2
	exit 1
fi

##############################################################################
# Define some network addresses
#

# Matches every ip address

any="0/0"

# Broadcast source addess

broadcast_src="0.0.0.0/32"

# Broadcast destination address

broadcast_dst="255.255.255.255/32"

# The loopback address (never to appear on the internet)

loopback="127.0.0.0/8"

# Class A, B and C private addresses (never to appear on the internet)

private_a="10.0.0.0/8"
private_b="172.16.0.0/12"
private_c="192.168.0.0/16"

# Class D multicast address

multicast="224.0.0.0/4"

# Class E reserved address

reserved="240.0.0.0/5"

# Illegal addresses

ILLEGAL_NETWORKS="$loopback $private_a $private_b $private_c"

# Reserved addresses

RESERVED_NETWORKS="1.0.0.0/8 2.0.0.0/8 5.0.0.0/8 7.0.0.0/8 23.0.0.0/8 27.0.0.0/8 31.0.0.0/8 37.0.0.0/8 39.0.0.0/8 41.0.0.0/8 42.0.0.0/8 49.0.0.0/8 50.0.0.0/8 58.0.0.0/7 60.0.0.0/8 65.0.0.0/8 66.0.0.0/8 67.0.0.0/8 68.0.0.0/8 69.0.0.0/8 70.0.0.0/8 71.0.0.0/8 72.0.0.0/8 73.0.0.0/8 74.0.0.0/8 75.0.0.0/8 76.0.0.0/8 77.0.0.0/8 78.0.0.0/8 79.0.0.0/8 80.0.0.0/4 96.0.0.0/4 112.0.0.0/8 113.0.0.0/8 114.0.0.0/8 115.0.0.0/8 116.0.0.0/8 117.0.0.0/8 118.0.0.0/8 119.0.0.0/8 120.0.0.0/8 121.0.0.0/8 122.0.0.0/8 123.0.0.0/8 124.0.0.0/8 125.0.0.0/8 126.0.0.0/8 197.0.0.0/8 217.0.0.0/8 218.0.0.0/8 219.0.0.0/8 220.0.0.0/6"

##############################################################################
# Define some system specific port numbers
#

ipv4=/proc/sys/net/ipv4

# Range of local return port numbers

if [ -r $ipv4/ip_local_port_range ]
then
	normal_ports=`sed 's/\W/:/' < $ipv4/ip_local_port_range`
else
	normal_ports="1024:"
fi

# Range of port numbers used for masquerading
# These can be changed in /usr/src/linux/include/net/ip_masq.h

[ -z "$masq_ports" ] && masq_ports="61000:65096"

##############################################################################
# Define some default port numbers. You can override these in the policy file.
#

# Range of X Window server ports to avoid like the plague

XWIN_PORTS="6000:6063"

# List of other tcp ports to avoid like the plague (NFS, SOCKS, OpenWindows)

EVIL_TCP_PORTS="2049 1080 2000"

# Allowable HTTP server port numbers (this is stupid, use a proxy)

EXTERNAL_HTTP_PORTS="80 81 800 8000 8080 8088"
INTERNAL_HTTP_PORTS="80"

# Allowable HTTPS server port numbers (this is stupid, use a proxy)

EXTERNAL_HTTPS_PORTS="443"
INTERNAL_HTTPS_PORTS="443"

# Allowable HTTP PROXY server port numbers

EXTERNAL_HTTP_PROXY_PORTS="8080"
INTERNAL_HTTP_PROXY_PORTS="8080"

# Allowable GOPHER server port numbers (this is stupid, use a proxy)

EXTERNAL_GOPHER_PORTS="70"
INTERNAL_GOPHER_PORTS="70"

# Allowable WAIS server port numbers (this is stupid, use a proxy)

EXTERNAL_WAIS_PORTS="210"
INTERNAL_WAIS_PORTS="210"

# Allowable udp ports used by traceroute

ITRACEROUTE_SRC_PORTS="32769:65535"
ITRACEROUTE_DST_PORTS="33434:33523"
OTRACEROUTE_SRC_PORTS="32769:65535"
OTRACEROUTE_DST_PORTS="33434:33523"

# Allowable tcp ports used by ssh1

[ -z "$SSH1_PORTS" ] && SSH1_PORTS="513:1023"

##############################################################################
# Define some default timeout values used for masquerading. You can override
# these in the policy file
#

# Timeout in seconds for masqueraded tcp addresses
# Zero means leave the timeout as it is

MASQ_TCP_TIMEOUT="0"

# Timeout in seconds for masqueraded tcp addresses after receiving FIN
# Zero means leave the timeout as it is

MASQ_TCPFIN_TIMEOUT="0"

# Timeout in seconds for masqueraded udp addresses
# Zero means leave the timeout as it is

MASQ_UDP_TIMEOUT="0"

##############################################################################
# Load the IP packet filtering policy and check it
#

# Source the policy file

. $policy

# Check that $TRUSTED_INTERFACES is defined (at least lo)

if [ -z "$TRUSTED_INTERFACES" ]
then
	echo "$0: \$TRUSTED_INTERFACES must be defined in $policy (e.g. TRUSTED_INTERFACES=\"eth0 lo\")" >&2
	exit 1
fi

trusted_interfaces="$TRUSTED_INTERFACES"

# If $INTERNAL_NETWORKS isn't defined, derive it from $trusted_interfaces

[ -z "$INTERNAL_NETWORKS" ] && INTERNAL_NETWORKS="`ifconfig | perl -e '

	my %network = ();
	my $iface = undef;

	while (<STDIN>)
	{
		if (defined $iface && $_ =~ /inet addr:(\d+\.\d+\.\d+\.\d+)\s+.*\s+Mask:(\d+\.\d+\.\d+\.\d+)/)
		{
			my $network = $1 . "/" . $2;
			$network{$iface} = (exists $network{$iface}) ? ($network{$iface} . " " . $network) : $network;
			$iface = undef;
			next;
		}

		my ($if) = $_ =~ /^(\S+)\s/;
		next unless defined $if;
		my ($device, $alias) = $if =~ /^([^:]+):(\d+)$/;
		$iface = (defined $device && defined $alias) ? $device : $if;
	}

	for (@ARGV)
	{
		next if $_ eq "lo";
		next unless exists $network{$_};
		print $network{$_}, " ";
	}

' $trusted_interfaces`"

# If masquerading is required, check that $INTERNAL_NETWORKS is defined

case "$MASQUERADE" in
	[Yy]es|[Tt]rue|[Oo]n|1)
		if [ -z "$INTERNAL_NETWORKS" ]
		then
			echo "$0: \$INTERNAL_NETWORKS must be defined in $policy (e.g. INTERNAL_NETWORKS=\"192.168.1.0/24\")" >&2
			exit 1
		fi
		;;
esac

# Check that $UNTRUSTED_INTERFACES is defined

if [ -z "$UNTRUSTED_INTERFACES" ]
then
	echo "$0: \$UNTRUSTED_INTERFACES must be defined in $policy (e.g. UNTRUSTED_INTERFACES=\"ppp0\")" >&2
	exit 1
fi

untrusted_interfaces="$UNTRUSTED_INTERFACES"

# Check that there aren't too many interfaces listed in $UNTRUSTED_INTERFACES

if [ "`perl -e 'print $#ARGV + 1' $untrusted_interfaces`" -gt 10 ]
then
	echo "$0: Too many untrusted interfaces (only supports 10)" >&2
	exit 1
fi

# Find the IP addresses of the untrusted interfaces (if they are up).
# These addresses will be used in the packet rules. If any of the
# interfaces aren't up yet, we will use $any in the packet rules.
# If any interfaces have aliases, we treat their addresses as being
# equal for that interface.

untrusted_addresses="`ifconfig | perl -e '

	my %iface = ();
	my $iface = undef;

	while (<STDIN>)
	{
		if (defined $iface && $_ =~ /inet addr:(\d+\.\d+\.\d+\.\d+)\s/)
		{
			$iface{$iface} = (exists $iface{$iface}) ? ($iface{$iface} . "," . $1) : $1;
			$iface = undef;
			next;
		}

		my ($if) = $_ =~ /^(\S+)\s/;
		next unless defined $if;
		my ($device, $alias) = $if =~ /^(\w+):(\d+)$/;
		$iface = (defined $device && defined $alias) ? $device : $if;
	}

	for (@ARGV)
	{
		print(((exists $iface{$_}) ? $iface{$_} : "'$any'") , " ");
	}

' $untrusted_interfaces`"

# Check that $OCDNS_SERVERS or $OSDNS_SERVERS is defined or really obvious

[ -z "$OCDNS_SERVERS" ] && OCDNS_SERVERS="`awk '/^nameserver/ { if ($2 != "127.0.0.1") { printf "%s/32\n", $2 } }' /etc/resolv.conf`"
if [ -z "$OCDNS_SERVERS$OSDNS_SERVERS" ]
then
	echo "$0: Either \$OCDNS_SERVERS or \$OSDNS_SERVERS must be defined in $policy" >&2
	exit 1
fi

# Log all denied/rejected packets except those in the "NOLOG" variables

case "$LOG" in
	[Nn]o|[Ff]alse|[Oo]ff|0)
		LOG=""
		;;
	*)
		LOG="-l"
		;;
esac

##############################################################################
# Debugging
#

ipchains() {
	case "$fwdebug" in
		[Yy]es|[Tt]rue|[Oo]n|1)
			echo ipchains $* >&2
			;;
	esac

	/sbin/ipchains $*
}

##############################################################################
# Start by setting the policy for the top level chains and flushing all
# chains.
#

echo -n "Starting IP Packet Filter"

# Set policies for the built-in chains

ipchains -P input DENY
ipchains -P output REJECT
ipchains -P forward REJECT

# Remove all existing rules/chains

ipchains -F
ipchains -X

##############################################################################
# The following sections construct rule sets for individual internet services.
# First, we define some helper functions.
#

# Create a chain
#
# chain <basename> <index>

chain() {
	local name=$1 index=$2
	eval [ -z "\$chain_$name$index" ] && ipchains -N $name$index
	eval chain_$name$index="1"
}

# Create input and output chains by prepending 'i' and 'o', respectively,
# to the basename and appending <index> to both
#
# chains <basename> <index>

chains() {
	local base=$1 index=$2
	chain i$base $index
	chain o$base $index
}

# Accept a tcp service
#
# tcp <chain1> <chain2> <srcaddr> <srcport> <dstaddr> <dstport>
#
# Accept tcp src to dst on chain1 and accept tcp dst to src responses on chain2.

tcp() {
	local chain1=$1 chain2=$2 srcaddr=$3 srcport=$4 dstaddr=$5 dstport=$6
	ipchains -A $chain1 -p tcp -s $srcaddr $srcport -d $dstaddr $dstport -j ACCEPT
	ipchains -A $chain2 -p tcp -s $dstaddr $dstport -d $srcaddr $srcport ! -y -j ACCEPT
}

# Accept an outgoing tcp service for this host and masqueraded hosts
#
# tcpm <chain1> <chain2> <srcaddr> <srcport> <dstaddr> <dstport>

case "$MASQUERADE" in
	[Yy]es|[Tt]rue|[Oo]n|1)
		tcpm() {
			local chain1=$1 chain2=$2 srcaddr=$3 srcport=$4 dstaddr=$5 dstport=$6
			tcp $chain1 $chain2 $srcaddr $srcport $dstaddr $dstport
			tcp $chain1 $chain2 $srcaddr $masq_ports $dstaddr $dstport
		}
		;;
	*)
		tcpm() {
			tcp $*
		}
		;;
esac

# Deny a tcp service
#
# tcpno <chain1> <chain2> <srcaddr> <srcport> <dstaddr> <dstport> <target1> <target2>
#
# On chain1, make tcp src to dst jump to target1. On chain2, make tcp dst to
# src responses jump to target2. If chain1 is the input chain and chain2 is
# the output chain, target1 should be deny and target2 should be reject.
# If chain1 is the output chain and chain2 is the input chain, target1 should
# be reject and target2 should be deny.

tcpno() {
	local chain1=$1 chain2=$2 srcaddr=$3 srcport=$4 dstaddr=$5 dstport=$6 target1=$7 target2=$8
	ipchains -A $chain1 -p tcp -s $srcaddr $srcport -d $dstaddr $dstport -j $target1 $LOG
	ipchains -A $chain2 -p tcp -s $dstaddr $dstport -d $srcaddr $srcport ! -y -j $target2 $LOG
}

# Deny an outgoing tcp service for this host and masqueraded hosts
#
# tcpmno <chain1> <chain2> <srcaddr> <srcport> <dstaddr> <dstport> <target1> <target2>

case "$MASQUERADE" in
	[Yy]es|[Tt]rue|[Oo]n|1)
		tcpmno() {
			local chain1=$1 chain2=$2 srcaddr=$3 srcport=$4 dstaddr=$5 dstport=$6 target1=$7 target2=$8
			tcpno $chain1 $chain2 $srcaddr $srcport $dstaddr $dstport $target1 $target2
			tcpno $chain1 $chain2 $srcaddr $masq_ports $dstaddr $dstport $target1 $target2
		}
		;;
	*)
		tcpmno() {
			tcpno $*
		}
		;;
esac

# Accept or deny a tcp connection
#
# tcpsyn <chain> <srcaddr> <srcport> <dstaddr> <dstport> <target> <extra>
#
# On chain, make tcp src to dst connections jump to target. extra is for the
# logging option, -l.

tcpsyn() {
	local chain=$1 srcaddr=$2 srcport=$3 dstaddr=$4 dstport=$5 target=$6 extra=$7
	ipchains -A $chain -p tcp -s $srcaddr $srcport -d $dstaddr $dstport -y -j $target $extra
}

# Accept a udp packet
#
# udp1 <chain> <srcaddr> <srcport> <dstaddr> <dstport> <extra>
#
# On chain, accept udp src to dst. extra is for the logging option, -l.

udp1() {
	local chain=$1 srcaddr=$2 srcport=$3 dstaddr=$4 dstport=$5 extra=$6
	ipchains -A $chain -p udp -s $srcaddr $srcport -d $dstaddr $dstport -j ACCEPT $extra
}

# Accept an outgoing udp service for this host and masqueraded hosts
#
# udpm1 <chain> <srcaddr> <srcport> <dstaddr> <dstport> <extra>

case "$MASQUERADE" in
	[Yy]es|[Tt]rue|[Oo]n|1)
		udpm1() {
			local chain=$1 srcaddr=$2 srcport=$3 dstaddr=$4 dstport=$5 extra=$6
			udp1 $chain $srcaddr $srcport $dstaddr $dstport $extra
			udp1 $chain $srcaddr $masq_ports $dstaddr $dstport $extra
		}
		;;
	*)
		udpm1() {
			udp1 $*
		}
		;;
esac

# Accept a udp service
#
# udp <chain1> <chain2> <srcaddr> <srcport> <dstaddr> <dstport>
#
# Accept udp src to dst on chain1 and udp dst to src on chain2.

udp() {
	local chain1=$1 chain2=$2 srcaddr=$3 srcport=$4 dstaddr=$5 dstport=$6
	udp1 $chain1 $srcaddr $srcport $dstaddr $dstport
	udp1 $chain2 $dstaddr $dstport $srcaddr $srcport
}

# Accept an outgoing udp service for this host and masqueraded hosts
#
# udpm <chain1> <chain2> <srcaddr> <srcport> <dstaddr> <dstport>

case "$MASQUERADE" in
	[Yy]es|[Tt]rue|[Oo]n|1)
		udpm() {
			local chain1=$1 chain2=$2 srcaddr=$3 srcport=$4 dstaddr=$5 dstport=$6
			udp $chain1 $chain2 $srcaddr $srcport $dstaddr $dstport
			udp $chain1 $chain2 $srcaddr $masq_ports $dstaddr $dstport
		}
		;;
	*)
		udpm() {
			udp $*
		}
		;;
esac

# Deny/reject a udp packet
#
# noudp1 <chain> <srcaddr> <srcport> <dstaddr> <dstport> <target> <extra>
#
# On chain, jump to target for udp src to dst. extra is for the logging option, -l.

noudp1() {
	local chain=$1 srcaddr=$2 srcport=$3 dstaddr=$4 dstport=$5 target=$6 extra=$7
	ipchains -A $chain -p udp -s $srcaddr $srcport -d $dstaddr $dstport -j $target $extra
}

# Deny/reject a tcp packet
#
# notcp1 <chain> <srcaddr> <srcport> <dstaddr> <dstport> <target> <extra>
#
# On chain, jump to target for udp src to dst. extra is for the logging option, -l.

notcp1() {
	local chain=$1 srcaddr=$2 srcport=$3 dstaddr=$4 dstport=$5 target=$6 extra=$7
	ipchains -A $chain -p tcp -s $srcaddr $srcport -d $dstaddr $dstport -j $target $extra
}

# Accept icmp
#
# icmp <chain> <srcaddr> <dstaddr> <type> <extra>
#
# Accept icmp type from src to dst on chain. extra is for the logging
# option, -l.

icmp() {
	local chain=$1 srcaddr=$2 dstaddr=$3 type=$4 extra=$5
	ipchains -A $chain -p icmp -s $srcaddr $type -d $dstaddr -j ACCEPT $extra
}

# Accept other protocols (for pptp and ipsec)
#
# other <protocol> <chain1> <chain2> <srcaddr> <dstaddr>
#
# Accept other protocol from src to dst on chain1 and from dst to src on chain2.

other() {
	local protocol=$1 chain1=$2 chain2=$3 srcaddr=$4 dstaddr=$5
	ipchains -A $chain1 -p $protocol -s $srcaddr -d $dstaddr -j ACCEPT
	ipchains -A $chain2 -p $protocol -s $dstaddr -d $srcaddr -j ACCEPT
}

# Takes the name of a policy variable and an address loop index as arguments.
# If both the common policy variable and its interface specific equivalent are
# empty, the interface specific policy variable is set to $any. This is used
# by services which accept access to/from all hosts by default.

default_to_any() {
	local common=$1 index=$2
	eval local specific="\${common}_$index"
	eval [ -z "\"\$$common\$$specific\"" ] && eval $specific="$any"
}

# Takes the name of a policy variable and an address loop index as arguments.
# Outputs the contents of the common policy variable and its interface specific
# equivalent. This is used by all services.

combine() {
	local common=$1 index=$2
	eval local specific="\${common}_$index"
	case "$fwdebug" in
		[Yy]es|[Tt]rue|[Oo]n|1)
			eval echo combine $common $index = \$$common \$$specific >&2
			;;
	esac
	eval echo \$$common \$$specific
}

# Appends the first argument to the remaining arguments and outputs them

number() {
	local num=$1; shift
	for item in $*
	do
		echo $item$num
	done
}

# incoming_tcp_any
#     create and populate rule chains that allow incoming connections from
#     the addresses given in a policy variable (any host, by default) to a
#     local tcp service
# e.g.
#     incoming_tcp_any smtp 25 SMTP_CLIENTS $i

incoming_tcp_any()
{
	local service=$1 port=$2 policyclients=$3 index=$4 client_ports=$5
	[ -z "$client_ports" ] && client_ports="1024:"

	chains i$service $index # incoming and outgoing rule chains for incoming $service

	# Permit connections from specific external hosts
	# If no clients are specified, permit all hosts

	default_to_any $policyclients $index

	for client in `combine $policyclients $index`
	do
		tcp ii$service$index oi$service$index $client $client_ports $self $port
	done
}

# incoming_tcp_only
#     create and populate rule chains that allow incoming connections from
#     the specific hosts given in a policy variable to a local tcp service
# e.g.
#     incoming_tcp_only smtp 25 SMTP_CLIENTS $i

incoming_tcp_only()
{
	local service=$1 port=$2 policyclients=$3 index=$4 client_ports=$5
	[ -z "$client_ports" ] && client_ports="1024:"

	chains i$service $index # incoming and outgoing rule chains for incoming $service

	# Permit connections from specific external hosts

	for client in `combine $policyclients $index`
	do
		tcp ii$service$index oi$service$index $client $client_ports $self $port
	done
}

# outgoing_tcp_any
#     create and populate rule chains that allow outgoing connections from
#     the local host and masqueraded internal hosts to an external tcp service
#     on hosts given in a policy variable (any host, by default)
# e.g.
#     outgoing_tcp_any smtp 25 SMTP_SERVERS $i

outgoing_tcp_any()
{
	local service=$1 port=$2 policyservers=$3 index=$4 client_ports=$5
	[ -z "$client_ports" ] && client_ports="$normal_ports"

	chains o$service $index # outgoing and incoming rule chains for outgoing $service

	# Permit connections to specific external hosts
	# If no servers are specified, permit all hosts

	default_to_any $policyservers $index

	for server in `combine $policyservers $index`
	do
		tcpm oo$service$index io$service$index $self $client_ports $server $port
	done
}

# outgoing_tcp_only
#     create and populate rule chains that allow outgoing connections from
#     the local host and masqueraded internal hosts to a tcp service on
#     specific external hosts given in a policy variable
# e.g.
#     outgoing_tcp_only nntp 119 NNTP_SERVERS $i

outgoing_tcp_only()
{
	local service=$1 port=$2 policyservers=$3 index=$4 client_ports=$5
	[ -z "$client_ports" ] && client_ports="$normal_ports"

	chains o$service $index # outgoing and incoming rule chains for outgoing $service

	# Permit connections to specific external hosts

	for server in `combine $policyservers $index`
	do
		tcpm oo$service$index io$service$index $self $client_ports $server $port
	done
}

# outgoing_tcp_exclusive
#     create and populate rule chains that allow outgoing connections from
#     the local host and masqueraded internal hosts to a tcp service on
#     hosts given in a policy variable (any host, by default) except for
#     specific ones given in another policy variable
# e.g.
#     outgoing_tcp_exclusive pop 109:110 POP_SERVERS EVIL_POP_SERVERS $i

outgoing_tcp_exclusive()
{
	local service=$1 port=$2 policyservers=$3 policyexclude=$4 index=$5 client_ports=$6
	[ -z "$client_ports" ] && client_ports="$normal_ports"

	chains o$service $index # outgoing and incoming rule chains for outgoing $service

	# Deny connections to specific external hosts

	for server in `combine $policyexclude $index`
	do
		tcpmno oo$service$index io$service$index $self $client_ports $server $port REJECT DENY
	done

	# Permit connections to specific external hosts
	# If no servers are specified, permit all hosts

	default_to_any $policyservers $index

	for server in `combine $policyservers $index`
	do
		tcpm oopop$index iopop$index $self $client_ports $server $port
	done
}

# incoming_tcpudp_any
#     create and populate rule chains that allow incoming connections from
#     the addresses given in a policy variable (any host, by default) to a
#     local tcp service and a local udp service with the same port number
# e.g.
#     incoming_tcpudp_any cdns 53 ICDNS_CLIENTS $i

incoming_tcpudp_any() {
	local service=$1 port=$2 policyclients=$3 index=$4 client_ports=$5
	[ -z "$client_ports" ] && client_ports="1024:"

	chains i$service $index # incoming and outgoing rule chains for incoming $service

	# Permit connections from specific external hosts
	# If no clients are specified, permit all hosts

	default_to_any $policyclients $index

	for client in `combine $policyclients $index`
	do
		udp ii$service$i oi$service$i $client $client_ports $self $port
		tcp ii$service$i oi$service$i $client $client_ports $self $port
	done
}

# outgoing_tcpudp_only
#     create and populate rule chains that allow outgoing connections from
#     the local host and masqueraded internal hosts to a tcp service and a
#     udp service with the same port number on specific external hosts given
#     in a policy variable
# e.g.
#     outgoing_tcpudp_only cdns 53 OCDNS_SERVERS $i

outgoing_tcpudp_only() {
	local service=$1 port=$2 policyservers=$3 index=$4 client_ports=$5
	[ -z "$client_ports" ] && client_ports="$normal_ports"

	chains o$service $index # incoming and outgoing rule chains for outgoing $service

	# Permit connections to specific external hosts

	for server in `combine $policyservers $index`
	do
		udpm oo$service$index io$service$index $self $client_ports $server $port
		tcpm oo$service$index io$service$index $self $client_ports $server $port
	done
}

# incoming_tcp_byport
#     create and populate rule chains that allow incoming connections from any
#     external host for a local tcp service on ports given in a policy variable
# e.g.
#     incoming_tcp_byport http INTERNAL_HTTP_PORTS $i

incoming_tcp_byport() {
	local service=$1 policyports=$2 index=$3

	chains i$service $index # incoming and outgoing rule chains for incoming $service

	# Permit connections from all hosts

	eval policyports=\$$policyports

	for port in $policyports
	do
		tcp ii$service$index oi$service$index $any 1024: $self $port
	done
}

# outgoing_tcp_byport
#     create and populate rule chains that allow connections to any external
#     host for a tcp service on ports given in a policy variable (all ports,
#     by default)
# e.g.
#     outgoing_tcp_byport http EXTERNAL_HTTP_PORTS $i

outgoing_tcp_byport() {
	local service=$1 policyports=$2 index=$3

	chains o$service $index # outgoing and incoming rule chains for outgoing $service

	# Permit connections to limited ports on all hosts
	# If no ports are specified, permit all ports

	eval policyports="\$$policyports"
	[ -z "$policyports" ] && policyports=":"

	for port in $policyports
	do
		tcpm oo$service$index io$service$index $self $normal_ports $any $port
	done
}

# incoming_udp_only
#     create and populate rule chains that allow incoming connections from
#     the addresses given in a policy variable to a local udp service
# e.g.
#     incoming_udp_only snmp 161 SNMP_CLIENTS $i

incoming_udp_only() {
	local service=$1 port=$2 policyclients=$3 index=$4 client_ports=$5
	[ -z "$client_ports" ] && client_ports="1024:"

	chains i$service $index # incoming and outgoing rule chains for incoming $service

	# Permit connections from specific external hosts

	for client in `combine $policyclients $index`
	do
		udp ii$service$i oi$service$i $client $client_ports $self $port
	done
}

# outgoing_udp_only
#     create and populate rule chains that allow outgoing connections from
#     the local host and masqueraded internal hosts to a udp service on
#     specific external hosts given in a policy variable
# e.g.
#     outgoing_udp_only snmp 161 SNMP_SERVERS $i

outgoing_udp_only() {
	local service=$1 port=$2 policyservers=$3 index=$4 client_ports=$5
	[ -z "$client_ports" ] && client_ports="$normal_ports"

	chains o$service $index # incoming and outgoing rule chains for outgoing $service

	# Permit connections to specific external hosts

	for server in `combine $policyservers $index`
	do
		udpm oo$service$index io$service$index $self $client_ports $server $port
	done
}

##############################################################################
# For each untrusted interface's ip addresses, create rules for each
# supported service using the ip address and the contents of the relevant
# policy variables. They might not all end up being used but we don't know
# until later when we look at the SERVICES policy variables. This doesn't
# affect the actual packet filtering but it does slow down the process of
# starting the firewall :( XXX This should be fixed.
#

# Each untrusted interface has a number from 0 to 9.

i=-1
for selves in $untrusted_addresses
do
	i=`expr $i + 1`

	# They may have aliases and hence multiple ip addresses.

	for self in `echo $selves | sed 's/,/ /g'`
	do

##############################################################################
# Incoming Client DNS
#
# Note: This is needed when this host runs a registered DNS server that can
# be accessed by external hosts (resolvers or BIND 8 servers without
# "query-source port 53"). For a bastion DNS slave server host, give access
# to all hosts. For an internal DNS master server host, give access to the
# bastion DNS server host for zone transfers if it runs BIND 8 without
# "query-source port 53". However, it would be better for the bastion DNS
# slave server to "query-source port 53" so that only incoming Server DNS
# from the bastion host is required for this host.
#

incoming_tcpudp_any cdns 53 ICDNS_CLIENTS $i

##############################################################################
# Outgoing Client DNS
#
# Note: This is needed when this host's resolver queries external DNS
# servers. This is also needed even when the resolver queries the local DNS
# server if that server is BIND 8 without "query-source port 53". If the
# resolver only queries the local DNS server which has been configured with
# "query-source port 53", only outgoing Server DNS is required for this
# host.
#

outgoing_tcpudp_only cdns 53 OCDNS_SERVERS $i

##############################################################################
# Incoming Server DNS
#
# Note: This is only needed when this host runs a registered DNS server that
# can be accessed by external DNS servers (BIND 4 servers and BIND 8 servers
# with "query-source port 53"). For a bastion DNS slave server host, give
# access to all hosts. For an internal DNS master server host, give access
# to the bastion DNS slave server host for zone transfers if it runs BIND 4
# or BIND 8 with "query-source port 53".
#

incoming_tcpudp_any sdns 53 ISDNS_CLIENTS $i 53

##############################################################################
# Outgoing Server DNS
#
# Note: This is needed when this host runs a DNS server (BIND 4 or BIND 8
# with "query-source port 53") that queries external DNS servers. For an
# internal host, forward all queries to a bastion (or your ISP's) DNS server
# and give access to only those servers. For a bastion DNS server host, give
# access to all hosts.
#

outgoing_tcpudp_only sdns 53 OSDNS_SERVERS $i 53

##############################################################################
# Incoming SMTP
#
# Note: If this is a bastion host, run smap and permit all hosts to connect.
# Otherwise, only permit connections from the bastion host and run smap.
#

incoming_tcp_any smtp 25 SMTP_CLIENTS $i

##############################################################################
# Outgoing SMTP
#
# Note: If this host is a bastion, permit connections to all hosts, otherwise
# only permit connections to the bastion host.
#

outgoing_tcp_any smtp 25 SMTP_SERVERS $i

##############################################################################
# Incoming POP
#
# Note: This is an extremely bad idea since real user names and passwords
# and private mail will be transmitted over the net in plaintext.
#

incoming_tcp_any pop 109:110 POP_CLIENTS $i

##############################################################################
# Outgoing POP
#
# Note: This is an extremely bad idea when the user name and password or
# people's private mail are too sensitive to be transmitted over the net in
# plaintext. Use $EVIL_POP_SERVERS to deny such uses while allowing less
# sensitive POP access.
#

outgoing_tcp_exclusive pop 109:110 POP_SERVERS EVIL_POP_SERVERS $i

##############################################################################
# Incoming IMAP
#
# Note: This is an extremely bad idea if any external IMAP clients or internal
# IMAP servers don't support and use the "AUTHENTICATE" command instead of the
# "LOGIN" command since user names, passwords and people's private mail will
# be transmitted over the net in plaintext.
#

incoming_tcp_any imap 143 IMAP_CLIENTS $i

##############################################################################
# Outgoing IMAP
#
# Note: This is an extremely bad idea if any internal IMAP clients or external
# IMAP servers don't support and use the "AUTHENTICATE" command instead of the
# "LOGIN" command since user names, passwords and people's private mail will
# be transmitted over the net in plaintext. Use $EVIL_IMAP_SERVERS to deny
# such uses while allowing secure IMAP access.
#

outgoing_tcp_exclusive imap 143 IMAP_SERVERS EVIL_IMAP_SERVERS $i

##############################################################################
# Incoming SSL-POP
#

incoming_tcp_any spop 995 SPOP_CLIENTS $i

##############################################################################
# Outgoing SSL-POP
#

outgoing_tcp_any spop 995 SPOP_SERVERS $i

##############################################################################
# Incoming SSL-IMAP
#

incoming_tcp_any simap 993 SIMAP_CLIENTS $i

##############################################################################
# Outgoing SSL-IMAP
#

outgoing_tcp_any simap 993 SIMAP_SERVERS $i

##############################################################################
# Incoming SSL-LDAP
#

incoming_tcp_any sldap 636 SLDAP_CLIENTS $i

##############################################################################
# Outgoing SSL-LDAP
#

outgoing_tcp_any sldap 636 SLDAP_SERVERS $i

##############################################################################
# Incoming SSH1
#
# Note: Permit this rather than telnet or ftp. You can restrict this to
# specific, trusted hosts.
#

incoming_tcp_any ssh1 22 SSH1_CLIENTS $i $SSH1_PORTS

##############################################################################
# Outgoing SSH1
#
# Note: Permit this rather than telnet or ftp. You can restrict this to
# specific, trusted hosts.
#

outgoing_tcp_any ssh1 22 SSH1_SERVERS $i $SSH1_PORTS

##############################################################################
# Incoming SSH2
#
# Note: Permit this rather than telnet or ftp. You can restrict this to
# specific, trusted hosts.
#

incoming_tcp_any ssh2 22 SSH2_CLIENTS $i

##############################################################################
# Outgoing SSH2
#
# Note: Permit this rather than telnet or ftp. You can restrict this to
# specific, trusted hosts.
#

outgoing_tcp_any ssh2 22 SSH2_SERVERS $i

##############################################################################
# Incoming FTP
#
# Note: This is an extremely bad idea if this host is are running a
# non-anonymous FTP server since real user names, passwords and private
# files will be transmitted over the net in plaintext. Use rsync over ssh
# instead. This should only be used on a bastion host running an anonymous
# FTP server.
#

incoming_tcp_any ftp 21 FTP_CLIENTS $i

##############################################################################
# Incoming Normal FTP
#
# Note: This is an extremely bad idea if this host is are running a
# non-anonymous FTP server since real user names, passwords and private
# files will be transmitted over the net in plaintext. Use rsync over ssh
# instead. This should only be used on a bastion host running an anonymous
# FTP server.
#

chains inftp $i # outgoing and incoming rule chains for incoming FTP (normal mode)

# Include common incoming FTP connection rules

ipchains -A oinftp$i -j oiftp$i
ipchains -A iinftp$i -j iiftp$i

# Permit Normal FTP connections from specific external hosts
# If no clients are specified, permit all hosts

default_to_any FTP_CLIENTS $i

for client in `combine FTP_CLIENTS $i`
do
	tcp oinftp$i iinftp$i $self 20 $client 1024:
done

##############################################################################
# Incoming Passive FTP
#
# Note: This is an extremely bad idea if this host is are running a
# non-anonymous FTP server since real user names, passwords and private
# files will be transmitted over the net in plaintext. It is also an
# extremely bad idea since it may allow any host to connect to any tcp port
# above 1023. Use rsync over ssh instead. This should only be used on a
# bastion host running an anonymous FTP server.
#

chains ipftp $i # incoming and outgoing rule chains for incoming FTP (passive mode)

# Include common incoming FTP connection rules

ipchains -A iipftp$i -j iiftp$i
ipchains -A oipftp$i -j oiftp$i

# Permit Passive FTP connections from specific external hosts
# If no clients are specified, permit all hosts

default_to_any FTP_CLIENTS $i

for client in `combine FTP_CLIENTS $i`
do
	tcp iipftp$i oipftp$i $client 1024: $self $normal_ports
done

##############################################################################
# Outgoing FTP
#
# Note: This is an extremely bad idea if used for non-anonymous FTP access
# since real user names, passwords and private files will be transmitted
# over the net in plaintext. Use $EVIL_FTP_SERVERS to deny such uses and
# require that users use rsync over ssh instead.
#

chains oftp $i # outgoing and incoming rule chains for outgoing FTP

# Deny FTP connections to specific external hosts where the user name and
# password required to connect or the contents of the files is too sensitive
# to be transmitted over the net in plaintext

for server in `combine EVIL_FTP_SERVERS $i`
do
	tcpmno ooftp$i ioftp$i $self $normal_ports $server 21 REJECT DENY
done

# Permit FTP connections to specific external hosts
# If no servers are specified, permit all hosts

default_to_any FTP_SERVERS $i

for server in `combine FTP_SERVERS $i`
do
	tcpm ooftp$i ioftp$i $self $normal_ports $server 21
done

##############################################################################
# Outgoing Normal FTP
#
# Note: This is an extremely bad idea if used for non-anonymous FTP access
# since real user names, passwords and private files will be transmitted
# over the net in plaintext. Use $EVIL_FTP_SERVERS to deny such uses and
# require that users use rsync over ssh instead. It is also an extremely bad
# idea since it allows any host to connect to any tcp port above 1023.
# Instead, restrict connections to a bastion host running an FTP proxy.
#

chains onftp $i # incoming and outgoing rule chains for outgoing FTP (normal mode)

# Include common outgoing FTP connection rules

ipchains -A ionftp$i -j ioftp$i
ipchains -A oonftp$i -j ooftp$i

# Deny FTP connections to specific external hosts where the user name and
# password required to connect or the contents of the files is too sensitive
# to be transmitted over the net in plaintext

for server in `combine EVIL_FTP_SERVERS $i`
do
	tcpno ionftp$i oonftp$i $server 20 $self $normal_ports DENY REJECT
done

# Permit Normal FTP connections to specific external hosts
# If no servers are specified, permit all hosts

default_to_any FTP_SERVERS $i

for server in `combine FTP_SERVERS $i`
do
	tcp ionftp$i oonftp$i $server 20 $self $normal_ports
done

##############################################################################
# Outgoing Passive FTP
#
# Note: This is an extremely bad idea if used for non-anonymous FTP access
# since real user names, passwords and private files will be transmitted
# over the net in plaintext. Use $EVIL_FTP_SERVERS to deny such uses and
# require that users use rsync over ssh instead.
#

chains opftp $i # outgoing and incoming rule chains for outgoing FTP (passive mode)

# Include common outgoing FTP connection rules

ipchains -A oopftp$i -j ooftp$i
ipchains -A iopftp$i -j ioftp$i

# Deny FTP connections to specific external hosts where the user name and
# password required to connect or the contents of the files is too sensitive
# to be transmitted over the net in plaintext

for server in `combine EVIL_FTP_SERVERS $i`
do
	tcpmno oopftp$i iopftp$i $self $normal_ports $server 1024: REJECT DENY
done

# Permit Passive FTP connections to specific external hosts
# If no servers are specified, permit all hosts

default_to_any FTP_SERVERS $i

for server in `combine FTP_SERVERS $i`
do
	tcpm oopftp$i iopftp$i $self $normal_ports $server 1024:
done

##############################################################################
# Incoming TELNET
#
# Note: This is an extremely bad idea since real user names, passwords and
# login sessions will be transmitted over the net in plaintext. Require that
# users use ssh instead.
#

incoming_tcp_only teln 23 TELNET_CLIENTS $i

##############################################################################
# Outgoing TELNET
#
# Note: This is an extremely bad idea since real user names, passwords and
# login sessions will be transmitted over the net in plaintext. Require that
# users use ssh instead.
#

outgoing_tcp_exclusive teln 23 TELNET_SERVERS EVIL_TELNET_SERVERS $i

##############################################################################
# Incoming HTTP
#
# Note: Only run public HTTP servers on bastion hosts.
#

incoming_tcp_byport http INTERNAL_HTTP_PORTS $i

##############################################################################
# Outgoing HTTP
#
# Note: You can limit HTTP connections to certain ports on external hosts
# with $EXTERNAL_HTTP_PORTS. By default, this is "80 81 800 8000 8080 8088".
# It is safe to make $EXTERNAL_HTTP_PORTS empty, permitting local clients to
# connect to any port (potentially an HTTP server) on any host and receive
# the responses but you'd be better off using a caching HTTP proxy on a
# bastion host anyway.
#

outgoing_tcp_byport http EXTERNAL_HTTP_PORTS $i

##############################################################################
# Incoming HTTPS
#
# Note: Only run public HTTPS servers on bastion hosts.
#

incoming_tcp_byport https INTERNAL_HTTPS_PORTS $i

##############################################################################
# Outgoing HTTPS
#
# Note: You can limit HTTPS connections to certain ports on external hosts
# with $EXTERNAL_HTTPS_PORTS. By default, this is "443". It is safe to make
# $EXTERNAL_HTTPS_PORTS empty, permitting local clients to connect to any
# port (potentially an HTTPS server) on any host and receive the responses
# but you'd be better off using a caching HTTPS proxy on a bastion host anyway.
#

outgoing_tcp_byport https EXTERNAL_HTTPS_PORTS $i

##############################################################################
# Incoming HTTP PROXY
#
# Note: You need this if your web proxy is internal and it has external
# clients (don't do that), or if this host is a bastion and the interface
# being filtered connects to the internal network.
#

chains iproxy $i # incoming and outgoing rule chains for incoming HTTP PROXY

# Permit HTTP PROXY connections to limited ports on specified hosts

for client in `combine INTERNAL_HTTP_PROXY_CLIENTS $i`
do
	for port in $INTERNAL_HTTP_PROXY_PORTS
	do
		tcp iiproxy$i oiproxy$i $client 1024: $self $port
	done
done

##############################################################################
# Outgoing HTTP PROXY
#
# Note: You need this if your web proxy is running on a bastion host.
#

chains oproxy $i # outgoing and incoming rule chains for outgoing HTTP PROXY

# Permit HTTP PROXY connections to limited ports on specified hosts

for server in `combine EXTERNAL_HTTP_PROXY_SERVERS $i`
do
	for port in $EXTERNAL_HTTP_PROXY_PORTS
	do
		tcpm ooproxy$i ioproxy$i $self $normal_ports $server $port
	done
done

##############################################################################
# Incoming NNTP
#
# Note: Don't run an NNTP server on a bastion host. Run it on an internal
# host and only permit connections from trusted external NNTP servers.
#

incoming_tcp_only nntp 119 NNTP_CLIENTS $i

##############################################################################
# Outgoing NNTP
#
# Note: Only permit NNTP connections to trusted external NNTP servers.
#

outgoing_tcp_only nntp 119 NNTP_SERVERS $i

##############################################################################
# Incoming RSYNC
#
# Note: Don't allow this over a firewall. Use rsync over ssh instead.
#

incoming_tcp_only rsync 873 RSYNC_CLIENTS $i

##############################################################################
# Outgoing RSYNC
#
# Note: Don't allow this over a firewall. Use rsync over ssh instead.
#

outgoing_tcp_only rsync 873 RSYNC_SERVERS $i

##############################################################################
# Incoming CVS
#
# Note: Don't allow this over a firewall. Use rsync over ssh instead.
#

incoming_tcp_only cvs 2401 CVS_CLIENTS $i

##############################################################################
# Outgoing CVS
#
# Note: Don't allow this over a firewall. Use rsync over ssh instead.
#

outgoing_tcp_only cvs 2401 CVS_SERVERS $i

##############################################################################
# Incoming GNATS
#

incoming_tcp_only gnats 1529 GNATS_CLIENTS $i

##############################################################################
# Outgoing GNATS
#

outgoing_tcp_only gnats 1529 GNATS_SERVERS $i

##############################################################################
# Incoming MYSQL
#

incoming_tcp_only mysql 3306 MYSQL_CLIENTS $i

##############################################################################
# Outgoing MYSQL
#

outgoing_tcp_only mysql 3306 MYSQL_SERVERS $i

##############################################################################
# Incoming SMB
#
# Note: This is probably a bad idea over a firewall.
#

chains ismb $i # incoming and outgoing rule chains for incoming SMB

# Permit SMB connections from specific external hosts
# If no clients are specified, permit all hosts

default_to_any SMB_CLIENTS $i

for client in `combine SMB_CLIENTS $i`
do
	udp iismb$i oismb$i $client 137 $self 137
	udp iismb$i oismb$i $client 138 $self 138
	tcp iismb$i oismb$i $client 1024: $self 139
done

##############################################################################
# Outgoing SMB
#
# Note: This is probably a bad idea over a firewall.
#

chains osmb $i # outgoing and incoming rule chains for outgoing SMB

# Permit SMB connections to specific external hosts
# If no servers are specified, permit all hosts

default_to_any SMB_SERVERS $i

for server in `combine SMB_SERVERS $i`
do
	udp oosmb$i iosmb$i $self 137 $server 137
	udpm oosmb$i iosmb$i $self 138 $server 138
	tcpm oosmb$i iosmb$i $self $normal_ports $server 139
done

##############################################################################
# Incoming IRC
#
# Note: If this host run an internal IRC server, make sure it can't
# communicate with external IRC servers or it will attach itself to the IRC
# spanning tree through which this host can be attacked. Also, DCC
# connections between IRC clients isn't supported because it's a very bad
# idea across a firewall.
#

incoming_tcp_any irc 6667 IRC_CLIENTS $i

##############################################################################
# Outgoing IRC
#
# Note: IRC clients can be dangerous and you shouldn't allow IRC across a
# firewall. It's best to run them on a victim host. Also, DCC connections
# between IRC clients isn't supported because it's a very bad idea across a
# firewall.
#

outgoing_tcp_any irc 6667 IRC_SERVERS $i

##############################################################################
# Incoming ICQ
#
# Note: Don't allow this through a firewall. ICQ is dangerous. It leaves
# 2001 tcp ports open. Run ICQ servers on an external victim host.
#

chains iicq $i # incoming and outgoing rule chains for incoming ICQ

# Permit ICQ connections from specific external hosts
# If no clients are specified, permit all hosts

default_to_any ICQ_CLIENTS $i

for client in `combine ICQ_CLIENTS $i`
do
	tcp iiicq$i oiicq$i $client 1024: $self 2000:4000
	udp iiicq$i oiicq$i $client 1024: $self 4000
done

##############################################################################
# Outgoing ICQ
#
# Note: Don't allow this through a firewall. ICQ is dangerous. Run ICQ
# clients on an external victim host.
#

chains oicq $i # outgoing and incoming rule chains for outgoing ICQ

# Permit ICQ connections to specific external hosts
# If no servers are specified, permit all hosts

default_to_any ICQ_SERVERS $i

for server in `combine ICQ_SERVERS $i`
do
	tcpm ooicq$i ioicq$i $self $normal_ports $server 2000:4000
	udpm ooicq$i ioicq$i $server 4000 $self $normal_ports
done

##############################################################################
# Incoming RealAudio/QuickTime
#
# Note: You don't need this. This is a bad idea since it leaves 30 udp
# ports open.
#

chains ireal $i # incoming and outgoing rule chains for incoming RealAudio/QuickTime

# Permit RealAudio connections from specific external hosts
# If no clients are specified, permit all hosts

default_to_any REALAUDIO_CLIENTS $i

for client in `combine REALAUDIO_CLIENTS $i`
do
	tcp iireal$i oireal$i $client 1024: $self 554
	tcp iireal$i oireal$i $client 1024: $self 7070:7071
	udp iireal$i oireal$i $client 6970:6999 $self $normal_ports
done

##############################################################################
# Outgoing RealAudio/QuickTime
#
# Note: You may need special kernel modules for this. This is a bad idea
# since it leaves 30 udp ports open.
#

chains oreal $i # outgoing and incoming rule chains for outgoing RealAudio/QuickTime

# Permit RealAudio connections to specific external hosts
# If no servers are specified, permit all hosts

default_to_any REALAUDIO_SERVERS $i

for server in `combine REALAUDIO_SERVERS $i`
do
	tcpm ooreal$i ioreal$i $self $normal_ports $server 554
	tcpm ooreal$i ioreal$i $self $normal_ports $server 7070:7071
	udpm ooreal$i ioreal$i $self 6970:6999 $server 1024:
done

##############################################################################
# NTP
#

chains ntp $i # incoming and outgoing rule chains for NTP

# Permit queries and responses between specific servers

for server in `combine NTP_SERVERS $i`
do
	udp ontp$i intp$i $self 123 $server 123
done

##############################################################################
# Incoming NTP
#
# Note: Only permit this if this host is running a public NTP server. If
# it's an internal host, only permit connections from a proxy DNS server
# running on a bastion host.

chains intp $i # incoming and outgoing rule chains for incoming NTP

# Include common NTP server rules

ipchains -A iintp$i -j intp$i
ipchains -A ointp$i -j ontp$i

# Permit NTP connections from specific hosts
# If no clients are specified, permit all hosts

default_to_any NTP_CLIENTS $i

for client in `combine NTP_CLIENTS $i`
do
	udp iintp$i ointp$i $client 1024: $self 123
done

##############################################################################
# Outgoing NTP
#
# Note: Permit this if you synchronize your network from external NTP
# servers. Restrict NTP connections to only those NTP servers.
#

chains ontp $i # outgoing and incoming rule chains for outgoing NTP

# Include common NTP server rules

ipchains -A oontp$i -j ontp$i
ipchains -A iontp$i -j intp$i

# Permit NTP connections from specific hosts

for server in `combine NTP_SERVERS $i`
do
	udpm oontp$i iontp$i $self $normal_ports $server 123
done

##############################################################################
# Incoming GOPHER
#
# Note: Don't use this. It's for GOPHER servers. I'm just being silly.
# If you must run a public GOPHER server, run it on a bastion host.
#

incoming_tcp_byport goph INTERNAL_GOPHER_PORTS $i

##############################################################################
# Outgoing GOPHER
#
# Note: Don't use this. Use an HTTP-GOPHER gateway.
#

outgoing_tcp_byport goph EXTERNAL_GOPHER_PORTS $i

##############################################################################
# Incoming WAIS
#
# Note: Don't use this. It's for WAIS servers. I'm just being silly.
# If you must run a public WAIS server, run it on a bastion host.
#

incoming_tcp_byport wais INTERNAL_WAIS_PORTS $i

##############################################################################
# Outgoing WAIS
#
# Note: Don't use this. Use an HTTP-WAIS gateway instead.
#

outgoing_tcp_byport wais EXTERNAL_WAIS_PORTS $i

##############################################################################
# Outgoing ARCHIE
#
# Note: Don't use this. Use an HTTP-ARCHIE gateway instead. If you must
# permit this, restrict it to the well known ARCHIE servers.
#

outgoing_udp_only arch 1525 ARCHIE_SERVERS $i

##############################################################################
# Incoming FINGER
#
# Note: Only run a public (secure) FINGER server on a bastion host.
#

incoming_tcp_any fing 79 FINGER_CLIENTS $i

##############################################################################
# Outgoing FINGER
#
# Note: Make sure this host's finger clients can handle non-printable
# characters in finger output otherwise programmable terminals may get
# themselves reprogrammed.
#

outgoing_tcp_any fing 79 FINGER_SERVERS $i

##############################################################################
# Outgoing WHOIS
#
# Note: Restrict WHOIS connections to the well known WHOIS servers.
# Do not run a WHOIS server.
#

outgoing_tcp_any whois 43 WHOIS_SERVERS $i

##############################################################################
# Incoming AUTH
#
# Note: Permitting this speeds up outgoing SMTP and FTP communications since
# some SMTP and FTP servers attempt to identify their clients. However,
# handing out local user names to anonymous FTP servers is not necessarily a
# good idea. See man identd for details.
#

incoming_tcp_any auth 113 AUTH_CLIENTS $i

##############################################################################
# Outgoing AUTH
#
# Note: It is safe to permit this except that it may be used by local
# attackers to gain information about external hosts.
#

outgoing_tcp_any auth 113 AUTH_SERVERS $i

##############################################################################
# Incoming SYSLOG
#
# Note: Only use this to collect syslog messages from a bastion host.
#

chains ilog$i # incoming SYSLOG

# Permit SYSLOG packets from specific external hosts

for client in `combine SYSLOG_CLIENTS $i`
do
	udp1 iilog$i $client : $self 514
done

##############################################################################
# Outgoing SYSLOG
#
# Note: Only use this to send syslog messages from the bastion host to an
# internal host.
#

chains olog$i # outgoing SYSLOG

# Permit SYSLOG packets to specific external hosts

for server in `combine SYSLOG_SERVERS $i`
do
	udp1 oolog$i $self : $server 514
done

##############################################################################
# DHCP Server
#
# Note: You probably don't need this.
#

chains sdhcp $i # incoming and outgoing rule chains for DHCP Server

# Permit DHCP traffic between this host and specific external hosts
# If no clients are specified, permit all hosts

default_to_any DHCP_CLIENTS $i

for client in `combine DHCP_CLIENTS $i`
do
	udp osdhcp$i isdhcp$i $self 67 $client 68
	udp1 osdhcp$i $self 67 $broadcast_dst 68
	udp1 isdhcp$i $broadcast_src 68 $self 67
done

# Outgoing address update
udp1 osdhcp$i $broadcast_src 67 $broadcast_dst 68
udp1 isdhcp$i $broadcast_src 68 $broadcast_dst 67

##############################################################################
# DHCP Client
#
# Note: Only allow DHCP traffic to/from trusted external DHCP servers.
#

chains cdhcp $i # incoming and outgoing rule chains for DHCP Client

# Permit DHCP traffic between this host and specific external hosts

for server in `combine DHCP_SERVERS $i`
do
	udp icdhcp$i ocdhcp$i $server 67 $any 68
	udp1 icdhcp$i $server 67 $broadcast_dst 68
	udp1 ocdhcp$i $broadcast_src 68 $server 67
done

if [ -n "`combine DHCP_SERVERS $i`" ]
then
	# Incoming address update
	udp1 icdhcp$i $broadcast_src 67 $broadcast_dst 68
	udp1 ocdhcp$i $broadcast_src 68 $broadcast_dst 67
fi

##############################################################################
# Incoming SNMP
#
# Note: You probably don't want to permit this across a firewall.
# If you do, only allow connections from trusted SNMP management stations.
#

incoming_udp_only snmp 161 SNMP_CLIENTS $i

##############################################################################
# Outgoing SNMP
#
# Note: You probably don't want to permit this across a firewall.
# If you do, only allow connections to trusted SNMP network devices.
#

outgoing_udp_only snmp 161 SNMP_SERVERS $i

##############################################################################
# Incoming SNMP TRAP
#
# Note: You probably don't want to permit this across a firewall.
# If you do, only allow connections from trusted SNMP management stations.
#

incoming_udp_only snmpt 162 SNMP_TRAP_CLIENTS $i

##############################################################################
# Outgoing SNMP TRAP
#
# Note: You probably don't want to permit this across a firewall.
# If you do, only allow connections to trusted SNMP network devices.
#

outgoing_udp_only snmpt 162 SNMP_TRAP_SERVERS $i

##############################################################################
# Incoming BGP
#
# Note: You probably don't want to permit this across a firewall.
# If you do, only allow connections from trusted BGP peers.
#

incoming_tcp_only bgp 179 BGP_CLIENTS $i

##############################################################################
# Outgoing BGP
#
# Note: You probably don't want to permit this across a firewall.
# If you do, only allow connections to trusted BGP peers.
#

outgoing_tcp_only bgp 179 BGP_SERVERS $i

##############################################################################
# OSPF
#
# Note: You must have ospf(89) in /etc/protocols.
#

if [ -n "$OSPF_PROTOCOL" ]
then
	chains ospf $i # incoming and outgoing rule chains for OSPF

	# Permit OSPF traffic to/from specific external routers

	for router in `combine OSPF_ROUTERS $i`
	do
		other ospf oospf$i iospf$i $self $router # protocol 89
	done
fi

##############################################################################
# Incoming RIP
#
# Note: You probably don't want to permit this across a firewall.
# If you do, only allow connection from trusted routers.
#

chains irip $i # incoming and outgoing rule chains for incoming RIP

# Permit RIP requests from specific external hosts

for client in `combine RIP_CLIENTS $i`
do
	# Incoming RIP broadcast from specified host (server)
	udp1 iirip$i $client 520 $self 520
	# Incoming RIP request from specified host (client)
	udp iirip$i oirip$i $client 1024: $self 520
done

##############################################################################
# Outgoing RIP
#
# Note: You probably don't want to permit this across a firewall.
# If you do, only allow connection to trusted routers.
#

chains orip $i # outgoing and incoming rule chains for outgoing RIP

# Permit RIP requests to specific external hosts

for server in `combine RIP_SERVERS $i`
do
	# Outgoing RIP broadcast to specified host (server)
	udpm1 oorip$i $self 520 $server 520
	# Outgoing RIP request to specified host (client)
	udpm oorip$i iorip$i $self $normal_ports $server 520
done

##############################################################################
# Incoming KERBEROS
#

chains ikerb $i # incoming and outgoing rule chains for incoming KERBEROS

# Permit KERBEROS connections from specific external hosts
# If no clients are specified, permit all hosts

default_to_any KERBEROS_CLIENTS $i

for client in `combine KERBEROS_CLIENTS $i`
do
	tcp iikerb$i oikerb$i $client 1024: $self 88      # kerberos
	tcp iikerb$i oikerb$i $client 1024: $self 543:544 # klogin/kshell
	tcp iikerb$i oikerb$i $client 1024: $self 749     # kadmin
done

##############################################################################
# Outgoing KERBEROS
#

chains okerb $i # incoming and outgoing rule chains for outgoing KERBEROS

# Permit KERBEROS connections to specific external hosts
# If no servers are specified, permit all hosts

default_to_any KERBEROS_SERVERS $i

for server in `combine KERBEROS_SERVERS $i`
do
	tcpm ookerb$i iokerb$i $self $normal_ports $server 88      # kerberos
	tcpm ookerb$i iokerb$i $self $normal_ports $server 543:544 # klogin/kshell
	tcpm ookerb$i iokerb$i $self $normal_ports $server 749     # kadmin
done

##############################################################################
# Incoming PPTP
#
# Note: You must have pptp(47) in /etc/protocols to use this.
# Warning: Some iMplementationS of PPTP are completely insecure, use IPSEC.
#

if [ -n "$PPTP_PROTOCOL" ]
then
	chains ipptp $i # incoming and outgoing rule chains for incoming PPTP

	# Permit PPTP connections from specific external hosts
	# If no clients are specified, permit all hosts

	default_to_any PPTP_CLIENTS $i

	for client in `combine PPTP_CLIENTS $i`
	do
		tcp iipptp$i oipptp$i $client 1024: $self 1723
		other pptp iipptp$i oipptp$i $client $self # protocol 47
	done
fi

##############################################################################
# Outgoing PPTP
#
# Note: You must have pptp(47) in /etc/protocols to use this.
# Warning: Some iMplementationS of PPTP are completely insecure, use IPSEC.
#

if [ -n "$PPTP_PROTOCOL" ]
then
	chains opptp $i # outgoing and incoming rule chains for outgoing PPTP

	# Permit PPTP connections to specific external hosts
	# If no servers are specified, permit all hosts

	default_to_any PPTP_SERVERS $i

	for server in `combine PPTP_SERVERS $i`
	do
		tcp oopptp$i iopptp$i $self $normal_ports $server 1723
		other pptp oopptp$i iopptp$i $self $server # protocol 47
	done
fi

##############################################################################
# Incoming IPSEC
#
# Note: You must have esp(50) and ah(51) in /etc/protocols to use this.
#

if [ -n "$ESP_PROTOCOL" -a -n "$AH_PROTOCOL" ]
then
	chains iipsec $i # incoming and outgoing rule chains for incoming IPSEC

	# Permit IPSEC connections from specific external hosts
	# If no clients are specified, permit all hosts

	default_to_any IPSEC_CLIENTS $i

	for client in `combine IPSEC_CLIENTS $i`
	do
		udp iiipsec$i oiipsec$i $client 500 $self 500
		other esp iiipsec$i oiipsec$i $client $self # protocol 50
		other ah iiipsec$i oiipsec$i $client $self # protocol 51
	done
fi

##############################################################################
# Outgoing IPSEC
#
# Note: You must have esp(50) and ah(51) in /etc/protocols to use this.
#

if [ -n "$ESP_PROTOCOL" -a -n "$AH_PROTOCOL" ]
then
	chains oipsec $i # outgoing and incoming rule chains for outgoing IPSEC

	# Permit IPSEC connections to specific external hosts
	# If no servers are specified, permit all hosts

	default_to_any IPSEC_SERVERS $i

	for server in `combine IPSEC_SERVERS $i`
	do
		udp ooipsec$i ioipsec$i $self 500 $client 500
		other esp ooipsec$i ioipsec$i $self $client # protocol 50
		other ah ooipsec$i ioipsec$i $self $client # protocol 51
	done
fi

##############################################################################
# Incoming PING
#
# Note: Only permit incoming pings from external hosts that have a reason to
# be pinging this host (e.g. your ISP).
#

chains iping $i # incoming and outgoing rule chains for incoming PING

# Permit PING requests from specific hosts

for client in `combine PING_CLIENTS $i`
do
	# Incoming PING: echo-request
	icmp iiping$i $client $self 8 $LOG
	# Outgoing PONG: echo-reply
	icmp oiping$i $self $client 0
done

##############################################################################
# Outgoing PING
#
# Note: This can be used by local attackers to flood external hosts but it
# is very useful. You can restrict outgoing PING to specific hosts if you
# want.
#

chains oping $i # outgoing and incoming rule chains for outgoing PING

# Permit PING requests to specific hosts
# If no servers are specified, permit all hosts

default_to_any PING_SERVERS $i

for server in `combine PING_SERVERS $i`
do
	# Outgoing PING: echo-request
	icmp ooping$i $self $server 8
	# Incoming PONG: echo-reply
	icmp ioping$i $server $self 0
done

##############################################################################
# Incoming TRACEROUTE
#
# Note: Only permit incoming traceroute from external hosts that have a
# reason to be tracing this network (e.g. your ISP). You can also limit
# which udp ports may be used for incoming traceroute by prior arrangement
# with those wishing to trace your network (recommended).
#

chains itrace $i # incoming and outgoing rule chains for incoming TRACEROUTE

# Permit TRACEROUTE requests from specific hosts

for client in `combine TRACEROUTE_CLIENTS $i`
do
	# Incoming TRACEROUTE probe
	udp1 iitrace$i $client $ITRACEROUTE_SRC_PORTS $self $ITRACEROUTE_DST_PORTS $LOG
	# Incoming TRACEROUTE responses: time-exceeded, destination-unreachable
	icmp oitrace$i $self $client 11
	icmp oitrace$i $self $client 3
done

##############################################################################
# Outgoing TRACEROUTE
#
# Note: This can be used by local attackers to gather information about
# external hosts but it is very useful. You can restrict outgoing TRACEROUTE
# to specific hosts if you want.
#

chains otrace $i # outgoing and incoming rule chains for outgoing TRACEROUTE

# Permit TRACEROUTE requests to specific hosts
# If no servers are specified, permit all hosts

default_to_any TRACEROUTE_SERVERS $i

for server in `combine TRACEROUTE_SERVERS $i`
do
	# Outgoing TRACEROUTE probe
	udpm1 ootrace$i $self $OTRACEROUTE_SRC_PORTS $server $OTRACEROUTE_DST_PORTS
	# Outgoing TRACEROUTE responses: time-exceeded, destination-unreachable
	icmp iotrace$i $server $self 11
	icmp iotrace$i $server $self 3
done

##############################################################################
# Other ICMP packets
#
# Note: This isn't configurable yet. Munge the [io]icmp chains as needed.
#

chains icmp $i # incoming and outgoing rule chains for other ICMP packets

# Permit incoming destination-unreachable

icmp iicmp$i $any $self 3
#icmp oicmp$i$i $self $any 3
icmp oicmp$i $self $any fragmentation-needed

# Permit incoming and outgoing source-quench

icmp iicmp$i $any $self 4
icmp oicmp$i $self $any 4

# Permit incoming and outgoing time-exceeded

icmp iicmp$i $any $self 11
icmp oicmp$i $self $any 11

# Permit incoming and outgoing parameter-problem

icmp iicmp$i $any $self 12
icmp oicmp$i $self $any 12

##############################################################################
# Prevent connections to notoriously insecure services (e.g. X Windows,
# NFS, SOCKS, OpenWindows)
#
# Note: There can up to 64(?) X servers on a host, occupying one port each.
# Blocking 64 ports (whether there are actually that many X servers running or
# not) can cause problems for other services that innocently bind to those
# ports only to find that nobody can connect. If you are certain that this host
# will never run that many X servers, you can reduce the range given in
# $XWIN_PORTS to something less aggressive: 6000:6000+#Xservers-1
#

chains danger $i # incoming and outgoing rule chains for dangerous services

# Permit specific X clients to connect
# Note: Don't use this

for client in `combine XWIN_CLIENTS $i`
do
	tcpsyn idanger$i $client : $self $XWIN_PORTS ACCEPT
	tcpsyn odanger$i $self : $client $XWIN_PORTS ACCEPT
done

for ports in $XWIN_PORTS $EVIL_TCP_PORTS
do
	tcpsyn idanger$i $any : $self $ports DENY $LOG
	tcpsyn odanger$i $self : $any $ports REJECT $LOG
done

##############################################################################
# Self Spoofing
#
# Note: Most spoof detection is interface independent (see below) except for
# spoofing of this host's interfaces' addresses.
#

chain ispoof $i

# Catch incoming packets that claim to be from this host
if [ "$self" != "$any" ]
then
	ipchains -A ispoof$i -s $self -j DENY $LOG
fi

##############################################################################
# Other TCP Services
#
# Note: This only works for applications with a simple, single-connection
# application protocol.
#

# List of ports on this host that any external host can connect to

for port in $OTHER_INCOMING_TCP_SERVICES
do
	incoming_tcp_any user $port any $i
done

# List of ports on any host that this network may connect to

for port in $OTHER_OUTGOING_TCP_SERVICES
do
	outgoing_tcp_any user $port any $i
done

##############################################################################
# No Log
#
# After you've set up your firewall, you may find regular, harmless packets
# being blocked and logged (e.g. netbios broadcasts). If you don't want them
# to be logged, you can add port numbers to these variables and they will
# be blocked but not logged.
#

chains nolog $i

# Deny incoming udp packets without logging them

for port in `combine INOLOG_UDP_PORTS $i`
do
	noudp1 inolog$i $any : $self $port DENY
done

# Reject outgoing udp packets without logging them

for port in `combine ONOLOG_UDP_PORTS $i`
do
	noudp1 onolog$i $self : $any $port REJECT
done

# Deny incoming tcp packets without logging them

for port in `combine INOLOG_TCP_PORTS $i`
do
	notcp1 inolog$i $any : $self $port DENY
done

# Reject outgoing tcp packets without logging them

for port in `combine ONOLOG_TCP_PORTS $i`
do
	notcp1 onolog$i $self : $any $port REJECT
done

##############################################################################
# End of service chain loop for each untrusted interface's ip addresses.
#

	done
done

##############################################################################
# Packet Fragments
#
# Note: This isn't configurable yet. Munge the [io]frag chains as needed.
#

chains frag # incoming and outgoing rule chains for fragments

# Note: The kernel must "always defrag" so as to avoid attacks where packets
# that would not pass through the filter aren't assembled until after filtering
# so we should deny any fragments that make it this far. There shouldn't be
# any.

ipchains -A ifrag -f -j DENY $LOG
ipchains -A ofrag -f -j REJECT $LOG

##############################################################################
# IP Spoofing
#
# Note: The kernel performs IP spoof protection as explained in the
# following extract from the "Advanced Router" section's help in the
# kernel configuration.
#
#   If you turn on IP forwarding, you will also get the rp_filter, which
#   automatically rejects incoming packets if the routing table entry
#   for their source address doesn't match the network interface they're
#   arriving on. This has security advantages because it prevents the
#   so-called IP spoofing, however it can pose problems if you use
#   asymmetric routing (packets from you to a host take a different path
#   than packets from that host to you) or if you operate a non-routing
#   host which has several IP addresses on different interfaces.
#
# If most packets take the default route, this only preally protects the host
# from packets pretending to come from the internal network, not packets
# pretending to come from some external network (that you may trust to some
# extent). Following the lead of http://linux-firewall-tools.com, we at least
# guard against anyone using blatantly illegal network addresses (Perhaps they
# do this in the hope that they won't have to conflict with anyone else's
# routing tables to get return packets back(?)).
#

chains spoof # incoming and outgoing rule chains for spoofed packets

# Catch incoming packets that claim to be from an internal network
for local_network in $INTERNAL_NETWORKS
do
	ipchains -A ispoof -s $local_network -j DENY $LOG
done

# Catch packets claiming to be to or from illegal networks
for illegal_netork in $ILLEGAL_NETWORKS
do
	ipchains -A ispoof -s $illegal_netork -j DENY $LOG
	ipchains -A ispoof -d $illegal_netork -j DENY $LOG
	ipchains -A ospoof -s $illegal_netork -j REJECT $LOG
	ipchains -A ospoof -d $illegal_netork -j REJECT $LOG
done

# Catch incoming packets with the wrong type of broadcast address
ipchains -A ispoof -s $broadcast_dst -j DENY $LOG
ipchains -A ispoof -d $broadcast_src -j DENY $LOG

# Catch packets with a multicast source address
ipchains -A ispoof -s $multicast -j DENY $LOG
ipchains -A ospoof -s $multicast -j REJECT $LOG

# Catch packets with a reserved source address
ipchains -A ispoof -s $reserved  -j DENY $LOG

# Catch incoming packets with IANA reserved source addresses
for reserved_network in $RESERVED_NETWORKS
do
	ipchains -A ispoof -s $reserved_network -j DENY $LOG
done

##############################################################################
# Construct the chains for the untrusted interfaces. All untrusted interfaces
# are protected from spoofing, notoriously dangerous services and problematic
# networks. Each untrusted interface permits services as specified for it in
# the policy file.
#

i=-1
for untrusted in $untrusted_interfaces
do
	i=`expr $i + 1`

	# Create incoming and outgoing chains for the untrusted network interface

	chains $untrusted

	# Disallow spoofing

	ipchains -A i$untrusted -j ispoof$i
	ipchains -A i$untrusted -j ispoof
	ipchains -A o$untrusted -j ospoof

	# Disallow all packets between this network and untrusted networks
	# Note: This is not particularly useful. If it's really hostile,
	# they can spoof some other network's addresses anyway. In fact,
	# they may have been doing so all along.

	for untrusted_network in $UNTRUSTED_NETWORKS
	do
		ipchains -A i$untrusted -s $untrusted_network -j DENY $LOG
		ipchains -A o$untrusted -d $untrusted_network -j REJECT $LOG
	done

	# Add the input/output rule chains to deny dangerous services and to
	# permit required services over $untrusted

	for service in danger$i `number $i \`combine SERVICES $i\`` icmp$i frag nolog$i
	do
		ipchains -A i$untrusted -j i$service
		ipchains -A o$untrusted -j o$service
	done
done

##############################################################################
# Finally, start filtering packets. Set up the built-in chains. Packets on
# trusted interfaces are accepted. Packets on untrusted interfaces must pass
# their respective rule chains. All packets that don't match any terminal
# rule are logged if requested. Masquerading begins here as well if requested.
#

# Accept all packets on trusted interfaces

for trusted in $trusted_interfaces
do
	ipchains -A input  -i $trusted -j ACCEPT
	ipchains -A output -i $trusted -j ACCEPT
done

# Direct packets through each untrusted interface's direction-based chains

for untrusted in $untrusted_interfaces
do
	ipchains -A input  -i $untrusted -j i$untrusted
	ipchains -A output -i $untrusted -j o$untrusted
done

# Masquerade packets between the internal networks and everywhere else
# but not amongst the internal networks themselves.

case "$MASQUERADE" in
	[Yy]es|[Tt]rue|[Oo]n|1)

		# Set masquerading timeouts

		if [ "$MASQ_TCP_TIMEOUT" != 0 -o "$MASQ_TCPFIN_TIMEOUT" != 0 -o "$MASQ_UDP_TIMEOUT" != 0 ]
		then
			ipchains -M -S ${MASQ_TCP_TIMEOUT:-0} ${MASQ_TCPFIN_TIMEOUT:-0} ${MASQ_UDP_TIMEOUT:-0}
		fi

		# Accept (unmasqueraded) traffic amongst multiple internal networks

		for src in $INTERNAL_NETWORKS
		do
			for dst in $INTERNAL_NETWORKS
			do
				if [ "$src" != "$dst" ]
				then
					ipchains -A forward -s $src -d $dst -j ACCEPT
				fi
			done
		done

		# Masquerade traffic from internal networks to the outside world

		for masqnet in $INTERNAL_NETWORKS
		do
			ipchains -A forward -s $masqnet -j MASQ
		done
		;;
esac

# Log all packets that reach the end of their chain

if [ ! -z "$LOG" ]
then
	ipchains -A input $LOG
	ipchains -A output $LOG
	ipchains -A forward $LOG
fi

action "" true

##############################################################################
# Start IP Source Address Verification
#

case "$IPV4_SPOOF_PROTECT" in
	[Nn]o|[Ff]alse|[Oo]ff|0)
		;;
	*)
		echo -n "Starting IP Source Address Verification"
		if [ -w $ipv4/conf/all/rp_filter ]
		then
			for procfile in $ipv4/conf/*/rp_filter
			do
				echo 1 > $procfile
			done
			action "" true
		else
			action "" false
		fi
		;;
esac

##############################################################################
# Start IP Source Routing Protection
#

case "$IPV4_SOURCE_ROUTE_PROTECT" in
	[Nn]o|[Ff]alse|[Oo]ff|0)
		;;
	*)
		echo -n "Starting IP Source Routing Protection"
		if [ -w $ipv4/conf/all/accept_source_route ]
		then
			for procfile in $ipv4/conf/*/accept_source_route
			do
				echo 0 > $procfile
			done
			action "" true
		else
			action "" false
		fi
		;;
esac

##############################################################################
# Start IP ICMP Redirect Protection
#

case "$IPV4_ICMP_REDIRECT_PROTECT" in
	[Nn]o|[Ff]alse|[Oo]ff|0)
		;;
	*)
		echo -n "Starting IP ICMP Redirect Protection"
		if [ -w $ipv4/conf/all/accept_redirects ]
		then
			for procfile in $ipv4/conf/*/accept_redirects
			do
				echo 0 > $procfile
			done
			action "" true
		else
			action "" false
		fi
		;;
esac

##############################################################################
# Start IP TCP SYN Cookie Protection
#

case "$IPV4_TCP_SYN_COOKIE_PROTECT" in
	[Nn]o|[Ff]alse|[Oo]ff|0)
		;;
	*)
		echo -n "Starting IP TCP SYN Cookie Protection"
		if [ -w $ipv4/tcp_syncookies ]
		then
			echo 1 > $ipv4/tcp_syncookies
			action "" true
		else
			action "" false
		fi
		;;
esac

##############################################################################
# Start IP Fragment Protection
#

case "$IPV4_FRAGMENT_PROTECT" in
	[Nn]o|[Ff]alse|[Oo]ff|0)
		;;
	*)
		echo -n "Starting IP Fragment Protection"
		if [ -w $ipv4/ip_always_defrag ]
		then
			echo 1 > $ipv4/ip_always_defrag
			action "" true
		else
			action "" false
		fi
		;;
esac

##############################################################################
# Start IP ICMP Broadcast Echo Protection
#

case "$IPV4_ICMP_BROADCAST_ECHO_PROTECT" in
	[Nn]o|[Ff]alse|[Oo]ff|0)
		;;
	*)
		echo -n "Starting IP ICMP Broadcast Echo Protection"
		if [ -w $ipv4/icmp_echo_ignore_broadcasts ]
		then
			echo 1 > $ipv4/icmp_echo_ignore_broadcasts
			action "" true
		else
			action "" false
		fi
		;;
esac

##############################################################################
# Start IP Bogus Error Response Protection
#

case "$IPV4_BOGUS_ERROR_RESPONSE_PROTECT" in
	[Nn]o|[Ff]alse|[Oo]ff|0)
		;;
	*)
		echo -n "Starting IP Bogus Error Response Protection"
		if [ -w $ipv4/icmp_ignore_bogus_error_responses ]
		then
			echo 1 > $ipv4/icmp_ignore_bogus_error_responses
			action "" true
		else
			action "" false
		fi
		;;
esac

##############################################################################
# Start IP Martian Logging
#

case "$IPV4_LOG_MARTIANS" in
	[Nn]o|[Ff]alse|[Oo]ff|0)
		;;
	*)
		echo -n "Starting IP Martian Logging"
		if [ -w $ipv4/conf/all/log_martians ]
		then
			for procfile in $ipv4/conf/*/log_martians
			do
				echo 0 > $procfile
			done
			action "" true
		else
			action "" false
		fi
		;;
esac

##############################################################################
# Start Dynamic IP Address Hacking in IP MASQ
#

case "$IPV4_DYNADDR" in
	[Yy]es|[Tt]rue|[Oo]n|1)
		echo -n "Starting Dynamic IP Address Hacking in IP MASQ"
		if [ -w $ipv4/ip_dynaddr ]
		then
			echo 1 > $ipv4/ip_dynaddr
			action "" true
		else
			action "" false
		fi
		;;
esac

##############################################################################
# Start IP Packet Forwarding
#

case "$MASQUERADE" in
	[Yy]es|[Tt]rue|[Oo]n|1)
		case "$FORWARD_IPV4" in
			[Nn]o|[Ff]alse|[Oo]ff|0)
				;;
			*)
				echo -n "Starting IP Packet Forwarding"
				if [ -w $ipv4/ip_forward ]
				then
					echo 1 > $ipv4/ip_forward
					action "" true
				else
					action "" false
				fi
				;;
		esac
		;;
esac

exit 0

# vi:set ts=4 sw=4:
