#!/bin/bash
#
# firewall - http://fwup.org/
#
# Copyright (C) 1999, 2000 raf <raf@raf.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
# or visit http://www.gnu.org/copyleft/gpl.html
#

# fwup - Brings up an ipchains packet filtering firewall
#
# Run this before any network interfaces are up
# (i.e. before /etc/rc.d/rc?.d/S??network start)
# and after receiving a dynamic IP address.
#
# Define policy in /etc/firewall.policy
# Read it carefully
#
# 20000914 raf <raf@raf.org>

##############################################################################
# Usage: [policy=filename] [fwdebug=1|2] fwup
#
# The policy variable determines the policy file to implement. By default,
# it is /etc/firewall.policy. Setting this in the policy file has no effect.
#
# If the fwdebug variable is 1, all ipchains, ipmasqadm and ip commands are
# printed on stderr before they are executed. If fwdebug is 2, the values of
# policy variables are also printed to stderr as they are used.
#

##############################################################################
# Start by checking that we've got everything we need
#

# Set the path explicitly

PATH=/sbin:/usr/sbin:/bin:/usr/bin

# Define a version of redhat's action function that copes with functions

RES_COL=60
[ -z "$COLUMNS" ] && COLUMNS=80
MOVE_TO_COL="echo -en \\033[300C\\033[$[${COLUMNS}-${RES_COL}]D"
SETCOLOR_SUCCESS="echo -en \\033[1;32m"
SETCOLOR_FAILURE="echo -en \\033[1;31m"
SETCOLOR_NORMAL="echo -en \\033[0;39m"

log()
{
	[ -z "$PROG_NAME" ] && PROG_NAME="`basename $0`"
	logger -t "$PROG_NAME" -p daemon.notice $*
}

die()
{
	log -s $*
	exit 1
}

success()
{
	local msg="$1"
	log $msg succeeded
	echo -n $msg
	$MOVE_TO_COL
	echo -n "[  "
	$SETCOLOR_SUCCESS
	echo -n "OK"
	$SETCOLOR_NORMAL
	echo "  ]"
	return 0
}

failure()
{
	local msg="$1"
	log $msg failed
	echo -n $msg
	$MOVE_TO_COL
	echo -n "["
	$SETCOLOR_FAILURE
	echo -n "FAILED"
	$SETCOLOR_NORMAL
	echo "]"
	return 1
}

action()
{
	local msg="$1"; shift
	$* && success "$msg" || failure "$msg"
}

not()
{
	"$@" && return 1 || return 0
}

yes()
{
	case "$1" in
		[Yy]es|[Tt]rue|[Oo]n|1)
			return 0
			;;
		*)
			return 1
			;;
	esac
}

no()
{
	case "$1" in
		[Nn]o|[Ff]alse|[Oo]ff|0)
			return 0
			;;
		*)
			return 1
			;;
	esac
}

# Source the network configuration (if redhat)

[ -r /etc/sysconfig/network ] && . /etc/sysconfig/network

# Check that networking is required (if redhat)

[ "$NETWORKING" = "no" ] && exit 0

# Check that ipchains is available

[ ! -x /sbin/ipchains ] && die "failed to find executable /sbin/ipchains"

# Check whether or not ipchains has the ipchains-Q patch

if /sbin/ipchains --help | grep quick >/dev/null
then
	[ -z "$fwdebug" ] && IPCHAINS_QUICK=1
fi

# Check that ifconfig is available

[ ! -x /sbin/ifconfig ] && die "failed to find executable /sbin/ifconfig"

# Check for other protocols that we might need

grep '^ospf' /etc/protocols >/dev/null && OSPF_PROTOCOL="1"
grep '^pptp' /etc/protocols >/dev/null && PPTP_PROTOCOL="1"
grep '^esp' /etc/protocols >/dev/null && ESP_PROTOCOL="1"
grep '^ah' /etc/protocols >/dev/null && AH_PROTOCOL="1"

# Check that the policy file is available

[ -z "$policy" ] && policy=/etc/firewall.policy

[ ! -r $policy ] && die "failed to find readable $policy"

# Check for ipmasqadm and ip later, iff they are needed

##############################################################################
# Define some network addresses
#

# Matches every ip address

any="0/0"

# Broadcast source addess

broadcast_src="0.0.0.0/32"

# Broadcast destination address

broadcast_dst="255.255.255.255/32"

# The loopback address (never to appear on the internet)

loopback="127.0.0.0/8"

# Class A, B and C private addresses (never to appear on the internet)

private_a="10.0.0.0/8"
private_b="172.16.0.0/12"
private_c="192.168.0.0/16"

# Class D multicast address

multicast="224.0.0.0/4"

# Class E reserved address

reserved="240.0.0.0/5"

# Illegal addresses

ILLEGAL_NETWORKS="$loopback $private_a $private_b $private_c"

# Reserved addresses

RESERVED_NETWORKS="1.0.0.0/8 2.0.0.0/8 5.0.0.0/8 7.0.0.0/8 23.0.0.0/8 27.0.0.0/8 31.0.0.0/8 37.0.0.0/8 39.0.0.0/8 41.0.0.0/8 42.0.0.0/8 49.0.0.0/8 50.0.0.0/8 58.0.0.0/7 60.0.0.0/8 65.0.0.0/8 66.0.0.0/8 67.0.0.0/8 68.0.0.0/8 69.0.0.0/8 70.0.0.0/8 71.0.0.0/8 72.0.0.0/8 73.0.0.0/8 74.0.0.0/8 75.0.0.0/8 76.0.0.0/8 77.0.0.0/8 78.0.0.0/8 79.0.0.0/8 80.0.0.0/4 96.0.0.0/4 112.0.0.0/8 113.0.0.0/8 114.0.0.0/8 115.0.0.0/8 116.0.0.0/8 117.0.0.0/8 118.0.0.0/8 119.0.0.0/8 120.0.0.0/8 121.0.0.0/8 122.0.0.0/8 123.0.0.0/8 124.0.0.0/8 125.0.0.0/8 126.0.0.0/8 197.0.0.0/8 217.0.0.0/8 218.0.0.0/8 219.0.0.0/8 220.0.0.0/6"

##############################################################################
# Determine some system specific port numbers
#

ipv4=/proc/sys/net/ipv4

# Range of local return port numbers

if [ -r $ipv4/ip_local_port_range ]
then
	normal_ports=`sed 's/\W/:/' < $ipv4/ip_local_port_range`
else
	normal_ports="1024:"
fi

# Range of port numbers used for masquerading
# These are defined in /usr/src/linux/include/net/ip_masq.h

[ -z "$masq_ports" ] && masq_ports="61000:65096"

##############################################################################
# Define some default port numbers. You can override these in the policy file.
#

# Range of X Window server ports to avoid like the plague

XWIN_PORTS="6000:6063"

# List of other tcp ports to avoid like the plague (NFS, SOCKS, OpenWindows)

EVIL_TCP_PORTS="2049 1080 2000:2010"

# List of particularly nasty udp ports to avoid like the plague

EVIL_UDP_PORTS=""

# Allowable HTTP server port numbers (this is stupid, use a proxy)

EXTERNAL_HTTP_PORTS="80 81 800 8000 8080 8088"
INTERNAL_HTTP_PORTS="80"

# Allowable HTTPS server port numbers (this is stupid, use a proxy)

EXTERNAL_HTTPS_PORTS="443"
INTERNAL_HTTPS_PORTS="443"

# Allowable HTTP PROXY server port numbers

EXTERNAL_HTTP_PROXY_PORTS="8080"
INTERNAL_HTTP_PROXY_PORTS="8080"

# Allowable GOPHER server port numbers (this is stupid, use a proxy)

EXTERNAL_GOPHER_PORTS="70"
INTERNAL_GOPHER_PORTS="70"

# Allowable WAIS server port numbers (this is stupid, use a proxy)

EXTERNAL_WAIS_PORTS="210"
INTERNAL_WAIS_PORTS="210"

# Allowable udp ports used by traceroute

ITRACEROUTE_SRC_PORTS="32769:65535"
ITRACEROUTE_DST_PORTS="33434:33523"
OTRACEROUTE_SRC_PORTS="32769:65535"
OTRACEROUTE_DST_PORTS="33434:33523"

# Allowable tcp ports used by ssh1

[ -z "$SSH1_PORTS" ] && SSH1_PORTS="513:1023"

# Allowable icmp packet types

OTHER_INCOMING_ICMP="3 4 11 12"
OTHER_OUTGOING_ICMP="fragmentation-needed 4 11 12"

# UDP ports needed for RTP for video/audio over IP

RTP_PORTS="4000:4400" # For 1 E1
# RTP_PORTS="4000:4800" # For 2 E1
# RTP_PORTS="4000:5200" # For 3 E1
# RTP_PORTS="4000:5600" # For 4 E1

# Ports needed for net2phone

NET2PHONE_UDP_PORT=6802
NET2PHONE_TCP_PORT=6802

##############################################################################
# Define some default timeout values used for masquerading. You can override
# these in the policy file.
#

# Timeout in seconds for masqueraded tcp addresses
# Zero means leave the timeout as it is

MASQ_TCP_TIMEOUT="0"

# Timeout in seconds for masqueraded tcp addresses after receiving FIN
# Zero means leave the timeout as it is

MASQ_TCPFIN_TIMEOUT="0"

# Timeout in seconds for masqueraded udp addresses
# Zero means leave the timeout as it is

MASQ_UDP_TIMEOUT="0"

##############################################################################
# Load the IP packet filtering policy and check it
#

# Source the policy file

. $policy

# Check that $TRUSTED_INTERFACES is defined (at least lo)

[ -z "$TRUSTED_INTERFACES" ] && die "\$TRUSTED_INTERFACES must be defined in $policy (e.g. TRUSTED_INTERFACES=\"eth0 lo\")"

# If $INTERNAL_NETWORKS isn't defined, derive it from $TRUSTED_INTERFACES

[ -z "$INTERNAL_NETWORKS" ] && INTERNAL_NETWORKS="`ifconfig | awk '

	# Print the addresses and network masks of the internal interfaces (not lo)

	BEGIN {

		# Receive input one interface at a time, not one line at a time
		RS="";

		# Build a dictionary of internal interfaces to look for (exclude lo)
		split(substr(ARGV[1], index(ARGV[1], "=") + 1), ifaces, " +");
		for (i in ifaces)
			if (ifaces[i] != "lo")
				internal[ifaces[i]] = 1;
	}

	{
		# All records but the first have $1 == "\0" for some reason
		iface = ($1 != "\0") ? $1 : $2;

		# Identify the real device for aliases
		if ((colon = index(iface, ":")) != 0)
			iface = substr(iface, 0, colon - 1);

		# Skip interfaces that we are not interested in
		if (internal[iface] == "")
			next;

		# Print the network pattern of this interface for ipchains
		if (match($0, /inet addr:[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/) == 0)
			next;

		addr = substr($0, RSTART + 10, RLENGTH - 10);

		if (match($0, /Mask:[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/) == 0)
			next;

		mask = substr($0, RSTART + 5, RLENGTH - 5);

		print addr "/" mask;
	}

' list="$TRUSTED_INTERFACES"`"

# Check that $UNTRUSTED_INTERFACES is defined

[ -z "$UNTRUSTED_INTERFACES" ] && die "\$UNTRUSTED_INTERFACES must be defined in $policy (e.g. UNTRUSTED_INTERFACES=\"ppp0\")"

# Check that there aren't too many interfaces listed in $UNTRUSTED_INTERFACES

too_many()
{
	[ $# -gt 10 ]
}

too_many $UNTRUSTED_INTERFACES && die "Too many untrusted interfaces (only supports 10)"

# Find the IP addresses of the untrusted interfaces (if they are up).
# These addresses will be used in the packet rules. If any of the
# interfaces aren't up yet, we will use $any in the packet rules.
# If any interfaces have aliases, we treat their addresses as being
# equal for that interface.

[ -z "$UNTRUSTED_ADDRESSES" ] && UNTRUSTED_ADDRESSES="`ifconfig | awk '

	# Print the addresses of the untrusted interfaces in order of the
	# appearance of their interface (multiple addresses/aliases are comma
	# separated, interfaces that are down result in a 0/0 address)

	BEGIN {
		# Receive input one interface at a time, not one line at a time
		RS="";

		# Build a dictionary of untrusted interfaces to look for
		split(substr(ARGV[1], index(ARGV[1], "=") + 1), ifaces, " +");
		for (i in ifaces)
			untrusted[ifaces[i]] = 1;
	}

	{
		# All records but the first have $1 == "\0" for some reason
		iface = ($1 != "\0") ? $1 : $2;

		# Identify the real device for aliases
		if ((colon = index(iface, ":")) != 0)
			iface = substr(iface, 0, colon - 1);

		# Skip interfaces that we are not interested in
		if (untrusted[iface] == "")
		{
			delete untrusted[iface]; # negate auto-vivification
			next;
		}

		# Store the address in a dictionary (comma separated when aliased)
		if (match($0, /inet addr:[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/) == 0)
			next;

		addr = substr($0, RSTART + 10, RLENGTH - 10);
		addresses[iface] = (addresses[iface] == "") ? addr : addresses[iface] "," addr;
	}

	END {
		# Print addresses in order of the appearance of its interface
		for (i in ifaces)
		{
			iface = ifaces[i];
			print (addresses[iface] != "") ? addresses[iface] : "'$any'";
		}
	}

' list="$UNTRUSTED_INTERFACES"`"

# Check the network topology variables

# Static NAT requires iproute2 and $NAT
if yes "$STATIC_NAT"
then
	# Check that ip is available
	[ ! -x /sbin/ip ] && die "failed to find executable /sbin/ip (required for static NAT)"
	# Check that /etc/iproute2 is available
	[ ! -d /etc/iproute2 ] && die "failed to find directory /etc/iproute2 (required for static NAT)"
	# Check the policy variable
	[ -z "$NAT" ] && die "\$NAT must be defined in $policy (required for static NAT)"
fi

# Alias port porwarding requires iproute2 and $ALIAS_PORTFW and implies port forwarding
if yes "$ALIAS_PORT_FORWARDING"
then
	# Check that ip is available
	[ ! -x /sbin/ip ] && die "failed to find executable /sbin/ip (required for alias port porwarding)"
	# Check the policy variable
	[ -z "$ALIAS_PORTFW" ] && die "\$ALIAS_PORTFW must be defined in $policy (required for alias port porwarding)"
	# Implies PORT_FORWARDING
	PORT_FORWARDING="yes"
fi

# Port forwarding requires ipmasqadm and $PORTFW and implies masquerading
if yes "$PORT_FORWARDING"
then
	# Check that ipmasqadm is available
	[ ! -x /usr/sbin/ipmasqadm ] && die "failed to find executable /usr/sbin/ipmasqadm (required for port forwarding)"
	# Check the policy variable
	not yes "$ALIAS_PORT_FORWARDING" && [ -z "$PORTFW" -a -z "$PORTRANGEFW" ] && die "\$PORTFW or \$PORTRANGEFW must be defined in $policy (required for port forwarding)"
	# Implies MASQUERADING
	MASQUERADING="yes"
fi

# If masquerading is required, check that $INTERNAL_NETWORKS is defined.
# Also check that at most one of MASQUERADING, FORWARDING and STATIC_NAT has
# been requested. They are mutually exclusive.

if yes "$FORWARDING"
then
	[ -z "$INTERNAL_NETWORKS" ] && die "\$INTERNAL_NETWORKS must be defined in $policy (e.g. INTERNAL_NETWORKS=\"10.0.0.0/8\")"
	yes "$MASQUERADING" && die "\$FORWARDING and \$MASQUERADING are mutually exclusive"
	yes "$STATIC_NAT" && die "\$FORWARDING and \$STATIC_NAT are mutually exclusive"
fi

if yes "$MASQUERADING"
then
	[ -z "$INTERNAL_NETWORKS" ] && die "\$INTERNAL_NETWORKS must be defined in $policy (e.g. INTERNAL_NETWORKS=\"10.0.0.0/8\")"
	yes "$FORWARDING" && die "\$MASQUERADING and \$FORWARDING are mutually exclusive"
	yes "$STATIC_NAT" && die "\$MASQUERADING and \$STATIC_NAT are mutually exclusive"
fi

if yes "$STATIC_NAT"
then
	[ -z "$INTERNAL_NETWORKS" ] && die "\$INTERNAL_NETWORKS must be defined in $policy (e.g. INTERNAL_NETWORKS=\"10.0.0.0/8\")"
	yes "$MASQUERADING" && die "\$STATIC_NAT and \$MASQUERADING are mutually exclusive"
	yes "$FORWARDING" && die "\$STATIC_NAT and \$FORWARDING are mutually exclusive"
fi

# Check that $OCDNS_SERVERS or $OSDNS_SERVERS is defined or really obvious

[ -z "$OCDNS_SERVERS" ] && OCDNS_SERVERS="`awk '/^nameserver/ { if ($2 != "127.0.0.1") { printf "%s/32\n", $2 } }' /etc/resolv.conf`"

[ -z "$OCDNS_SERVERS$OSDNS_SERVERS" ] && die "Either \$OCDNS_SERVERS or \$OSDNS_SERVERS must be defined in $policy"

# Log all denied/rejected packets except those in the "NOLOG" variables

no "$LOG" && LOG="" || LOG="-l"

# Set the blocking policies

[ -z "$BLOCKIN" ] && BLOCKIN="DENY"
[ -z "$BLOCKOUT" ] && BLOCKOUT="REJECT"
[ -z "$BLOCKFWD" ] && BLOCKFWD="REJECT"

# Check the blocking policies

for block in BLOCKIN BLOCKOUT BLOCKFWD
do
	eval block_policy="\$$block"
	[ "$block_policy" != "DENY" -a "$block_policy" != "REJECT" ] && die "\$$block must be either DENY or REJECT"
done

##############################################################################
# Support for ipchains -Q (very fast ipchains)
#

cmdfile="/tmp/ipchains.q"

quick_start()
{
	rm -f $cmdfile
	touch $cmdfile
	chmod 600 $cmdfile
}

quick()
{
	echo $* >> $cmdfile
}

quick_run()
{
	/sbin/ipchains -Q $cmdfile
	local rc=$?
	rm -f $cmdfile
	return $rc
}

##############################################################################
# Debugging
#

dbg()
{
	[ -n "$fwdebug" ] && [ "$fwdebug" -gt 0 ]
}

dbg2()
{
	[ -n "$fwdebug" ] && [ "$fwdebug" -gt 1 ]
}

ipchains()
{
	dbg && echo ipchains $* >&2
	yes "$IPCHAINS_QUICK" && quick ipchains $* || /sbin/ipchains $*
}

ipmasqadm()
{
	dbg && echo ipmasqadm $* >&2
	/usr/sbin/ipmasqadm $*
}

ip()
{
	dbg && echo ip $* >&2
	/sbin/ip $*
}

##############################################################################
# Helper functions.
#

# chain basename index
#
# Create a chain if it doesn't already exist

chain()
{
	local name=$1 index=$2
	eval [ -z "\$chain_$name$index" ] && ipchains -N $name$index
	eval chain_$name$index="1"
}

# chains basename index
#
# Create input and output chains by prepending 'i' and 'o', respectively,
# to basename and appending index

chains()
{
	local base=$1 index=$2
	chain i$base $index
	chain o$base $index
}

# domasq index
#
# Returns 1 if masquerading is required on the current interface, 0 otherwise

domasq()
{
	local index=$1
	yes "$MASQUERADING" && [ "$index" = "0" ]
}

# tcp chain1 chain2 srcaddr srcport dstaddr dstport
#
# Accept a tcp service from src to dst on chain1 and replies on chain2

tcp()
{
	local chain1=$1 chain2=$2 srcaddr=$3 srcport=$4 dstaddr=$5 dstport=$6
	ipchains -A $chain1 -p tcp -s $srcaddr $srcport -d $dstaddr $dstport -j ACCEPT
	ipchains -A $chain2 -p tcp -s $dstaddr $dstport -d $srcaddr $srcport ! -y -j ACCEPT
}

# tcpmasq chain1 chain2 srcaddr srcport dstaddr dstport
#
# Accept an outgoing tcp service for this host and masqueraded hosts

tcpmasq()
{
	local chain1=$1 chain2=$2 srcaddr=$3 srcport=$4 dstaddr=$5 dstport=$6
	tcp $chain1 $chain2 $srcaddr $srcport $dstaddr $dstport
	tcp $chain1 $chain2 $srcaddr $masq_ports $dstaddr $dstport
}

# tcpm index chain1 chain2 srcaddr srcport dstaddr dstport
#
# Accept an outgoing tcp service for this host and masqueraded hosts if
# masquerading and this is on the first untrusted interface. Just accept
# the tcp service as stated, otherwise.

tcpm()
{
	local index=$1 chain1=$2 chain2=$3 srcaddr=$4 srcport=$5 dstaddr=$6 dstport=$7
	if domasq $index
	then
		tcpmasq $chain1 $chain2 $srcaddr $srcport $dstaddr $dstport
	else
		tcp $chain1 $chain2 $srcaddr $srcport $dstaddr $dstport
	fi
}

# tcpno chain1 chain2 srcaddr srcport dstaddr dstport target1 target2
#
# Deny a tcp service: On chain1, make tcp src to dst jump to target1. On
# chain2, make tcp dst to src responses jump to target2. If chain1 is the
# input chain and chain2 is the output chain, target1 should be deny and
# target2 should be reject. If chain1 is the output chain and chain2 is the
# input chain, target1 should be reject and target2 should be deny.

tcpno()
{
	local chain1=$1 chain2=$2 srcaddr=$3 srcport=$4 dstaddr=$5 dstport=$6 target1=$7 target2=$8
	ipchains -A $chain1 -p tcp -s $srcaddr $srcport -d $dstaddr $dstport -j $target1 $LOG
	ipchains -A $chain2 -p tcp -s $dstaddr $dstport -d $srcaddr $srcport ! -y -j $target2 $LOG
}

# tcpmasqno chain1 chain2 srcaddr srcport dstaddr dstport target1 target2
#
# Deny an outgoing tcp service for this host and masqueraded hosts

tcpmasqno()
{
	local chain1=$1 chain2=$2 srcaddr=$3 srcport=$4 dstaddr=$5 dstport=$6 target1=$7 target2=$8
	tcpno $chain1 $chain2 $srcaddr $srcport $dstaddr $dstport $target1 $target2
	tcpno $chain1 $chain2 $srcaddr $masq_ports $dstaddr $dstport $target1 $target2
}

# tcpmno chain1 chain2 srcaddr srcport dstaddr dstport target1 target2
#
# Deny an outgoing tcp service for this host and masqueraded hosts if
# masquerading and this is on the first untrusted interface. Just deny
# the tcp service as stated, otherwise.

tcpmno()
{
	local index=$1 chain1=$2 chain2=$3 srcaddr=$4 srcport=$5 dstaddr=$6 dstport=$7 target1=$8 target2=$9
	if domasq $index
	then
		tcpmasqno $chain1 $chain2 $srcaddr $srcport $dstaddr $dstport $target1 $target2
	else
		tcpno $chain1 $chain2 $srcaddr $srcport $dstaddr $dstport $target1 $target2
	fi
}

# tcpsyn chain srcaddr srcport dstaddr dstport target extra
#
# Accept or deny a tcp connection: On chain, make tcp src to dst connections
# jump to target. extra is for the logging option, -l.

tcpsyn()
{
	local chain=$1 srcaddr=$2 srcport=$3 dstaddr=$4 dstport=$5 target=$6 extra=$7
	ipchains -A $chain -p tcp -s $srcaddr $srcport -d $dstaddr $dstport -y -j $target $extra
}

# udp1 chain srcaddr srcport dstaddr dstport extra
#
# Accept a udp packet: On chain, accept udp src to dst. extra is for the
# logging option, -l.

udp1()
{
	local chain=$1 srcaddr=$2 srcport=$3 dstaddr=$4 dstport=$5 extra=$6
	ipchains -A $chain -p udp -s $srcaddr $srcport -d $dstaddr $dstport -j ACCEPT $extra
}

# udpmasq1 chain srcaddr srcport dstaddr dstport extra
#
# Accept an outgoing udp packet for this host and masqueraded hosts

udpmasq1()
{
	local chain=$1 srcaddr=$2 srcport=$3 dstaddr=$4 dstport=$5 extra=$6
	udp1 $chain $srcaddr $srcport $dstaddr $dstport $extra
	udp1 $chain $srcaddr $masq_ports $dstaddr $dstport $extra
}

# udpm1 chain srcaddr srcport dstaddr dstport extra
#
# Accept an outgoing udp packet for this host and masqueraded hosts if
# masquerading and this is on the first untrusted interface. Just accept
# the udp packet as stated, otherwise.

udpm1()
{
	local index=$1 chain=$2 srcaddr=$3 srcport=$4 dstaddr=$5 dstport=$6 extra=$7
	if domasq $index
	then
		udpmasq1 $chain $srcaddr $srcport $dstaddr $dstport $extra
	else
		udp1 $chain $srcaddr $srcport $dstaddr $dstport $extra
	fi
}

# udp chain1 chain2 srcaddr srcport dstaddr dstport
#
# Accept udp src to dst on chain1 and udp dst to src on chain2.

udp()
{
	local chain1=$1 chain2=$2 srcaddr=$3 srcport=$4 dstaddr=$5 dstport=$6
	udp1 $chain1 $srcaddr $srcport $dstaddr $dstport
	udp1 $chain2 $dstaddr $dstport $srcaddr $srcport
}

# udpmasq chain1 chain2 srcaddr srcport dstaddr dstport
#
# Accept an outgoing udp service for this host and masqueraded hosts

udpmasq()
{
	local chain1=$1 chain2=$2 srcaddr=$3 srcport=$4 dstaddr=$5 dstport=$6
	udp $chain1 $chain2 $srcaddr $srcport $dstaddr $dstport
	udp $chain1 $chain2 $srcaddr $masq_ports $dstaddr $dstport
}

# udpmasq chain1 chain2 srcaddr srcport dstaddr dstport
#
# Accept an outgoing udp service for this host and masqueraded hosts if
# masquerading and this is on the first untrusted interface. Just accept
# the udp service as stated, otherwise.

udpm()
{
	local index=$1 chain1=$2 chain2=$3 srcaddr=$4 srcport=$5 dstaddr=$6 dstport=$7
	if domasq $index
	then
		udpmasq $chain1 $chain2 $srcaddr $srcport $dstaddr $dstport
	else
		udp $chain1 $chain2 $srcaddr $srcport $dstaddr $dstport
	fi
}

# noudp1 chain srcaddr srcport dstaddr dstport target extra
#
# Deny/reject a udp packet: On chain, jump to target for udp src to dst.
# extra is for the logging option, -l.

noudp1()
{
	local chain=$1 srcaddr=$2 srcport=$3 dstaddr=$4 dstport=$5 target=$6 extra=$7
	ipchains -A $chain -p udp -s $srcaddr $srcport -d $dstaddr $dstport -j $target $extra
}

# notcp1 chain srcaddr srcport dstaddr dstport target extra
#
# Deny/reject a tcp packet: On chain, jump to target for udp src to dst.
# extra is for the logging option, -l.

notcp1()
{
	local chain=$1 srcaddr=$2 srcport=$3 dstaddr=$4 dstport=$5 target=$6 extra=$7
	ipchains -A $chain -p tcp -s $srcaddr $srcport -d $dstaddr $dstport -j $target $extra
}

# icmp chain srcaddr dstaddr type extra
#
# Accept icmp type from src to dst on chain. extra is for the logging
# option, -l.

icmp()
{
	local chain=$1 srcaddr=$2 dstaddr=$3 type=$4 extra=$5
	ipchains -A $chain -p icmp -s $srcaddr $type -d $dstaddr -j ACCEPT $extra
}

# other protocol chain1 chain2 srcaddr dstaddr
#
# Accept other protocol from src to dst on chain1 and from dst to src on chain2.

other()
{
	local protocol=$1 chain1=$2 chain2=$3 srcaddr=$4 dstaddr=$5
	ipchains -A $chain1 -p $protocol -s $srcaddr -d $dstaddr -j ACCEPT
	ipchains -A $chain2 -p $protocol -s $dstaddr -d $srcaddr -j ACCEPT
}

# default_to_any varname index
#
# Takes the name of a policy variable and an address loop index as arguments.
# If both the common policy variable and its interface specific equivalent are
# empty, the interface specific policy variable is set to $any. This is used
# by services which accept access to/from all hosts by default.

default_to_any()
{
	local common=$1 index=$2
	eval local specific=\"\${common}_$index\"
	eval [ -z \"\$$common\$$specific\" ] && eval $specific="$any"
}

# combine varname index
#
# Takes the name of a policy variable and an address loop index as arguments.
# Outputs the contents of the common policy variable and its interface specific
# equivalent. This is used by all services.

combine()
{
	local common=$1 index=$2
	eval local specific=\"\${common}_$index\"
	dbg2 && eval echo $common.`index UNTRUSTED_INTERFACES $index` = \$$common \$$specific >&2
	eval echo \$$common \$$specific
}

# number num arg...
#
# Appends the first argument to the remaining arguments and outputs them

number()
{
	local num=$1; shift
	for item in $*
	do
		echo $item$num
	done
}

# index listvarname index
#
# Prints the n-th word (n is $2) in the variable named in $1

index()
{
	local var=$1 index=$2
	eval set \$$var
	index=`expr $index + 1`
	eval echo \$$index
}

# member search arg...
#
# Returns 0 if the 1st argument is the same as any of the following
# arguments, 1 if it is not

member()
{
	local search=$1
	shift
	for item in $*
	do
		[ "$search" = "$item" ] && return 0
	done
	return 1
}

# incoming_tcp_only service target port clientsvarname index [clientports]
#
# Create and populate rule chains that allow incoming connections from the
# specific hosts given in a policy variable to a local/internal tcp service

incoming_tcp_only()
{
	local service=$1 targets="$2" port=$3 clientsvarname=$4 index=$5 client_ports=$6
	[ -z "$client_ports" ] && client_ports="1024:"

	chains i$service $index

	for client in `combine $clientsvarname $index`
	do
		for target in $targets
		do
			tcp ii$service$index oi$service$index $client $client_ports $target $port
		done
	done
}

# incoming1_tcp_only service target port clientsvarname index [clientports]
#
# Create and populate rule chains that allow incoming connections from the
# specific hosts given in a policy variable to a local/internal tcp service
# for services that don't have an incoming/outgoing pair of rulesets

incoming1_tcp_only()
{
	local service=$1 targets="$2" port=$3 clientsvarname=$4 index=$5 client_ports=$6
	[ -z "$client_ports" ] && client_ports="1024:"

	chains $service $index

	for client in `combine $clientsvarname $index`
	do
		for target in $targets
		do
			tcp i$service$index o$service$index $client $client_ports $target $port
		done
	done
}

# incoming_tcp_any service target port clientsvarname index [clientports]
#
# Create and populate rule chains that allow incoming connections from the
# specific hosts given in a policy variable (any host, by default) to a
# local/internal tcp service

incoming_tcp_any()
{
	local service=$1 targets="$2" port=$3 clientsvarname=$4 index=$5 client_ports=$6

	default_to_any $clientsvarname $index
	incoming_tcp_only $service "$targets" $port $clientsvarname $index $client_ports
}

# incoming1_tcp_any service target port clientsvarname index [clientports]
#
# Create and populate rule chains that allow incoming connections from the
# specific hosts given in a policy variable (any host, by default) to a
# local/internal tcp service for services that don't have an incoming/outgoing
# pair of rulesets

incoming1_tcp_any()
{
	local service=$1 targets="$2" port=$3 clientsvarname=$4 index=$5 client_ports=$6

	default_to_any $clientsvarname $index
	incoming1_tcp_only $service "$targets" $port $clientsvarname $index $client_ports
}

# outgoing_tcp_only service target port serversvarname index [clientports]
#
# Create and populate rule chains that allow outgoing connections from the
# local/internal host and masqueraded internal hosts to a tcp service on
# specific external hosts given in a policy variable

outgoing_tcp_only()
{
	local service=$1 targets="$2" port=$3 serversvarname=$4 index=$5 client_ports=$6
	[ -z "$client_ports" ] && client_ports="$normal_ports"

	chains o$service $index

	for server in `combine $serversvarname $index`
	do
		for target in $targets
		do
			tcpm $index oo$service$index io$service$index $target $client_ports $server $port
		done
	done
}

# outgoing1_tcp_only service target port serversvarname index [clientports]
#
# Create and populate rule chains that allow outgoing connections from the
# local/internal host and masqueraded internal hosts to a tcp service on
# specific external hosts given in a policy variable for services that don't
# have an incoming/outgoing pair of rulesets

outgoing1_tcp_only()
{
	local service=$1 targets="$2" port=$3 serversvarname=$4 index=$5 client_ports=$6
	[ -z "$client_ports" ] && client_ports="$normal_ports"

	chains $service $index

	for server in `combine $serversvarname $index`
	do
		for target in $targets
		do
			tcpm $index o$service$index i$service$index $target $client_ports $server $port
		done
	done
}

# outgoing_tcp_any service target port serversvarname index [clientports]
#
# Create and populate rule chains that allow outgoing connections from the
# local/internal host and masqueraded internal hosts to a tcp service on
# specific external hosts given in a policy variable (any host, by default)

outgoing_tcp_any()
{
	local service=$1 targets="$2" port=$3 serversvarname=$4 index=$5 client_ports=$6

	default_to_any $serversvarname $index
	outgoing_tcp_only $service "$targets" $port $serversvarname $index $client_ports
}

# outgoing1_tcp_any service target port serversvarname index [clientports]
#
# Create and populate rule chains that allow outgoing connections from the
# local/internal host and masqueraded internal hosts to a tcp service on
# specific external hosts given in a policy variable (any host, by default)
# for services that don't have an incoming/outgoing pair of rulesets

outgoing1_tcp_any()
{
	local service=$1 targets="$2" port=$3 serversvarname=$4 index=$5 client_ports=$6

	default_to_any $serversvarname $index
	outgoing1_tcp_only $service "$targets" $port $serversvarname $index $client_ports
}

# outgoing_tcp_exclusive service target port serversvarname excludevarname index [clientports]
#
# Create and populate rule chains that allow outgoing connections from the
# local/internal host and masqueraded internal hosts to a tcp service on
# specific hosts given in a policy variable (any host, by default) except
# for specific ones given in another policy variable

outgoing_tcp_exclusive()
{
	local service=$1 targets="$2" port=$3 serversvarname=$4 excludevarname=$5 index=$6 client_ports=$7
	[ -z "$client_ports" ] && client_ports="$normal_ports"

	chains o$service $index

	for server in `combine $excludevarname $index`
	do
		for target in $targets
		do
			tcpmno $index oo$service$index io$service$index $target $client_ports $server $port $BLOCKOUT $BLOCKIN
		done
	done

	outgoing_tcp_any $service "$targets" $port $serversvarname $index $client_ports
}

# incoming_tcpudp_any servce target port clientsvarname index [clientports]
#
# Create and populate rule chains that allow incoming connections from the
# specific hosts given in a policy variable (any host, by default) to a
# local/internal tcp service and a local/internal udp service with the
# same port number

incoming_tcpudp_any()
{
	local service=$1 targets="$2" port=$3 clientsvarname=$4 index=$5 client_ports=$6
	[ -z "$client_ports" ] && client_ports="1024:"

	chains i$service $index

	default_to_any $clientsvarname $index

	for client in `combine $clientsvarname $index`
	do
		for target in $targets
		do
			udp ii$service$index oi$service$index $client $client_ports $target $port
			tcp ii$service$index oi$service$index $client $client_ports $target $port
		done
	done
}

# outgoing_tcpudp_only service target port serversvarname index [clientports]
#
# Create and populate rule chains that allow outgoing connections from the
# local/internal host and masqueraded internal hosts to a tcp service and
# a udp service with the same port number on specific external hosts given
# in a policy variable

outgoing_tcpudp_only()
{
	local service=$1 targets="$2" port=$3 serversvarname=$4 index=$5 client_ports=$6
	[ -z "$client_ports" ] && client_ports="$normal_ports"

	chains o$service $index

	for server in `combine $serversvarname $index`
	do
		for target in $targets
		do
			udpm $index oo$service$index io$service$index $target $client_ports $server $port
			tcpm $index oo$service$index io$service$index $target $client_ports $server $port
		done
	done
}

# incoming_tcp_byport service target portsvarname index
#
# Create and populate rule chains that allow incoming connections from any
# external host for a local/internal tcp service on ports given in a policy
# variable

incoming_tcp_byport()
{
	local service=$1 targets="$2" portsvarname=$3 index=$4

	chains i$service $index

	eval portsvar=\"\$$portsvarname\"

	for target in $targets
	do
		for port in $portsvar
		do
			tcp ii$service$index oi$service$index $any 1024: $target $port
		done
	done
}

# outgoing_tcp_byport service target portsvarname index
#
# create and populate rule chains that allow connections from the
# local/internal host to any external host for a tcp service on ports given
# in a policy variable (all ports, by default)

outgoing_tcp_byport()
{
	local service=$1 targets="$2" portsvarname=$3 index=$4

	chains o$service $index

	eval portsvar=\"\$$portsvarname\"
	[ -z "$portsvar" ] && portsvar=":"

	for target in $targets
	do
		for port in $portsvar
		do
			tcpm $index oo$service$index io$service$index $target $normal_ports $any $port
		done
	done
}

# incoming_udp_only service target port clientsvarname index [clientports]
#
# Create and populate rule chains that allow incoming connections from
# specific hosts given in a policy variable to a local/internal udp service

incoming_udp_only()
{
	local service=$1 targets="$2" port=$3 clientsvarname=$4 index=$5 client_ports=$6
	[ -z "$client_ports" ] && client_ports="1024:"

	chains i$service $index

	for client in `combine $clientsvarname $index`
	do
		for target in $targets
		do
			udp ii$service$index oi$service$index $client $client_ports $target $port
		done
	done
}

# incoming1_udp_only service target port clientsvarname index [clientports]
#
# Create and populate rule chains that allow incoming connections from
# specific hosts given in a policy variable to a local/internal udp service
# for services that don't have an incoming/outgoing pair of rulesets

incoming1_udp_only()
{
	local service=$1 targets="$2" port=$3 clientsvarname=$4 index=$5 client_ports=$6
	[ -z "$client_ports" ] && client_ports="1024:"

	chains $service $index

	for client in `combine $clientsvarname $index`
	do
		for target in $targets
		do
			udp i$service$index o$service$index $client $client_ports $target $port
		done
	done
}

# incoming_udp_any service target port clientsvarname index [clientports]
#
# Create and populate rule chains that allow incoming connections from
# specific hosts given in a policy variable (all hosts, by default) to
# a local/internal udp service

incoming_udp_any()
{
	local service=$1 targets="$2" port=$3 clientsvarname=$4 index=$5 client_ports=$6

	default_to_any $clientsvarname $index
	incoming_udp_only $service "$targets" $port $clientsvarname $index $client_ports
}

# incoming1_udp_any service target port clientsvarname index [clientports]
#
# Create and populate rule chains that allow incoming connections from
# specific hosts given in a policy variable (all hosts, by default) to
# a local/internal udp service

incoming1_udp_any()
{
	local service=$1 targets="$2" port=$3 clientsvarname=$4 index=$5 client_ports=$6

	default_to_any $clientsvarname $index
	incoming1_udp_only $service "$targets" $port $clientsvarname $index $client_ports
}

# outgoing_udp_only service target ports serversvarname index [clientports]
#
# Create and populate rule chains that allow outgoing connections from the
# local/internal host and masqueraded internal hosts to a udp service on
# specific external hosts given in a policy variable

outgoing_udp_only()
{
	local service=$1 targets="$2" port=$3 serversvarname=$4 index=$5 client_ports=$6
	[ -z "$client_ports" ] && client_ports="$normal_ports"

	chains o$service $index

	for server in `combine $serversvarname $index`
	do
		for target in $targets
		do
			udpm $index oo$service$index io$service$index $target $client_ports $server $port
		done
	done
}

# outgoing1_udp_only service target ports serversvarname index [clientports]
#
# Create and populate rule chains that allow outgoing connections from the
# local/internal host and masqueraded internal hosts to a udp service on
# specific external hosts given in a policy variable for services that don't
# have an incoming/outgoing pair of rulesets

outgoing1_udp_only()
{
	local service=$1 targets="$2" port=$3 serversvarname=$4 index=$5 client_ports=$6
	[ -z "$client_ports" ] && client_ports="$normal_ports"

	chains $service $index

	for server in `combine $serversvarname $index`
	do
		for target in $targets
		do
			udpm $index o$service$index i$service$index $target $client_ports $server $port
		done
	done
}

##############################################################################
# The following sections define functions that create rule chains that allow
# specific internet services.
#

##############################################################################
# Incoming Client DNS
#
# Note: This is needed when this host runs a registered DNS server that can
# be accessed by external hosts (resolvers or BIND 8 servers without
# "query-source port 53"). For a bastion DNS slave server host, give access
# to all hosts. For an internal DNS master server host, give access to the
# bastion DNS server host for zone transfers if it runs BIND 8 without
# "query-source port 53". However, it would be better for the bastion DNS
# slave server to "query-source port 53" so that only incoming Server DNS
# from the bastion host is required for this host.
#
# Open: tcp/53 udp/53

icdns()
{
	incoming_tcpudp_any cdns "$1" 53 ICDNS_CLIENTS $2
}

##############################################################################
# Outgoing Client DNS
#
# Note: Don't use this. It leaves too many udp ports open.
# Note: This is needed when this host's resolver queries external DNS
# servers. This is also needed even when the resolver queries the local DNS
# server if that server is BIND 8 without "query-source port 53". If the
# resolver only queries the local DNS server which has been configured with
# "query-source port 53", only outgoing Server DNS is required for this
# host.
#
# Open: tcp(ack)/1024-4999,61000-65096 udp/1024-4999,61000-65096

ocdns()
{
	outgoing_tcpudp_only cdns "$1" 53 OCDNS_SERVERS $2
}

##############################################################################
# Incoming Server DNS
#
# Note: This is only needed when this host runs a registered DNS server that
# can be accessed by external DNS servers (BIND 4 servers and BIND 8 servers
# with "query-source port 53"). For a bastion DNS slave server host, give
# access to all hosts. For an internal DNS master server host, give access
# to the bastion DNS slave server host for zone transfers if it runs BIND 4
# or BIND 8 with "query-source port 53".
#
# Open: tcp/53 udp/53

isdns()
{
	incoming_tcpudp_any sdns "$1" 53 ISDNS_CLIENTS $2 53
}

##############################################################################
# Outgoing Server DNS
#
# Note: This is needed when this host runs a DNS server (BIND 4 or BIND 8
# with "query-source port 53") that queries external DNS servers. For an
# internal host, forward all queries to a bastion (or your ISP's) DNS server
# and give access to only those servers. For a bastion DNS server host, give
# access to all hosts.
#
# Note: Unless $ALLOW_MASQUERADED_OSDNS is "yes", masquerading is ignored
# for this service. It is assumed that the internal DNS server will reside
# on this firewall host rather than on an internal, masqueraded host.
# This allows us to avoid accepting packets to the masquerading ports
# (i.e. 61000:65096) from hostile hosts that impersonate your external
# DNS servers.
#
# Open (no $MASQUERADING):                              tcp(ack)/53 udp/53
# Open ($MASQUERADING and no $ALLOW_MASQUERADED_OSDNS): tcp(ack)/53 udp/53
# Open ($MASQUERADING and $ALLOW_MASQUERADED_OSDNS):    tcp(ack)/53,61000-65096 udp/53,61000-65096

osdns()
{
	if not yes "$ALLOW_MASQUERADED_OSDNS"
	then
		local save_masq="$MASQUERADING"
		MASQUERADING=""
	fi

	outgoing_tcpudp_only sdns "$1" 53 OSDNS_SERVERS $2 53

	if not yes "$ALLOW_MASQUERADED_OSDNS"
	then
		MASQUERADING="$save_masq"
	fi
}

##############################################################################
# Incoming SMTP
#
# Note: If this is a bastion host, run smap and permit all hosts to connect.
# Otherwise, run smap and only permit connections from the bastion host.
#
# Open: tcp/25

ismtp()
{
	incoming_tcp_any smtp "$1" 25 SMTP_CLIENTS $2
}

##############################################################################
# Outgoing SMTP
#
# Note: If this host is a bastion, permit connections to all hosts, otherwise
# only permit connections to the bastion host.
#
# Open: tcp(ack)/1024-4999,61000-65096

osmtp()
{
	outgoing_tcp_any smtp "$1" 25 SMTP_SERVERS $2
}

##############################################################################
# Incoming POP
#
# Note: This is an extremely bad idea since real user names and passwords
# and private mail will be transmitted over the net in plaintext. Use
# SSL-POP instead.
#
# Open: tcp/109-110

ipop()
{
	incoming_tcp_any pop "$1" 109:110 POP_CLIENTS $2
}

##############################################################################
# Outgoing POP
#
# Note: This is an extremely bad idea when the user name and password or
# people's private mail are too sensitive to be transmitted over the net in
# plaintext. Use $EVIL_POP_SERVERS to deny such uses while allowing less
# sensitive POP access. Use SSL-POP instead.
#
# Open: tcp(ack)/1024-4999,61000-65096

opop()
{
	outgoing_tcp_exclusive pop "$1" 109:110 POP_SERVERS EVIL_POP_SERVERS $2
}

##############################################################################
# Incoming IMAP
#
# Note: This is an extremely bad idea if any external IMAP clients or internal
# IMAP servers don't support and use the "AUTHENTICATE" command instead of the
# "LOGIN" command since user names, passwords and people's private mail will
# be transmitted over the net in plaintext. Use SSL-IMAP instead.
#
# Open: tcp/143

iimap()
{
	incoming_tcp_any imap "$1" 143 IMAP_CLIENTS $2
}

##############################################################################
# Outgoing IMAP
#
# Note: This is an extremely bad idea if any internal IMAP clients or external
# IMAP servers don't support and use the "AUTHENTICATE" command instead of the
# "LOGIN" command since user names, passwords and people's private mail will
# be transmitted over the net in plaintext. Use $EVIL_IMAP_SERVERS to deny
# such uses while allowing secure IMAP access. Use SSL-IMAP instead.
#
# Open: tcp(ack)/1024-4999,61000-65096

oimap()
{
	outgoing_tcp_exclusive imap "$1" 143 IMAP_SERVERS EVIL_IMAP_SERVERS $2
}

##############################################################################
# Incoming LDAP
#
# Note: Don't allow this across a firewall if your ldap server contains
# information that the world at large does not need to see. This should
# probably only be used for public key servers. Otherwise, use SSL-LDAP.
#
# Open: tcp/389

ildap()
{
	incoming_tcp_any ldap "$1" 389 SLDAP_CLIENTS $2
}

##############################################################################
# Outgoing LDAP
#
# Open: tcp(ack)/1024-4999,61000-65096

oldap()
{
	outgoing_tcp_any ldap "$1" 389 SLDAP_SERVERS $2
}

##############################################################################
# Incoming SSL-POP
#
# Open: tcp/995

ispop()
{
	incoming_tcp_any spop "$1" 995 SPOP_CLIENTS $2
}

##############################################################################
# Outgoing SSL-POP
#
# Open: tcp(ack)/1024-4999,61000-65096

ospop()
{
	outgoing_tcp_any spop "$1" 995 SPOP_SERVERS $2
}

##############################################################################
# Incoming SSL-IMAP
#
# Open: tcp/993

isimap()
{
	incoming_tcp_any simap "$1" 993 SIMAP_CLIENTS $2
}

##############################################################################
# Outgoing SSL-IMAP
#
# Open: tcp(ack)/1024-4999,61000-65096

osimap()
{
	outgoing_tcp_any simap "$1" 993 SIMAP_SERVERS $2
}

##############################################################################
# Incoming SSL-LDAP
#
# Open: tcp/636

isldap()
{
	incoming_tcp_any sldap "$1" 636 SLDAP_CLIENTS $2
}

##############################################################################
# Outgoing SSL-LDAP
#
# Open: tcp(ack)/1024-4999,61000-65096

osldap()
{
	outgoing_tcp_any sldap "$1" 636 SLDAP_SERVERS $2
}

##############################################################################
# Incoming SSH1
#
# Note: Permit this rather than telnet or ftp. You can restrict this to
# specific, trusted hosts.
#
# Open: tcp/22

issh1()
{
	incoming_tcp_any ssh1 "$1" 22 SSH1_CLIENTS $2 $SSH1_PORTS
}

##############################################################################
# Outgoing SSH1
#
# Note: Permit this rather than telnet or ftp. You can restrict this to
# specific, trusted hosts.
#
# Open: tcp(ack)/513-1023,61000-65096

ossh1()
{
	outgoing_tcp_any ssh1 "$1" 22 SSH1_SERVERS $2 $SSH1_PORTS
}

##############################################################################
# Incoming SSH2/LSH
#
# Note: Permit this rather than telnet or ftp. You can restrict this to
# specific, trusted hosts.
#
# Open: tcp/22

issh2()
{
	incoming_tcp_any ssh2 "$1" 22 SSH2_CLIENTS $2
}

##############################################################################
# Outgoing SSH2/LSH
#
# Note: Permit this rather than telnet or ftp. You can restrict this to
# specific, trusted hosts.
#
# Open: tcp(ack)/1024-4999,61000-65096

ossh2()
{
	outgoing_tcp_any ssh2 "$1" 22 SSH2_SERVERS $2
}

##############################################################################
# Incoming FTP
#
# Note: This is an extremely bad idea if this host is are running a
# non-anonymous FTP server since real user names, passwords and private
# files will be transmitted over the net in plaintext. Use rsync over ssh
# instead. This should only be used on a bastion host running an anonymous
# FTP server.
#
# Open: tcp/21

iftp()
{
	incoming_tcp_any ftp "$1" 21 FTP_CLIENTS $2
}

##############################################################################
# Incoming Normal FTP
#
# Note: This is an extremely bad idea if this host is are running a
# non-anonymous FTP server since real user names, passwords and private
# files will be transmitted over the net in plaintext. Use rsync over ssh
# instead. This should only be used on a bastion host running an anonymous
# FTP server.
#
# Open: tcp/21 tcp(ack)/1024-4999,61000-65096

inftp()
{
	local targets="$1" index=$2

	chains inftp $index

	iftp "$targets" $index
	ipchains -A oinftp$index -j oiftp$index
	ipchains -A iinftp$index -j iiftp$index

	default_to_any FTP_CLIENTS $index

	for client in `combine FTP_CLIENTS $index`
	do
		for target in $targets
		do
			tcp oinftp$index iinftp$index $target 20 $client 1024:
		done
	done
}

##############################################################################
# Incoming Passive FTP
#
# Note: This is an extremely bad idea if this host is are running a
# non-anonymous FTP server since real user names, passwords and private
# files will be transmitted over the net in plaintext. It is also an
# extremely bad idea since it may allow any host to connect to any tcp port
# above 1023. Use rsync over ssh instead. This should only be used on a
# bastion host running an anonymous FTP server.
#
# Open: tcp/21,1024-4999

ipftp()
{
	local targets="$1" index=$2

	chains ipftp $index

	iftp "$targets" $index
	ipchains -A iipftp$index -j iiftp$index
	ipchains -A oipftp$index -j oiftp$index

	default_to_any FTP_CLIENTS $index

	for client in `combine FTP_CLIENTS $index`
	do
		for target in $targets
		do
			tcp iipftp$index oipftp$index $client 1024: $target $normal_ports
		done
	done
}

##############################################################################
# Outgoing FTP
#
# Note: This is an extremely bad idea if used for non-anonymous FTP access
# since real user names, passwords and private files will be transmitted
# over the net in plaintext. Use $EVIL_FTP_SERVERS to deny such uses and
# require that users use rsync over ssh instead.
#
# Open: tcp(ack)/1024-4999,61000-65096

oftp()
{
	local targets="$1" index=$2

	chains oftp $index

	# Deny FTP connections to specific external hosts where the user name and
	# password required to connect or the contents of the files is too sensitive
	# to be transmitted over the net in plaintext

	for server in `combine EVIL_FTP_SERVERS $index`
	do
		for target in $targets
		do
			tcpmno $index ooftp$index ioftp$index $target $normal_ports $server 21 $BLOCKOUT $BLOCKIN
		done
	done

	default_to_any FTP_SERVERS $index

	for server in `combine FTP_SERVERS $index`
	do
		for target in $targets
		do
		tcpm $index ooftp$index ioftp$index $target $normal_ports $server 21
		done
	done
}

##############################################################################
# Outgoing Normal FTP
#
# Note: This is an extremely bad idea if used for non-anonymous FTP access
# since real user names, passwords and private files will be transmitted
# over the net in plaintext. Use $EVIL_FTP_SERVERS to deny such uses and
# require that users use rsync over ssh instead. It is also an extremely bad
# idea since it allows any host to connect to any tcp port above 1023.
# Instead, restrict connections to a bastion host running an FTP proxy.
#
# Open: tcp/1024-4999 tcp(ack)/1024-4999,61000-65096

onftp()
{
	local targets="$1" index=$2

	chains onftp $index

	# Include common outgoing FTP connection rules

	oftp "$targets" $index
	ipchains -A ionftp$index -j ioftp$index
	ipchains -A oonftp$index -j ooftp$index

	# Deny FTP connections to specific external hosts where the user name and
	# password required to connect or the contents of the files is too sensitive
	# to be transmitted over the net in plaintext

	for server in `combine EVIL_FTP_SERVERS $index`
	do
		for target in $targets
		do
			tcpno ionftp$index oonftp$index $server 20 $target $normal_ports $BLOCKIN $BLOCKOUT
		done
	done

	default_to_any FTP_SERVERS $index

	for server in `combine FTP_SERVERS $index`
	do
		for target in $targets
		do
			tcp ionftp$index oonftp$index $server 20 $target $normal_ports
		done
	done
}

##############################################################################
# Outgoing Passive FTP
#
# Note: This is an extremely bad idea if used for non-anonymous FTP access
# since real user names, passwords and private files will be transmitted
# over the net in plaintext. Use $EVIL_FTP_SERVERS to deny such uses and
# require that users use rsync over ssh instead.
#
# Open: tcp(ack)/1024-4999,61000-65096

opftp()
{
	local targets="$1" index=$2

	chains opftp $index

	# Include common outgoing FTP connection rules

	oftp "$targets" $index
	ipchains -A oopftp$index -j ooftp$index
	ipchains -A iopftp$index -j ioftp$index

	# Deny FTP connections to specific external hosts where the user name and
	# password required to connect or the contents of the files is too sensitive
	# to be transmitted over the net in plaintext

	for server in `combine EVIL_FTP_SERVERS $index`
	do
		for target in $targets
		do
			tcpmno $index oopftp$index iopftp$index $target $normal_ports $server 1024: $BLOCKOUT $BLOCKIN
		done
	done

	default_to_any FTP_SERVERS $index

	for server in `combine FTP_SERVERS $index`
	do
		for target in $targets
		do
			tcpm $index oopftp$index iopftp$index $target $normal_ports $server 1024:
		done
	done
}

##############################################################################
# Incoming TELNET
#
# Note: This is an extremely bad idea since real user names, passwords and
# login sessions will be transmitted over the net in plaintext. Require that
# users use ssh instead.
#
# Open: tcp/23

iteln()
{
	incoming_tcp_only teln "$1" 23 TELNET_CLIENTS $2
}

##############################################################################
# Outgoing TELNET
#
# Note: This is an extremely bad idea since real user names, passwords and
# login sessions will be transmitted over the net in plaintext. Require that
# users use ssh instead.
#
# Open: tcp(ack)/1024-4999,61000-65096

oteln()
{
	outgoing_tcp_exclusive teln "$1" 23 TELNET_SERVERS EVIL_TELNET_SERVERS $2
}

##############################################################################
# Incoming HTTP
#
# Note: Only run public HTTP servers on bastion hosts.
#
# Open: tcp/80

ihttp()
{
	incoming_tcp_byport http "$1" INTERNAL_HTTP_PORTS $2
}

##############################################################################
# Outgoing HTTP
#
# Note: You can limit HTTP connections to certain ports on external hosts
# with $EXTERNAL_HTTP_PORTS. By default, this is "80 81 800 8000 8080 8088".
# It is safe to make $EXTERNAL_HTTP_PORTS empty, permitting local clients to
# connect to any port (potentially an HTTP server) on any host and receive
# the responses but you'd be better off using a caching HTTP proxy on a
# bastion host anyway.
#
# Open: tcp(ack)/1024-4999,61000-65096

ohttp()
{
	outgoing_tcp_byport http "$1" EXTERNAL_HTTP_PORTS $2
}

##############################################################################
# Incoming HTTPS
#
# Note: Only run public HTTPS servers on bastion hosts.
#
# Open: tcp/443

ihttps()
{
	incoming_tcp_byport https "$1" INTERNAL_HTTPS_PORTS $2
}

##############################################################################
# Outgoing HTTPS
#
# Note: You can limit HTTPS connections to certain ports on external hosts
# with $EXTERNAL_HTTPS_PORTS. By default, this is "443". It is safe to make
# $EXTERNAL_HTTPS_PORTS empty, permitting local clients to connect to any
# port (potentially an HTTPS server) on any host and receive the responses
# but you'd be better off using a caching HTTPS proxy on a bastion host anyway.
#
# Open: tcp(ack)/1024-4999,61000-65096

ohttps()
{
	outgoing_tcp_byport https "$1" EXTERNAL_HTTPS_PORTS $2
}

##############################################################################
# Incoming HTTP PROXY
#
# Note: You need this if your web proxy is internal and it has external
# clients (don't do that), or if this host is a bastion and the interface
# being filtered connects to the internal network.
#
# Open: tcp/8080

iproxy()
{
	local targets="$1" index=$2

	chains iproxy $index

	for client in `combine INTERNAL_HTTP_PROXY_CLIENTS $index`
	do
		for target in $targets
		do
			for port in $INTERNAL_HTTP_PROXY_PORTS
			do
				tcp iiproxy$index oiproxy$index $client 1024: $target $port
			done
		done
	done
}

##############################################################################
# Outgoing HTTP PROXY
#
# Note: You need this if your web proxy is running on a bastion host.
#
# Open: tcp(ack)/1024-4999,61000-65096

oproxy()
{
	local targets="$1" index=$2

	chains oproxy $index

	for server in `combine EXTERNAL_HTTP_PROXY_SERVERS $index`
	do
		for target in $targets
		do
			for port in $EXTERNAL_HTTP_PROXY_PORTS
			do
				tcpm $index ooproxy$index ioproxy$index $target $normal_ports $server $port
			done
		done
	done
}

##############################################################################
# Incoming SQUID
#
# Open: tcp/3128,3130,4287

isquid()
{
	incoming_tcp_any squid "$1" 3128 SQUID_CLIENTS $2
	incoming_tcp_only squid "$1" 3130 ICP_CLIENTS $2
	incoming_tcp_only squid "$1" 4287 HTCP_CLIENTS $2
}

##############################################################################
# Outgoing SQUID
#
# Open: tcp(ack)/1024-4999,61000-65096 udp/1024-4999,61000-65096

osquid()
{
	outgoing_tcp_only squid "$1" 3128 SQUID_SERVERS $2
	outgoing_tcp_only squid "$1" 3130 ICP_SERVERS $2
	outgoing_tcp_only squid "$1" 4287 HTCP_SERVERS $2
	outgoing_udp_only squid "$1" 3131 NLANR_REGISTRAR $2
}

##############################################################################
# Incoming NNTP
#
# Note: Don't run an NNTP server on a bastion host. Run it on an internal
# host and only permit connections from trusted external NNTP servers.
#
# Open: tcp/119

inntp()
{
	incoming_tcp_only nntp "$1" 119 NNTP_CLIENTS $2
}

##############################################################################
# Outgoing NNTP
#
# Note: Only permit NNTP connections to trusted external NNTP servers.
#
# Open: tcp(ack)/1024-4999,61000-65096

onntp()
{
	outgoing_tcp_only nntp "$1" 119 NNTP_SERVERS $2
}

##############################################################################
# Incoming RSYNC
#
# Note: Don't allow this over a firewall. Use rsync over ssh instead.
#
# Open: tcp/873

irsync()
{
	incoming_tcp_only rsync "$1" 873 RSYNC_CLIENTS $2
}

##############################################################################
# Outgoing RSYNC
#
# Note: Don't allow this over a firewall. Use rsync over ssh instead.
#
# Open: tcp(ack)/1024-4999,61000-65096

orsync()
{
	outgoing_tcp_only rsync "$1" 873 RSYNC_SERVERS $2
}

##############################################################################
# Incoming CVS
#
# Note: Don't allow this over a firewall. Use rsync over ssh instead.
#
# Open: tcp/2401

icvs()
{
	incoming_tcp_only cvs "$1" 2401 CVS_CLIENTS $2
}

##############################################################################
# Outgoing CVS
#
# Note: Don't allow this over a firewall. Use rsync over ssh instead.
#
# Open: tcp(ack)/1024-4999,61000-65096

ocvs()
{
	outgoing_tcp_only cvs "$1" 2401 CVS_SERVERS $2
}

##############################################################################
# Incoming GNATS
#
# Open: tcp/1529

ignats()
{
	incoming_tcp_only gnats "$1" 1529 GNATS_CLIENTS $2
}

##############################################################################
# Outgoing GNATS
#
# Open: tcp(ack)/1024-4999,61000-65096

ognats()
{
	outgoing_tcp_only gnats "$1" 1529 GNATS_SERVERS $2
}

##############################################################################
# Incoming MYSQL
#
# Open: tcp/3306

imysql()
{
	incoming_tcp_only mysql "$1" 3306 MYSQL_CLIENTS $2
}

##############################################################################
# Outgoing MYSQL
#
# Open: tcp(ack)/1024-4999,61000-65096

omysql()
{
	outgoing_tcp_only mysql "$1" 3306 MYSQL_SERVERS $2
}

##############################################################################
# Incoming SMB
#
# Note: This is probably a bad idea over a firewall.
#
# Open: tcp/139 udp/137-138

ismb()
{
	local targets="$1" index=$2

	chains ismb $index

	for client in `combine SMB_CLIENTS $index`
	do
		for target in $targets
		do
			udp iismb$index oismb$index $client 137 $target 137
			udp iismb$index oismb$index $client 138 $target 138
			tcp iismb$index oismb$index $client 1024: $target 139
		done
	done
}

##############################################################################
# Outgoing SMB
#
# Note: This is probably a bad idea over a firewall.
#
# Open: tcp(ack)/1024-4999,61000-65096

osmb()
{
	local targets="$1" index=$2

	chains osmb $index

	for server in `combine SMB_SERVERS $index`
	do
		for target in $targets
		do
			udpm $index oosmb$index iosmb$index $target 137 $server 137
			udpm $index oosmb$index iosmb$index $target 138 $server 138
			tcpm $index oosmb$index iosmb$index $target $normal_ports $server 139
		done
	done
}

##############################################################################
# Incoming IRC
#
# Note: If this host run an internal IRC server, make sure it can't
# communicate with external IRC servers or it will attach itself to the IRC
# spanning tree through which this host can be attacked. Also, DCC
# connections between IRC clients isn't supported because it's a very bad
# idea across a firewall.
#
# Open: tcp/6667

iirc()
{
	incoming_tcp_any irc "$1" 6667 IRC_CLIENTS $2
}

##############################################################################
# Outgoing IRC
#
# Note: IRC clients can be dangerous and you shouldn't allow IRC across a
# firewall. It's best to run them on a victim host. Also, DCC connections
# between IRC clients isn't supported because it's a very bad idea across a
# firewall.
#
# Open: tcp(ack)/1024-4999,61000-65096

oirc()
{
	outgoing_tcp_any irc "$1" 6667 IRC_SERVERS $2
}

##############################################################################
# Incoming ICQ
#
# Note: Don't allow this through a firewall. ICQ is dangerous. Run ICQ
# servers on an external victim host.
#
# Open: tcp/2000-4000 udp/4000

iicq()
{
	local targets="$1" index=$2

	chains iicq $index

	default_to_any ICQ_CLIENTS $index

	for client in `combine ICQ_CLIENTS $index`
	do
		for target in $targets
		do
			tcp iiicq$index oiicq$index $client 1024: $target 2000:4000
			udp iiicq$index oiicq$index $client 1024: $target 4000
		done
	done
}

##############################################################################
# Outgoing ICQ
#
# Note: Don't allow this through a firewall. ICQ is dangerous. Run ICQ
# clients on an external victim host.
#
# Open: tcp(ack)/1024-4999,61000-65096 udp/1024-4999,61000-65096

oicq()
{
	local targets="$1" index=$2

	chains oicq $index

	default_to_any ICQ_SERVERS $index

	for server in `combine ICQ_SERVERS $index`
	do
		for target in $targets
		do
			tcpm $index ooicq$index ioicq$index $target $normal_ports $server 2000:4000
			udpm $index ooicq$index ioicq$index $target $normal_ports $server 4000
		done
	done
}

##############################################################################
# Incoming RealAudio/QuickTime
#
# Note: Don't allow this through a firewall. You probably don't need it. It's
# a bad idea since it leaves all the udp ports open.
#
# Open: tcp/554,7070-7071 udp/1024-4999

ireal()
{
	local targets="$1" index=$2

	chains ireal $index

	default_to_any REALAUDIO_CLIENTS $index

	for client in `combine REALAUDIO_CLIENTS $index`
	do
		for target in $targets
		do
			tcp iireal$index oireal$index $client 1024: $target 554
			tcp iireal$index oireal$index $client 1024: $target 7070:7071
			udp iireal$index oireal$index $client 6970:6999 $target $normal_ports
		done
	done
}

##############################################################################
# Outgoing RealAudio/QuickTime
#
# Note: You may need to load the raudio masquerading module (see $MASQ_MODULES).
# This is a bad idea since it leaves many udp ports open.
#
# Open: tcp(ack)/1024-4999,61000-65096 udp/6970-6999,61000,65096

oreal()
{
	local targets="$1" index=$2

	chains oreal $index

	default_to_any REALAUDIO_SERVERS $index

	for server in `combine REALAUDIO_SERVERS $index`
	do
		for target in $targets
		do
			tcpm $index ooreal$index ioreal$index $target $normal_ports $server 554
			tcpm $index ooreal$index ioreal$index $target $normal_ports $server 7070:7071
			udpm $index ooreal$index ioreal$index $target 6970:6999 $server 1024:
		done
	done
}

##############################################################################
# Incoming NTP
#
# Note: Only permit this if this host is running a public NTP server. If
# it's an internal host, only permit connections from a proxy DNS server
# running on a bastion host.
#
# Open: udp/123

intp()
{
	local targets="$1" index=$2

	chains intp $index

	default_to_any NTP_CLIENTS $index

	incoming_udp_any ntp "$targets" 123 NTP_CLIENTS $index 123

	for client in `combine NTP_CLIENTS $index`
	do
		for target in $targets
		do
			udp iintp$index ointp$index $client 1024: $target 123
		done
	done
}

##############################################################################
# Outgoing NTP
#
# Note: Permit this if you synchronize your network from external NTP
# servers. Restrict NTP connections to only those NTP servers.
#
# Open: udp/123,1024-4999,61000-65096

ontp()
{
	local targets="$1" index=$2

	chains ontp $index

	outgoing_udp_only ntp "$targets" 123 NTP_SERVERS $index 123

	for server in `combine NTP_SERVERS $index`
	do
		for target in $targets
		do
			udpm $index oontp$index iontp$index $target $normal_ports $server 123
		done
	done
}

##############################################################################
# Incoming GOPHER
#
# Note: Don't use this. It's for GOPHER servers. I'm just being silly.
# If you must run a public GOPHER server, run it on a bastion host.
#
# Open: tcp/70

igoph()
{
	incoming_tcp_byport goph "$1" INTERNAL_GOPHER_PORTS $2
}

##############################################################################
# Outgoing GOPHER
#
# Note: Don't use this. Use an HTTP-GOPHER gateway.
#
# Open: tcp(ack)/1024-4999,61000-65096

ogoph()
{
	outgoing_tcp_byport goph "$1" EXTERNAL_GOPHER_PORTS $2
}

##############################################################################
# Incoming WAIS
#
# Note: Don't use this. It's for WAIS servers. I'm just being silly.
# If you must run a public WAIS server, run it on a bastion host.
#
# Open: tcp/210

iwais()
{
	incoming_tcp_byport wais "$1" INTERNAL_WAIS_PORTS $2
}

##############################################################################
# Outgoing WAIS
#
# Note: Don't use this. Use an HTTP-WAIS gateway instead.
#
# Open: tcp(ack)/1024-4999,61000-65096

owais()
{
	outgoing_tcp_byport wais "$1" EXTERNAL_WAIS_PORTS $2
}

##############################################################################
# Outgoing ARCHIE
#
# Note: Don't use this. Use an HTTP-ARCHIE gateway instead. If you must
# permit this, restrict it to the well known ARCHIE servers.
#
# Open: udp/1024-4999,61000-65096

oarch()
{
	outgoing_udp_only arch "$1" 1525 ARCHIE_SERVERS $2
}

##############################################################################
# Incoming FINGER
#
# Note: Only run a public (secure) FINGER server on a bastion host.
#
# Open: tcp/79

ifing()
{
	incoming_tcp_any fing "$1" 79 FINGER_CLIENTS $2
}

##############################################################################
# Outgoing FINGER
#
# Note: Make sure this host's finger clients can handle non-printable
# characters in finger output otherwise programmable terminals may get
# themselves reprogrammed.
#
# Open: tcp(ack)/1024-4999,61000-65096

ofing()
{
	outgoing_tcp_any fing "$1" 79 FINGER_SERVERS $2
}

##############################################################################
# Outgoing WHOIS
#
# Note: Restrict WHOIS connections to the well known WHOIS servers.
# Do not run a WHOIS server.
#
# Open: tcp(ack)/1024-4999,61000-65096

owhois()
{
	outgoing_tcp_any whois "$1" 43 WHOIS_SERVERS $2
}

##############################################################################
# Incoming AUTH
#
# Note: Permitting this speeds up outgoing SMTP and FTP communications since
# some SMTP and FTP servers attempt to identify their clients. However,
# handing out local user names to anonymous FTP servers is not necessarily a
# good idea. See man identd for details.
#
# Open: tcp/113

iauth()
{
	incoming_tcp_any auth "$1" 113 AUTH_CLIENTS $2
}

##############################################################################
# Outgoing AUTH
#
# Note: It is safe to permit this except that it may be used by local
# attackers to gain information about external hosts.
#
# Open: tcp(ack)/1024-4999,61000-65096

oauth()
{
	outgoing_tcp_any auth "$1" 113 AUTH_SERVERS $2
}

##############################################################################
# Incoming NOTES
#
# Note: You only need this if external Lotus Notes servers connect to
# internal Lotus Notes servers.
#
# Open: tcp/1352

inotes()
{
	incoming_tcp_any notes "$1" 1352 NOTES_CLIENTS $2
}

##############################################################################
# Outgoing NOTES
#
# Note: You only need this if internal Lotus Notes servers connect to
# external Lotus Notes servers.
#
# Open: tcp(ack)/1024-4999,61000-65096

onotes()
{
	outgoing_tcp_any notes "$1" 1352 NOTES_SERVERS $2
}

##############################################################################
# Client DIALPAD
#
# Note: You only need this if you use the internet telephony service provided
# by www.dialpad.com. Check http://www.dialpad.com/support/helpsys.html#firewall
# for updates to the list of dialpad networks used below.
#
# Note: If your dialpad software runs on an mswin host (almost certainly)
# and it's in a masqueraded network, you'll need to port forward
# udp/51200:51201 and tcp/51210 to that host (see $PORTFW).
#
# Open: tcp(ack)/1024-4999,61000-65096, tcp/51210, udp/51200-51201

cdial()
{
	incoming1_udp_any cdial "$1" 51200:51201 DIALPAD_SERVERS $2
	incoming1_tcp_any cdial "$1" 51210 DIALPAD_SERVERS $2
	outgoing1_tcp_any cdial "$1" 7175 DIALPAD_SERVERS $2
}

##############################################################################
# Client WEBPHONE
#
# Note: You only need this if you use the internet telephony service provided
# by the webphone software (www.webphone.com).
#
# Note: If your webphone software runs on an mswin host (almost certainly) and
# it's in a masqueraded network, you probably need to port forward tcp/21845
# and udp/21845 to that host.
#
# Open: tcp(ack)/1024-499,61000-65096, tcp/21845, udp/21845

cwbfn()
{
	incoming1_tcp_only cwbfn "$1" 21845 WEBPHONE_PEERS $2
	outgoing1_tcp_only cwbfn "$1" 21845:21847 WEBPHONE_PEERS $2
	outgoing1_udp_only cwbfn "$1" 21845 WEBPHONE_PEERS $2 21845
}

##############################################################################
# Client NET2PHONE
#
# Note: You only need this if you use the internet telephony service provided
# by www.net2phone.com. There may be other sites that provide this service
# using the same protocol.
#
# Note: If your net2phone client runs on an mswin host (almost certainly) and
# it's in a masqueraded network, you probably need to port forward the ports
# specified in $NET2PHONE_UDP_PORT and $NET2PHONE_TCP_PORT to that host
# (see $PORTFW).
#
# Open: tcp(ack)/1024-4999,61000-65096, tcp/6802, udp/6801-6802

cnt2fn()
{
	outgoing1_udp_only cnt2fn "$1" 6801 NET2PHONE_PEERS $2 6801
	outgoing1_udp_only cnt2fn "$1" NET2PHONE_UDP_PORT NET2PHONE_PEERS $2 NET2PHONE_UDP_PORT
	outgoing1_tcp_only cnt2fn "$1" NET2PHONE_TCP_PORT NET2PHONE_PEERS $2
	incoming1_tcp_only cnt2fn "$1" NET2PHONE_TCP_PORT NET2PHONE_PEERS $2
}

##############################################################################
# Client HOTTELEPHONE/WEB2CALL
#
# Note: You only need this if you use the internet telephony service provided
# by www.hottelephone.com and www.web2call.com. There may be other sites that
# provide this service using the same protocol.
#
# Note: If your hottelephone/web2call client runs on an mswin host (almost
# certainly) and it's in a masqueraded network, you probably need to port
# forward tcp/1720, udp/1717-1719 and the udp ports specified in $RTP_PORTS
# to that host (see $PORTRANGEFW) and load the h323 masquerading module (see
# $MASQ_MODULES).
#
# Note: Don't use this. It leaves far too many ports open. $RTP_PORTS
# contains a port range starting at 4000 that contains either 400, 800,
# 1200 or 1600 ports. So there will be at least 400 and up to 1600 ports
# open! If you must use this service, only allow in on a victim host.
#
# Open: tcp(ack)/1024-4999,61000-65096, tcp/1720, udp/1717-1719,4000-5600

chotel()
{
	incoming1_tcp_only chotel "$1" 1720 HOTTELEPHONE_PEERS $2
	outgoing1_tcp_only chotel "$1" 1720 HOTTELEPHONE_PEERS $2
	incoming1_udp_only chotel "$1" 1717:1719 HOTTELEPHONE_PEERS $2 1717:1719
	incoming1_udp_only chotel "$1" $RTP_PORTS HOTTELEPHONE_PEERS $2 $RTP_PORTS
}

##############################################################################
# Incoming NETMEETING
#
# Note: Don't use this except on a victim host. This application is extremely
# dangerous in that it can allow outsiders to exert control over your pc!!!
#
# Note: If you allow the audio/video conferencing features of netmeeting, it
# will also require all unprivileged tcp and udp ports be open to incoming
# connections!
#
# Note: If the host running netmeeting is in a masqueraded network and you
# allow audio/video conferencing, you probably need to port forward all
# unprivileged tcp and udp ports to the mswin host running netmeeting
# (see $PORTRANGEFW) and load the h323 masquerading module (see $MASQ_MODULES).
# Otherwise (when masquerading), only tcp/522,1503 need to be port forwarded
# to the netmeeting host and the h323 module does not need to be loaded.
#
# Note: You might also need to allow incoming LDAP.
#
# Open (no A/V):   tcp/522,1503
# Open (with A/V): tcp/1024-65535, udp/1024-65535

intmt()
{
	if yes "$INCOMING_NETMEETING_AUDIO_VISUAL_CONFERENCING"
	then
		incoming_tcp_only ntmt "$1" 522 NETMEETING_CLIENTS $2
		incoming_tcp_only ntmt "$1" 1024: NETMEETING_CLIENTS $2
		incoming_udp_only ntmt "$1" 1024: NETMEETING_CLIENTS $2
	else
		incoming_tcp_only ntmt "$1" 522 NETMEETING_CLIENTS $2
		incoming_tcp_only ntmt "$1" 1503 NETMEETING_CLIENTS $2
	fi
}

##############################################################################
# Outgoing NETMEETING
#
# Note: Don't use this except on a victim host. This application is extremely
# dangerous in that it can allow outsiders to exert control over your pc!!!
#
# Note: If you allow the audio/video conferencing features of netmeeting, it
# will also require all unprivileged udp ports be open to incoming packets!
#
# Note: If the host running netmeeting is in a masqueraded network and you
# allow audio/video conferencing, you probably need to port forward all
# unprivileged udp ports to the mswin host running netmeeting (see
# $PORTRANGEFW) and load the h323 masquerading module (see $MASQ_MODULES).
# Otherwise no ports need to be port forwarded and the h323 module does not
# need to be loaded.
#
# Note: You might also need to allow outgoing LDAP.
#
# Open (no A/V):   tcp(ack)/1024-4999,61000-65096
# Open (with A/V): tcp(ack)/1024-4999,61000-65096, udp/1024-4999,61000-65096

ontmt()
{
	if yes "$OUTGOING_NETMEETING_AUDIO_VISUAL_CONFERENCING"
	then
		outgoing_tcp_only ntmt "$1" 522 NETMEETING_SERVERS $2
		outgoing_tcp_only ntmt "$1" 1024: NETMEETING_SERVERS $2
		outgoing_udp_only ntmt "$1" 1024: NETMEETING_SERVERS $2
	else
		outgoing_tcp_only ntmt "$1" 522 NETMEETING_SERVERS $2
		outgoing_tcp_only ntmt "$1" 1503 NETMEETING_SERVERS $2
	fi
}

##############################################################################
# Incoming SYSLOG
#
# Note: Only use this to collect syslog messages from a bastion host.
#
# Open: udp/514

ilog()
{
	local targets="$1" index=$2

	chains ilog $index

	for client in `combine SYSLOG_CLIENTS $index`
	do
		for target in $targets
		do
			udp1 iilog$index $client : $target 514
		done
	done
}

##############################################################################
# Outgoing SYSLOG
#
# Note: Only use this to send syslog messages from the bastion host to an
# internal host.
#
# Open: none

olog()
{
	local targets="$1" index=$2

	chains olog $index

	for server in `combine SYSLOG_SERVERS $index`
	do
		for target in $targets
		do
			udp1 oolog$index $target : $server 514
		done
	done
}

##############################################################################
# DHCP Server
#
# Note: You probably don't need this.
#
# Open: udp/67

sdhcp()
{
	local targets="$1" index=$2

	chains sdhcp $index

	default_to_any DHCP_CLIENTS $index

	for client in `combine DHCP_CLIENTS $index`
	do
		for target in $targets
		do
			udp osdhcp$index isdhcp$index $target 67 $client 68
			udp1 osdhcp$index $target 67 $broadcast_dst 68
			udp1 isdhcp$index $broadcast_src 68 $target 67
		done
	done

	# Outgoing address update
	udp1 osdhcp$index $broadcast_src 67 $broadcast_dst 68
	udp1 isdhcp$index $broadcast_src 68 $broadcast_dst 67
}

##############################################################################
# DHCP Client
#
# Note: Only allow DHCP traffic to/from trusted external DHCP servers.
#
# Open: udp/68

cdhcp()
{
	local targets="$1" index=$2

	chains cdhcp $index

	for server in `combine DHCP_SERVERS $index`
	do
		for target in $targets
		do
			udp icdhcp$index ocdhcp$index $server 67 $any 68
			udp1 icdhcp$index $server 67 $broadcast_dst 68
			udp1 ocdhcp$index $broadcast_src 68 $server 67
		done
	done

	if [ -n "`combine DHCP_SERVERS $index`" ]
	then
		# Incoming address update
		udp1 icdhcp$index $broadcast_src 67 $broadcast_dst 68
		udp1 ocdhcp$index $broadcast_src 68 $broadcast_dst 67
	fi
}

##############################################################################
# Incoming SNMP
#
# Note: You probably don't want to permit this across a firewall.
# If you do, only allow connections from trusted SNMP management stations.
#
# Open: udp/161

isnmp()
{
	incoming_udp_only snmp "$1" 161 SNMP_CLIENTS $2
}

##############################################################################
# Outgoing SNMP
#
# Note: You probably don't want to permit this across a firewall.
# If you do, only allow connections to trusted SNMP network devices.
#
# Open: udp/1024-4999,61000-65096

osnmp()
{
	outgoing_udp_only snmp "$1" 161 SNMP_SERVERS $2
}

##############################################################################
# Incoming SNMP TRAP
#
# Note: You probably don't want to permit this across a firewall.
# If you do, only allow connections from trusted SNMP management stations.
#
# Open: 162

isnmpt()
{
	incoming_udp_only snmpt "$1" 162 SNMP_TRAP_CLIENTS $2
}

##############################################################################
# Outgoing SNMP TRAP
#
# Note: You probably don't want to permit this across a firewall.
# If you do, only allow connections to trusted SNMP network devices.
#
# Open: udp/1024-4999,61000-65096

osnmpt()
{
	outgoing_udp_only snmpt "$1" 162 SNMP_TRAP_SERVERS $2
}

##############################################################################
# Incoming BGP
#
# Note: You probably don't want to permit this across a firewall.
# If you do, only allow connections from trusted BGP peers.
#
# Open: tcp/179

ibgp()
{
	incoming_tcp_only bgp "$1" 179 BGP_CLIENTS $2
}

##############################################################################
# Outgoing BGP
#
# Note: You probably don't want to permit this across a firewall.
# If you do, only allow connections to trusted BGP peers.
#
# Open: tcp(ack)/1024-4999,61000-65096

obgp()
{
	outgoing_tcp_only bgp "$1" 179 BGP_SERVERS $2
}

##############################################################################
# OSPF
#
# Note: You must have ospf(89) in /etc/protocols.
#
# Open: ospf

ospf()
{
	local targets="$1" index=$2

	if [ -n "$OSPF_PROTOCOL" ]
	then
		chains ospf $index

		for router in `combine OSPF_ROUTERS $index`
		do
			for target in $targets
			do
				other ospf oospf$index iospf$index $target $router
			done
		done
	fi
}

##############################################################################
# Incoming RIP
#
# Note: You probably don't want to permit this across a firewall.
# If you do, only allow connection from trusted routers.
#
# Open: udp/520

irip()
{
	local targets="$1" index=$2

	chains irip $index

	for client in `combine RIP_CLIENTS $index`
	do
		for target in $targets
		do
			# Incoming RIP broadcast from specified host (server)
			udp1 iirip$index $client 520 $target 520
			# Incoming RIP request from specified host (client)
			udp iirip$index oirip$index $client 1024: $target 520
		done
	done
}

##############################################################################
# Outgoing RIP
#
# Note: You probably don't want to permit this across a firewall.
# If you do, only allow connection to trusted routers.
#
# Open: udp/1024-4999,61000-65096

orip()
{
	local targets="$1" index=$2

	chains orip $index

	for server in `combine RIP_SERVERS $index`
	do
		for target in $targets
		do
			# Outgoing RIP broadcast to specified host (server)
			udpm1 $index oorip$index $target 520 $server 520
			# Outgoing RIP request to specified host (client)
			udpm $index oorip$index iorip$index $target $normal_ports $server 520
		done
	done
}

##############################################################################
# Incoming KERBEROS
#
# Open: tcp/88,543-544,749

ikerb()
{
	local targets="$1" index=$2

	chains ikerb $index

	default_to_any KERBEROS_CLIENTS $index

	for client in `combine KERBEROS_CLIENTS $index`
	do
		for target in $targets
		do
			tcp iikerb$index oikerb$index $client 1024: $target 88      # kerberos
			tcp iikerb$index oikerb$index $client 1024: $target 543:544 # klogin/kshell
			tcp iikerb$index oikerb$index $client 1024: $target 749     # kadmin
		done
	done
}

##############################################################################
# Outgoing KERBEROS
#
# Open: tcp(ack)/1024-4999,61000-65096

okerb()
{
	local targets="$1" index=$2

	chains okerb $index

	default_to_any KERBEROS_SERVERS $index

	for server in `combine KERBEROS_SERVERS $index`
	do
		for target in $targets
		do
			tcpm $index ookerb$index iokerb$index $target $normal_ports $server 88      # kerberos
			tcpm $index ookerb$index iokerb$index $target $normal_ports $server 543:544 # klogin/kshell
			tcpm $index ookerb$index iokerb$index $target $normal_ports $server 749     # kadmin
		done
	done
}

##############################################################################
# Incoming PPTP
#
# Note: You must have pptp(47) in /etc/protocols to use this.
# Warning: Some iMplementationS of PPTP are completely insecure, use IPSEC.
#
# Open: tcp/1723 pptp

if [ -n "$PPTP_PROTOCOL" ]
then
	ipptp()
	{
		local targets="$1" index=$2

		chains ipptp $index

		default_to_any PPTP_CLIENTS $index

		for client in `combine PPTP_CLIENTS $index`
		do
			for target in $targets
			do
				tcp iipptp$index oipptp$index $client 1024: $target 1723
				other pptp iipptp$index oipptp$index $client $target
			done
		done
	}
fi

##############################################################################
# Outgoing PPTP
#
# Note: You must have pptp(47) in /etc/protocols to use this.
# Warning: Some iMplementationS of PPTP are completely insecure, use IPSEC.
#
# Open: tcp(ack)/1024-4999,61000-65096 pptp

if [ -n "$PPTP_PROTOCOL" ]
then
	opptp()
	{
		local targets="$1" index=$2

		chains opptp $index

		default_to_any PPTP_SERVERS $index

		for server in `combine PPTP_SERVERS $index`
		do
			for target in $targets
			do
				tcp oopptp$index iopptp$index $target $normal_ports $server 1723
				other pptp oopptp$index iopptp$index $target $server
			done
		done
	}
fi

##############################################################################
# Incoming IPSEC
#
# Note: You must have esp(50) and ah(51) in /etc/protocols to use this.
#
# Open: udp/500 esp ah

if [ -n "$ESP_PROTOCOL" -a -n "$AH_PROTOCOL" ]
then
	iipsec()
	{
		local targets="$1" index=$2

		chains iipsec $index

		default_to_any IPSEC_CLIENTS $index

		for client in `combine IPSEC_CLIENTS $index`
		do
			for target in $targets
			do
				udp iiipsec$index oiipsec$index $client 500 $target 500
				other esp iiipsec$index oiipsec$index $client $target
				other ah iiipsec$index oiipsec$index $client $target
			done
		done
	}
fi

##############################################################################
# Outgoing IPSEC
#
# Note: You must have esp(50) and ah(51) in /etc/protocols to use this.
#
# Open: udp/500 esp ah

oipsec()
{
	local targets="$1" index=$2

	if [ -n "$ESP_PROTOCOL" -a -n "$AH_PROTOCOL" ]
	then
		chains oipsec $index

		default_to_any IPSEC_SERVERS $index

		for server in `combine IPSEC_SERVERS $index`
		do
			for target in $targets
			do
				udp ooipsec$index ioipsec$index $target 500 $client 500
				other esp ooipsec$index ioipsec$index $target $client
				other ah ooipsec$index ioipsec$index $target $client
			done
		done
	fi
}

##############################################################################
# Incoming PING
#
# Note: Only permit incoming pings from external hosts that have a reason to
# be pinging this host (e.g. your ISP).
#
# Open: icmp/echo-request

iping()
{
	local targets="$1" index=$2

	chains iping $index

	for client in `combine PING_CLIENTS $index`
	do
		for target in $targets
		do
			icmp iiping$index $client $target 8 $LOG # echo-request
			icmp oiping$index $target $client 0      # echo-reply
		done
	done
}

##############################################################################
# Outgoing PING
#
# Note: This can be used by local attackers to flood external hosts but it
# is very useful. You can restrict outgoing PING to specific hosts if you
# want.
#
# Open: icmp/echo-reply

oping()
{
	local targets="$1" index=$2

	chains oping $index

	default_to_any PING_SERVERS $index

	for server in `combine PING_SERVERS $index`
	do
		for target in $targets
		do
			icmp ooping$index $target $server 8 # echo-request
			icmp ioping$index $server $target 0 # echo-reply
		done
	done
}

##############################################################################
# Incoming TRACEROUTE
#
# Note: Only permit incoming traceroute from external hosts that have a
# reason to be tracing this network (e.g. your ISP). You can also limit
# which udp ports may be used for incoming traceroute by prior arrangement
# with those wishing to trace your network (recommended).
#
# Open: udp/33434-33523

itrace()
{
	local targets="$1" index=$2

	chains itrace $index

	for client in `combine TRACEROUTE_CLIENTS $index`
	do
		for target in $targets
		do
			# Incoming TRACEROUTE probe
			udp1 iitrace$index $client $ITRACEROUTE_SRC_PORTS $target $ITRACEROUTE_DST_PORTS $LOG
			# Incoming TRACEROUTE responses: time-exceeded, destination-unreachable
			icmp oitrace$index $target $client 11
			icmp oitrace$index $target $client 3
		done
	done
}

##############################################################################
# Outgoing TRACEROUTE
#
# Note: This can be used by local attackers to gather information about
# external hosts but it is very useful. You can restrict outgoing TRACEROUTE
# to specific hosts if you want.
#
# Open: icmp/time-exceeded,destination-unreachable

otrace()
{
	local targets="$1" index=$2

	chains otrace $index

	default_to_any TRACEROUTE_SERVERS $index

	for server in `combine TRACEROUTE_SERVERS $index`
	do
		for target in $targets
		do
			# Outgoing TRACEROUTE probe
			udp1 ootrace$index $target $OTRACEROUTE_SRC_PORTS $server $OTRACEROUTE_DST_PORTS
			# Outgoing TRACEROUTE responses: time-exceeded, destination-unreachable
			icmp iotrace$index $server $target 11
			icmp iotrace$index $server $target 3
		done
	done
}

##############################################################################
# Other ICMP packets
#
# Note: The default icmp rules allow incoming destination-unreachable and
# outgoing fragmentation-needed, incoming anad outgoing source-quench,
# incoming and outgoing time-exceeded and incoming and outgoing
# parameter-problem. There's probably no reason to change this.
#
# Open: destination-unreachable, source-quench, time-exceeded, parameter-problem

mand_icmp()
{
	local targets="$1" index=$2

	chains icmp $index

	for code in `combine OTHER_INCOMING_ICMP $index`
	do
		for target in $targets
		do
			icmp iicmp$index $any $target $code
		done
	done

	for code in `combine OTHER_OUTGOING_ICMP $index`
	do
		for target in $targets
		do
			icmp oicmp$index $target $any $code
		done
	done
}

##############################################################################
# Prevent connections to notoriously insecure services (e.g. X Windows,
# NFS, SOCKS, OpenWindows)
#
# Note: There can up to 64(?) X servers on a host, occupying one port each.
# Blocking 64 ports (whether there are actually that many X servers running or
# not) can cause problems for other services that innocently bind to those
# ports only to find that nobody can connect. If you are certain that this host
# will never run that many X servers, you can reduce the range given in
# $XWIN_PORTS to something less aggressive: 6000:6000+#Xservers-1
#

mand_danger()
{
	local targets="$1" index=$2

	chains danger $index

	# Permit specific X clients to connect
	# Note: Don't use this

	for client in `combine XWIN_CLIENTS $index`
	do
		for target in $targets
		do
			tcpsyn idanger$index $client : $target $XWIN_PORTS ACCEPT
			tcpsyn odanger$index $target : $client $XWIN_PORTS ACCEPT
		done
	done

	for ports in `combine XWIN_PORTS $index` `combine EVIL_TCP_PORTS $index`
	do
		for target in $targets
		do
			tcpsyn idanger$index $any : $target $ports $BLOCKIN $LOG
			tcpsyn odanger$index $target : $any $ports $BLOCKOUT $LOG
		done
	done

	for ports in `combine EVIL_UDP_PORTS $index`
	do
		for target in $targets
		do
			noudp1 idanger$index $any : $target $ports $BLOCKIN $LOG
			noudp1 odanger$index $target : $any $ports $BLOCKOUT $LOG
		done
	done
}

##############################################################################
# Self Spoofing
#
# Note: Most spoof detection is interface independent (see below) except for
# spoofing of this host's interfaces' addresses.
#

mand_spoof()
{
	local targets="$1" index=$2

	chain ispoof $index

	# Catch incoming packets that claim to be from this host
	if [ "$targets" != "$any" ]
	then
		for target in $targets
		do
			ipchains -A ispoof$index -s $target -j $BLOCKIN $LOG
		done
	fi
}

##############################################################################
# Other TCP Services
#
# Note: This only works for applications with a simple, single-connection
# application protocol. Also, it can't be restricted to certain external
# servers or clients. All external hosts will be allowed to engage in these
# services so it should only be used for safe applications.
#
# Open (incoming): whatever you add
# Open (outgoing): tcp(ack)/1024-4999,61000-65096

mand_user()
{
	local targets="$1" index=$2

	chains iuser $index
	chains ouser $index

	# List of ports on this host that any external host can connect to

	for port in $OTHER_INCOMING_TCP_SERVICES
	do
		for target in $targets
		do
			incoming_tcp_any user $target $port any $index
		done
	done

	# List of ports on any host that this network may connect to

	for port in $OTHER_OUTGOING_TCP_SERVICES
	do
		for target in $targets
		do
			outgoing_tcp_any user $target $port any $index
		done
	done
}

##############################################################################
# No Log
#
# After you've set up your firewall, you may find regular, harmless packets
# being blocked and logged (e.g. netbios broadcasts). If you don't want them
# to be logged, you can add port numbers and protocol names to these variables
# and they will be blocked but not logged.
#

mand_nolog()
{
	local targets="$1" index=$2

	chains nolog $index

	# Deny incoming udp packets without logging them

	for port in `combine INOLOG_UDP_PORTS $index`
	do
		for target in $targets
		do
			noudp1 inolog$index $any : $target $port $BLOCKIN
		done
	done

	# Reject outgoing udp packets without logging them

	for port in `combine ONOLOG_UDP_PORTS $index`
	do
		for target in $targets
		do
			noudp1 onolog$index $target : $any $port $BLOCKOUT
		done
	done

	# Deny incoming tcp packets without logging them

	for port in `combine INOLOG_TCP_PORTS $index`
	do
		for target in $targets
		do
			notcp1 inolog$index $any : $target $port $BLOCKIN
		done
	done

	# Reject outgoing tcp packets without logging them

	for port in `combine ONOLOG_TCP_PORTS $index`
	do
		for target in $targets
		do
			notcp1 onolog$index $target : $any $port $BLOCKOUT
		done
	done

	# Deny incoming packets for other protocols without logging them

	for protocol in `combine INOLOG_PROTO $index`
	do
		for target in $targets
		do
			ipchains -A inolog$index -p $protocol -j $BLOCKIN
		done
	done

	# Reject outgoing packets for other protocols without logging them

	for protocol in `combine ONOLOG_PROTO $index`
	do
		for target in $targets
		do
			ipchains -A onolog$index -p $protocol -j $BLOCKOUT
		done
	done
}

##############################################################################
# Forwarding
#
# If forwarding, accept all forwarded packets.
# All checks are on the input and output chains.

init_forward()
{
	ipchains -P forward ACCEPT
}

##############################################################################
# Masquerading
#
# If masquerading, masquerade packets between the internal networks and
# everywhere else but not amongst the internal networks themselves.
#
# Note: while ipchains probably can masquerade packets across multiple external
# interfaces, it seems very strange so fwup will only create rules to allow
# masquerading across the first untrusted interface.
#

init_masq()
{
	# Set masquerading timeouts

	if [ "$MASQ_TCP_TIMEOUT" != 0 -o "$MASQ_TCPFIN_TIMEOUT" != 0 -o "$MASQ_UDP_TIMEOUT" != 0 ]
	then
		ipchains -M -S ${MASQ_TCP_TIMEOUT:-0} ${MASQ_TCPFIN_TIMEOUT:-0} ${MASQ_UDP_TIMEOUT:-0}
	fi

	# Accept (unmasqueraded) traffic amongst multiple internal networks

	for src in $INTERNAL_NETWORKS
	do
		for dst in $INTERNAL_NETWORKS
		do
			if [ "$src" != "$dst" ]
			then
				ipchains -A forward -s $src -d $dst -j ACCEPT
			fi
		done
	done

	# Masquerade traffic from internal networks to the outside world

	for masqnet in $INTERNAL_NETWORKS
	do
		ipchains -A forward -s $masqnet -j MASQ
	done
}

##############################################################################
# Port Forwarding and Alias Port Forwarding
#
# Note: Port forwarding can only be started when connected. Otherwise, the
# address of the untrusted interface is 0/0 which ipmasqadm can't use.
#

init_portfw()
{
	# Handle port forwarding and alias port forwarding
	if yes "$ALIAS_PORT_FORWARDING"
	then
		# Remove any Alias Port Forwarding related policy routing rules
		set $ALIAS_PORTFW
		local fwmark=0
		while [ $# != 0 ]
		do
			fwmark="`expr $fwmark + 1`"
			local proto=$1 dstaddr=$2 dstport=$3 toaddr=$4 toport=$5 pref=$6
			shift; shift; shift; shift; shift; shift

			[ -z "$dstaddr" -o -z "$proto" -o -z "$dstport" -o -z "$toaddr" -o -z "$toport" -o -z "$pref" ] && break

			ip rule delete from $toaddr fwmark $fwmark nat $dstaddr 2>/dev/null
		done

		# Prepare for alias port forwarding
		set $ALIAS_PORTFW
		chain fwmark
		ipchains -I input -j fwmark
	else
		# There may only be one address on this interface
		dstaddr="`index UNTRUSTED_ADDRESSES 0`"
		if echo "$dstaddr" | grep "," >/dev/null
		then
			log -s "Too many addresses - use alias port porwarding instead"
			return 1
		elif [ "$dstaddr" = "$any" ]
		then
			log -s "Interface is down - leaving portfw until later"
			return 1
		fi

		# Prepare for port forwarding
		set $PORTFW
	fi

	# Flush any existing port forwarding rules
	ipmasqadm portfw -f

	# Start port forwarding
	fwmark=0
	while [ $# != 0 ]
	do
		local proto=$1
		shift

		if yes "$ALIAS_PORT_FORWARDING"
		then
			local dstaddr=$1
			shift
		fi

		local dstport=$1 toaddr=$2 toport=$3 pref=$4
		shift; shift; shift; shift

		if [ -z "$dstaddr" -o -z "$proto" -o -z "$dstport" -o -z "$toaddr" -o -z "$toport" -o -z "$pref" ]
		then
			if yes "$ALIAS_PORT_FORWARDING"
			then
				log -s "Invalid Alias Port Forwarding instruction: protocol=\"$proto\" dstaddr=\"$dstaddr\" dstport=\"$dstport\" toaddr=\"$toaddr\" toport=\"$toport\" preference=\"$pref\""
			else
				log -s "Invalid Port Forwarding instruction: protocol=\"$proto\" dstport=\"$dstport\" toaddr=\"$toaddr\" toport=\"$toport\" preference=\"$pref\""
			fi
			break
		fi

		# Port forward incoming connections to internal hosts

		ipmasqadm portfw -a -P $proto -L $dstaddr $dstport -R $toaddr $toport -p $pref

		# If multiple public ip addresses are involved, arrange for
		# reply packets to have their source addresses translated into
		# the original destination addresses of the incoming
		# connections. Otherwise, their source addresses would all be
		# that of the default route interface.

		if yes "$ALIAS_PORT_FORWARDING"
		then
			fwmark="`expr $fwmark + 1`"

			# Don't mark traffic amongst multiple internal networks
			for src in $INTERNAL_NETWORKS
			do
				for dst in $INTERNAL_NETWORKS
				do
					if [ "$src" != "$dst" ]
					then
						ipchains -A fwmark -s $src -d $dst -j RETURN
					fi
				done
			done

			# Mark traffic from internal networks to the outside world
			ipchains -A fwmark -p $proto -s $toaddr $toport -m $fwmark

			ip rule add from $toaddr fwmark $fwmark nat $dstaddr priority 10010
		fi
	done

	# Forward port ranges if required

	if not yes "$ALIAS_PORT_FORWARDING"
	then
		set $PORTRANGEFW

		# Create the fwmark chain if it wasn't created earlier
		if [ $# != 0 -a -z "$chain_fwmark" ]
		then
			chain fwmark
			ipchains -I input -j fwmark
		fi

		# Port forward marked connections to an internal host
		[ $# != 0 ] && ipmasqadm mfw -A -m 1000 -r $toaddr

		# Mark all packets in each port range for identification
		while [ $# != 0 ]
		do
			local proto=$1 portrange=$2 toaddr=$3
			shift; shift; shift

			if [ -z "$proto" -o -z "$portrange" -o -z "$toaddr" ]
			then
				log -s "Invalid Port Range Forwarding instruction: protocol=\"$proto\" portrange=\"$portrange\" toaddr=\"$toaddr\""
				break
			fi

			if echo "$portrange" | grep ":" >/dev/null
			then
				:
			else
				log -s "Invalid Port Range: portrange=\"$portrange\""
				break
			fi

			ipchains -A fwmark -p $proto -d $dstaddr $portrange -m 1000
		done
	fi
}

##############################################################################
# Static NAT
#
# Note: This does not support NAT between multiple internal networks. It is
# intentionally suppressed. If you require internal NAT, do it elsewhere
# using rule priorities less than 10000.
#

init_nat()
{
	# Remove any Static NAT related policy routing rules and routes
	set $NAT
	while [ $# != 0 ]
	do
		local dstaddr=$1 toaddr=$2
		shift; shift

		[ -z "$dstaddr" -o -z "$toaddr" ] && break

		ip route delete nat $dstaddr via $toaddr 2>/dev/null

		for src in $INTERNAL_NETWORKS
		do
			for dst in $INTERNAL_NETWORKS
			do
				if [ "$src" != "$dst" ]
				then
					ip rule delete from $src to $dst lookup main 2>/dev/null
				fi
			done
		done

		local base="${dstaddr%/*}" bits="${dstaddr#*/}"
		[ "$base" != "$dstaddr" ] && toaddr="$toaddr/$bits"
		ip rule delete from $toaddr nat $base 2>/dev/null
	done

	# Start NAT
	set $NAT
	while [ $# != 0 ]
	do
		local dstaddr=$1 toaddr=$2
		shift; shift

		if [ -z "$dstaddr" -o -z "$toaddr" ]
		then
			log -s "Invalid Static NAT instruction: dstaddr=\"$dstaddr\" toaddr=\"$toaddr\""
			break
		fi

		# Translate the destination addresses of incoming packets
		ip route add nat $dstaddr via $toaddr

		# Don't NAT when forwarding internally
		for src in $INTERNAL_NETWORKS
		do
			for dst in $INTERNAL_NETWORKS
			do
				if [ "$src" != "$dst" ]
				then
					ip rule add from $src to $dst lookup main priority 10000
				fi
			done
		done

		# Translate the source addresses of outgoing packets
		base="${dstaddr%/*}" bits="${dstaddr#*/}"
		[ "$base" != "$dstaddr" ] && toaddr="$toaddr/$bits"
		ip rule add from $toaddr nat $base priority 10010
	done
	ip route flush cache
}

##############################################################################
# Before we start creating chains, set up the policy for the top level chains
# and flush all chains.
#

do_start_filter()
{
	# Use "ipchains -Q" if possible

	yes "$IPCHAINS_QUICK" && quick_start

	# Set policies for the built-in chains

	ipchains -P input $BLOCKIN
	ipchains -P output $BLOCKOUT
	ipchains -P forward $BLOCKFWD

	# Remove all existing rules/chains

	ipchains -F
	ipchains -X

##############################################################################
# IP Spoofing
#
# Note: The kernel performs IP spoof protection as explained in the
# following extract from the "Advanced Router" section's help in the
# kernel configuration.
#
#   If you turn on IP forwarding, you will also get the rp_filter, which
#   automatically rejects incoming packets if the routing table entry
#   for their source address doesn't match the network interface they're
#   arriving on. This has security advantages because it prevents the
#   so-called IP spoofing, however it can pose problems if you use
#   asymmetric routing (packets from you to a host take a different path
#   than packets from that host to you) or if you operate a non-routing
#   host which has several IP addresses on different interfaces.
#
# If most packets take the default route, this only really protects the host
# from packets pretending to come from the internal network, not packets
# pretending to come from some external network (that you may trust to some
# extent). Following the lead of http://linux-firewall-tools.com, we at least
# guard against anyone using blatantly illegal network addresses (Perhaps this
# is done in the hope that they won't have to conflict with anyone else's
# routing tables to get return packets back(?)).
#

	chains spoof

	# Catch incoming packets that claim to be from an internal network
	for internal_network in $INTERNAL_NETWORKS
	do
		ipchains -A ispoof -s $internal_network -j $BLOCKIN $LOG
	done

	# Catch packets claiming to be to or from illegal networks
	for illegal_netork in $ILLEGAL_NETWORKS
	do
		ipchains -A ispoof -s $illegal_netork -j $BLOCKIN $LOG
		ipchains -A ispoof -d $illegal_netork -j $BLOCKIN $LOG
		ipchains -A ospoof -s $illegal_netork -j $BLOCKOUT $LOG
		ipchains -A ospoof -d $illegal_netork -j $BLOCKOUT $LOG
	done

	# Catch incoming packets with the wrong type of broadcast address
	ipchains -A ispoof -s $broadcast_dst -j $BLOCKIN $LOG
	ipchains -A ispoof -d $broadcast_src -j $BLOCKIN $LOG

	# Catch packets with a multicast source address
	ipchains -A ispoof -s $multicast -j $BLOCKIN $LOG
	ipchains -A ospoof -s $multicast -j $BLOCKOUT $LOG

	# Catch packets with a reserved source address
	ipchains -A ispoof -s $reserved  -j $BLOCKIN $LOG

	# Catch incoming packets with IANA reserved source addresses
	for reserved_network in $RESERVED_NETWORKS
	do
		ipchains -A ispoof -s $reserved_network -j $BLOCKIN $LOG
	done

##############################################################################
# Packet Fragments
#
# Note: Fragments are denied/rejected iff $IPV4_FRAGMENT_PROTECT != "no".
#
# Note: The kernel must "always defrag" so as to avoid attacks where packets
# that would not pass through the filter aren't assembled until after filtering
# so we should deny any fragments that make it this far. There shouldn't be
# any.
#
# Note: Recent kernels aren't vulnerable to this sort of attack so if you need
# to allow fragments for performance reasons, do so with a recent kernel.


	chains frag

	if not no "$IPV4_FRAGMENT_PROTECT"
	then
		ipchains -A ifrag -f -j $BLOCKIN $LOG
		ipchains -A ofrag -f -j $BLOCKOUT $LOG
	fi

##############################################################################
# Construct the chains for the untrusted interfaces. All untrusted interfaces
# are protected from spoofing, notoriously dangerous services and problematic
# networks. Each untrusted interface permits services as specified for it in
# the policy file.
#
# The SERVICE variables are composed of words of the form: service[.target]
# where service is the name of a supported service and target identifies a
# TARGET_* variable containing the set of ip addresses that require the
# service. If the target is omitted, the target is the addresses of the
# current interface.
#

	i=-1
	for untrusted in $UNTRUSTED_INTERFACES
	do
		# Each untrusted interface has a number from 0 to 9.
		i=`expr $i + 1`

		# There may be aliases and hence multiple ip addresses.
		TARGET_self="`index UNTRUSTED_ADDRESSES $i | sed 's/,/ /g'`"

		# Create incoming and outgoing chains for the untrusted network interface
		# Note: May not work for things like ppp+
		chains $untrusted

		# Disallow spoofing
		mand_spoof "$TARGET_self" "$i"
		ipchains -A i$untrusted -j ispoof$i
		# Only perform full spoof protection on external untrusted interfaces
		if not member $untrusted $INTERNAL_UNTRUSTED_INTERFACES
		then
			ipchains -A i$untrusted -j ispoof
			ipchains -A o$untrusted -j ospoof
		fi

		# Disallow all packets between this network and untrusted networks
		# Note: This is not particularly useful. If it's really hostile,
		# they can spoof some other network's addresses anyway. In fact,
		# they may have been doing so all along.
		for untrusted_network in $UNTRUSTED_NETWORKS
		do
			ipchains -A i$untrusted -s $untrusted_network -j $BLOCKIN $LOG
			ipchains -A o$untrusted -d $untrusted_network -j $BLOCKOUT $LOG
		done

		# Add the input/output rule chains to deny dangerous services
		mand_danger "$any" "$i"
		ipchains -A i$untrusted -j idanger$i
		ipchains -A o$untrusted -j odanger$i

		# Add the input/output rule chains to allow requested services
		for service in `combine SERVICES $i`
		do
			# Extract the service name and target (no target implies self)
			service_name="${service%.*}"
			service_target="${service#*.}"
			[ "$service" = "$service_name" ] && service_target="self"
			eval target=\"\$TARGET_$service_target\"

			if [ -z "$target" ]
			then
				log -s "Failed to find target for $service_name: \$TARGET_$service_target"
				continue
			fi

			if not typeset -f $service_name >/dev/null
			then
				log -s "$service_name is not a recognised service name"
				continue
			fi

			# Add rules for this target to the service chain for this interface
			$service_name "$target" "$i"

			# Install the service chain for this interface unless already done
			eval [ -z "\$installed_${untrusted}_$service_name$i" ] || continue
			eval installed_${untrusted}_$service_name$i="1"
			ipchains -A i$untrusted -j i$service_name$i
			ipchains -A o$untrusted -j o$service_name$i
		done

		mand_user "$any" "$i"
		mand_icmp "$any" "$i"
		mand_nolog "$any" "$i"

		for service in iuser$i ouser$i icmp$i frag nolog$i
		do
			ipchains -A i$untrusted -j i$service
			ipchains -A o$untrusted -j o$service
		done
	done

##############################################################################
# Finally, start filtering packets. Set up the built-in chains. Packets on
# trusted interfaces are accepted. Packets on untrusted interfaces must pass
# their respective rule chains. All packets that don't match any terminal
# rule are logged if requested. Masquerading begins here as well if requested.
#

	# Accept all packets on trusted interfaces

	for trusted in $TRUSTED_INTERFACES
	do
		ipchains -A input  -i $trusted -j ACCEPT
		ipchains -A output -i $trusted -j ACCEPT
	done

	# Direct packets through each untrusted interface's direction-based chains

	for untrusted in $UNTRUSTED_INTERFACES
	do
		ipchains -A input  -i $untrusted -j i$untrusted
		ipchains -A output -i $untrusted -j o$untrusted
	done

	# Setup network role

	yes "$FORWARDING" && init_forward
	yes "$MASQUERADING" && init_masq
	yes "$PORT_FORWARDING" && init_portfw
	yes "$STATIC_NAT" && init_nat

	# Log all packets that reach the end of their chain

	if [ ! -z "$LOG" ]
	then
		ipchains -A input $LOG
		ipchains -A output $LOG
		ipchains -A forward $LOG
	fi

	not yes "$IPCHAINS_QUICK" || quick_run
}

action "Starting IP Packet Filter" do_start_filter

##############################################################################
# Load IP Masquerading Modules
#

if yes "$MASQUERADING"
then
	if [ -r /proc/modules -a -n "$MASQ_MODULES" ]
	then
		do_load_modules()
		{
			local required="0" loaded="0" module

			for module in $MASQ_MODULES
			do
				if grep ip_masq_$module /proc/modules >/dev/null
				then
					continue
				fi
				required="`expr $required + 1`"
				eval modprobe ip_masq_$module \$MASQ_MODULES_$module && loaded="`expr $loaded + 1`"
			done

			[ "$loaded" = "$required" ]
		}

		action "Loading IP Masquerading Modules" do_load_modules
	fi
fi

##############################################################################
# Start IP Destination Loose UDP Masquerading
#

if yes "$IPV4_MASQ_UDP_DEST_LOOSE"
then
	do_start_dloose()
	{
		[ -w $ipv4/ip_masq_udp_dloose ] && echo 1 > $ipv4/ip_masq_udp_dloose
	}

	action "Starting IP Destination Loose UDP Masquerading" do_start_dloose
fi

##############################################################################
# Start IP Source Address Verification
#

if not no "$IPV4_SPOOF_PROTECT"
then
	do_start_spoof()
	{
		if [ -w $ipv4/conf/all/rp_filter ]
		then
			for procfile in $ipv4/conf/*/rp_filter
			do
				echo 1 > $procfile
			done
		fi
	}

	action "Starting IP Source Address Verification" do_start_spoof
fi

##############################################################################
# Start IP Source Routing Protection
#

if not no "$IPV4_SOURCE_ROUTE_PROTECT"
then
	do_start_sourceroute()
	{
		if [ -w $ipv4/conf/all/accept_source_route ]
		then
			for procfile in $ipv4/conf/*/accept_source_route
			do
				echo 0 > $procfile
			done
		fi
	}

	action "Starting IP Source Routing Protection" do_start_sourceroute
fi

##############################################################################
# Start IP ICMP Redirect Protection
#

if not no "$IPV4_ICMP_REDIRECT_PROTECT"
then
	do_start_redirect()
	{
		if [ -w $ipv4/conf/all/accept_redirects ]
		then
			for procfile in $ipv4/conf/*/accept_redirects
			do
				echo 0 > $procfile
			done
		fi
	}

	action "Starting IP ICMP Redirect Protection" do_start_redirect
fi

##############################################################################
# Start IP TCP SYN Cookie Protection
#

if not no "$IPV4_TCP_SYN_COOKIE_PROTECT"
then
	do_start_syncookie()
	{
		[ -w $ipv4/tcp_syncookies ] && echo 1 > $ipv4/tcp_syncookies
	}

	action "Starting IP TCP SYN Cookie Protection" do_start_syncookie
fi

##############################################################################
# Start IP Fragment Protection
#

if not no "$IPV4_FRAGMENT_PROTECT"
then
	do_start_fragment()
	{
		[ -w $ipv4/ip_always_defrag ] && echo 1 > $ipv4/ip_always_defrag
	}

	action "Starting IP Fragment Protection" do_start_fragment
fi

##############################################################################
# Start IP ICMP Broadcast Echo Protection
#

if not no "$IPV4_ICMP_BROADCAST_ECHO_PROTECT"
then
	do_start_icmp()
	{
		[ -w $ipv4/icmp_echo_ignore_broadcasts ] && echo 1 > $ipv4/icmp_echo_ignore_broadcasts
	}

	action "Starting IP ICMP Broadcast Echo Protection" do_start_icmp
fi

##############################################################################
# Start IP Bogus Error Response Protection
#

if not no "$IPV4_BOGUS_ERROR_RESPONSE_PROTECT"
then
	do_start_bogus()
	{
		[ -w $ipv4/icmp_ignore_bogus_error_responses ] && echo 1 > $ipv4/icmp_ignore_bogus_error_responses
	}

	action "Starting IP Bogus Error Response Protection" do_start_bogus
fi

##############################################################################
# Start IP Martian Logging
#

if not no "$IPV4_LOG_MARTIANS"
then
	do_start_martian()
	{
		if [ -w $ipv4/conf/all/log_martians ]
		then
			for procfile in $ipv4/conf/*/log_martians
			do
				echo 0 > $procfile
			done
		fi
	}

	action "Starting IP Martian Logging" do_start_martian
fi

##############################################################################
# Start Dynamic IP Address Hacking in IP MASQ
#

if yes "$IPV4_DYNADDR"
then
	do_start_dynaddr()
	{
		[ -w $ipv4/ip_dynaddr ] && echo 1 > $ipv4/ip_dynaddr
	}

	action "Starting Dynamic IP Address Hacking in IP MASQ" do_start_dynaddr
fi

##############################################################################
# Start IP Packet Forwarding
#

start_forwarding="0"
yes "$FORWARDING" && start_forwarding="1"
yes "$MASQUERADING" && start_forwarding="1"
yes "$STATIC_NAT" && start_forwarding="1"

if [ "$start_forwarding" = "1" ]
then
	do_start_forwarding()
	{
		[ -w $ipv4/ip_forward ] && echo 1 > $ipv4/ip_forward
	}

	action "Starting IP Packet Forwarding" do_start_forwarding
fi

exit 0

# vi:set ts=4 sw=4:
